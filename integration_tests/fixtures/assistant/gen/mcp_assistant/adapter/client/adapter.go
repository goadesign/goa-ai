// Code generated by goa v3.24.2, DO NOT EDIT.
//
// MCP client adapter exposing original service endpoints
//
// Command:
// $ goa gen example.com/assistant/design

package mcpAssistantadapter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"sort"
	"strings"

	assistant "example.com/assistant/gen/assistant"
	assistantjsonrpcc "example.com/assistant/gen/jsonrpc/assistant/client"
	mcpAssistantjsonrpcc "example.com/assistant/gen/jsonrpc/mcp_assistant/client"
	mcpAssistant "example.com/assistant/gen/mcp_assistant"
	retry "goa.design/goa-ai/runtime/mcp/retry"
	goahttp "goa.design/goa/v3/http"
	jsonrpc "goa.design/goa/v3/jsonrpc"
)

// NewEndpoints creates endpoints that expose the original service API while
// invoking the MCP transport under the hood for mapped methods. Unmapped
// methods transparently fall back to the original JSON-RPC transport.
// NewEndpoints creates an Endpoints set that routes mapped methods through
// the MCP transport while leaving unmapped methods on the original transport.
func NewEndpoints(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Endpoints {
	// Transport clients
	mcpC := mcpAssistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)
	origC := assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)

	// Build endpoints matching the original service
	e := &assistant.Endpoints{}
	// Tool: analyze_sentiment -> AnalyzeSentiment
	e.AnalyzeSentiment = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.AnalyzeSentimentPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "analyze_sentiment", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:analyze_sentiment", err.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to analyze\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for analyze_sentiment")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:analyze_sentiment", recvErr.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to analyze\"}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:analyze_sentiment", "empty MCP tool response", "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to analyze\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for analyze_sentiment")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildAnalyzeSentimentRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeAnalyzeSentimentResponse(dec, false)
		return decode(resp)
	}
	// Tool: extract_keywords -> ExtractKeywords
	e.ExtractKeywords = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.ExtractKeywordsPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "extract_keywords", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:extract_keywords", err.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for extract_keywords")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:extract_keywords", recvErr.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text\"}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:extract_keywords", "empty MCP tool response", "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for extract_keywords")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildExtractKeywordsRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeExtractKeywordsResponse(dec, false)
		return decode(resp)
	}
	// Tool: summarize_text -> SummarizeText
	e.SummarizeText = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.SummarizeTextPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "summarize_text", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:summarize_text", err.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to summarize\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for summarize_text")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:summarize_text", recvErr.Error(), "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to summarize\"}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:summarize_text", "empty MCP tool response", "{\"text\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"text\"],\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Input text to summarize\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for summarize_text")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildSummarizeTextRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeSummarizeTextResponse(dec, false)
		return decode(resp)
	}
	// Tool: search -> Search
	e.Search = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.SearchPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "search", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:search", err.Error(), "{\"limit\":1,\"query\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"query\"],\"properties\":{\"limit\":{\"type\":\"integer\",\"description\":\"Maximum number of results\"},\"query\":{\"type\":\"string\",\"description\":\"Search query\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for search")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:search", recvErr.Error(), "{\"limit\":1,\"query\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"query\"],\"properties\":{\"limit\":{\"type\":\"integer\",\"description\":\"Maximum number of results\"},\"query\":{\"type\":\"string\",\"description\":\"Search query\"}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:search", "empty MCP tool response", "{\"limit\":1,\"query\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"query\"],\"properties\":{\"limit\":{\"type\":\"integer\",\"description\":\"Maximum number of results\"},\"query\":{\"type\":\"string\",\"description\":\"Search query\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for search")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildSearchRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeSearchResponse(dec, false)
		return decode(resp)
	}
	// Tool: execute_code -> ExecuteCode
	e.ExecuteCode = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.ExecuteCodePayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "execute_code", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:execute_code", err.Error(), "{\"code\":\"abc123\",\"language\":\"javascript\"}", "{\"type\":\"object\",\"required\":[\"language\",\"code\"],\"properties\":{\"code\":{\"type\":\"string\",\"description\":\"Code to execute\"},\"language\":{\"type\":\"string\",\"description\":\"Language to execute\",\"enum\":[\"python\",\"javascript\"]}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for execute_code")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:execute_code", recvErr.Error(), "{\"code\":\"abc123\",\"language\":\"javascript\"}", "{\"type\":\"object\",\"required\":[\"language\",\"code\"],\"properties\":{\"code\":{\"type\":\"string\",\"description\":\"Code to execute\"},\"language\":{\"type\":\"string\",\"description\":\"Language to execute\",\"enum\":[\"python\",\"javascript\"]}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:execute_code", "empty MCP tool response", "{\"code\":\"abc123\",\"language\":\"javascript\"}", "{\"type\":\"object\",\"required\":[\"language\",\"code\"],\"properties\":{\"code\":{\"type\":\"string\",\"description\":\"Code to execute\"},\"language\":{\"type\":\"string\",\"description\":\"Language to execute\",\"enum\":[\"python\",\"javascript\"]}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for execute_code")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildExecuteCodeRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeExecuteCodeResponse(dec, false)
		return decode(resp)
	}
	// Tool: process_batch -> ProcessBatch
	e.ProcessBatch = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.ProcessBatchPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "process_batch", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:process_batch", err.Error(), "{\"blob\":\"abc123\",\"format\":\"text\",\"items\":[\"abc123\"],\"mimeType\":\"abc123\",\"uri\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"items\"],\"properties\":{\"blob\":{\"type\":\"string\",\"description\":\"Base64 blob\"},\"format\":{\"type\":\"string\",\"description\":\"Output format\",\"enum\":[\"json\",\"text\",\"blob\",\"uri\"]},\"items\":{\"type\":\"array\",\"description\":\"Items to process\",\"items\":{\"type\":\"string\"}},\"mimeType\":{\"type\":\"string\",\"description\":\"MIME type\"},\"uri\":{\"type\":\"string\",\"description\":\"Resource URI\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for process_batch")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:process_batch", recvErr.Error(), "{\"blob\":\"abc123\",\"format\":\"text\",\"items\":[\"abc123\"],\"mimeType\":\"abc123\",\"uri\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"items\"],\"properties\":{\"blob\":{\"type\":\"string\",\"description\":\"Base64 blob\"},\"format\":{\"type\":\"string\",\"description\":\"Output format\",\"enum\":[\"json\",\"text\",\"blob\",\"uri\"]},\"items\":{\"type\":\"array\",\"description\":\"Items to process\",\"items\":{\"type\":\"string\"}},\"mimeType\":{\"type\":\"string\",\"description\":\"MIME type\"},\"uri\":{\"type\":\"string\",\"description\":\"Resource URI\"}},\"additionalProperties\":false}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:process_batch", "empty MCP tool response", "{\"blob\":\"abc123\",\"format\":\"text\",\"items\":[\"abc123\"],\"mimeType\":\"abc123\",\"uri\":\"abc123\"}", "{\"type\":\"object\",\"required\":[\"items\"],\"properties\":{\"blob\":{\"type\":\"string\",\"description\":\"Base64 blob\"},\"format\":{\"type\":\"string\",\"description\":\"Output format\",\"enum\":[\"json\",\"text\",\"blob\",\"uri\"]},\"items\":{\"type\":\"array\",\"description\":\"Items to process\",\"items\":{\"type\":\"string\"}},\"mimeType\":{\"type\":\"string\",\"description\":\"MIME type\"},\"uri\":{\"type\":\"string\",\"description\":\"Resource URI\"}},\"additionalProperties\":false}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for process_batch")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildProcessBatchRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeProcessBatchResponse(dec, false)
		return decode(resp)
	}
	// Resource: doc://list -> ListDocuments
	e.ListDocuments = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "doc://list"
		{
			var payload any
			payload = struct{}{}
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for doc://list")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildListDocumentsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeListDocumentsResponse(dec, false)
		return decode(resp)
	}
	// Resource: system://info -> SystemInfo
	e.SystemInfo = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "system://info"
		{
			var payload any
			payload = struct{}{}
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for system://info")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildSystemInfoRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeSystemInfoResponse(dec, false)
		return decode(resp)
	}
	// Resource: conversation://history -> ConversationHistory
	e.ConversationHistory = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "conversation://history"
		{
			var payload any
			payload = v.(*assistant.ConversationHistoryPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for conversation://history")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildConversationHistoryRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeConversationHistoryResponse(dec, false)
		return decode(resp)
	}
	// Dynamic Prompt: contextual_prompts -> GeneratePrompts
	e.GeneratePrompts = func(ctx context.Context, v any) (any, error) {
		var args []byte
		{
			var payload any
			payload = v.(*assistant.GeneratePromptsPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}
		ires, err := mcpC.PromptsGet()(ctx, &mcpAssistant.PromptsGetPayload{Name: "contextual_prompts", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("prompts/get:contextual_prompts", err.Error(), "{\"context\":\"abc123\",\"task\":\"abc123\"}", "")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		r := ires.(*mcpAssistant.PromptsGetResult)
		if r == nil || r.Messages == nil || len(r.Messages) == 0 || r.Messages[0] == nil || r.Messages[0].Content == nil || r.Messages[0].Content.Text == nil {
			prompt := retry.BuildRepairPrompt("prompts/get:contextual_prompts", "empty MCP prompt response", "{\"context\":\"abc123\",\"task\":\"abc123\"}", "")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP prompt response for contextual_prompts")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Messages[0].Content.Text)}
		req3, _ := origC.BuildGeneratePromptsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGeneratePromptsResponse(dec, false)
		return decode(resp)
	}

	return e
}

// NewClient returns *assistant.Client using MCP-backed endpoints.
func NewClient(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Client {
	e := NewEndpoints(scheme, host, doer, enc, dec, restore)
	origClient := assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)
	return assistant.NewClient(
		e.ListDocuments,
		e.SystemInfo,
		e.ConversationHistory,
		e.GeneratePrompts,
		origClient.SendNotification(),
		e.AnalyzeSentiment,
		e.ExtractKeywords,
		e.SummarizeText,
		e.Search,
		e.ExecuteCode,
		e.ProcessBatch,
	)
}
