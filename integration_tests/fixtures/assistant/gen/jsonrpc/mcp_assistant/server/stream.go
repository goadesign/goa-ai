// Code generated by goa v3.24.2, DO NOT EDIT.
//
// stream
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	mcpassistant "example.com/assistant/gen/mcp_assistant"
	goahttp "goa.design/goa/v3/http"
	"goa.design/goa/v3/jsonrpc"
	goa "goa.design/goa/v3/pkg"
)

// ToolsCallServerStream implements the mcpassistant.ToolsCallServerStream
// interface using Server-Sent Events.
type ToolsCallServerStream struct {
	// once ensures headers are written once
	once sync.Once
	// encoder is the SSE event encoder
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder
	// w is the HTTP response writer
	w http.ResponseWriter
	// r is the HTTP request
	r *http.Request
	// requestID is the JSON-RPC request ID for sending final response
	requestID any
	// closed indicates if the stream has been closed via SendAndClose
	closed bool
	// mu protects the closed flag
	mu sync.Mutex
}

// sseEventWriter wraps http.ResponseWriter to format output as SSE events.
type toolsCallServerStreamEventWriter struct {
	w         http.ResponseWriter
	eventType string
	started   bool
}

func (s *toolsCallServerStreamEventWriter) Header() http.Header        { return s.w.Header() }
func (s *toolsCallServerStreamEventWriter) WriteHeader(statusCode int) { s.w.WriteHeader(statusCode) }
func (s *toolsCallServerStreamEventWriter) Write(data []byte) (int, error) {
	if !s.started {
		s.started = true
		if s.eventType != "" {
			fmt.Fprintf(s.w, "event: %s\n", s.eventType)
		}
		s.w.Write([]byte("data: "))
	}
	return s.w.Write(data)
}

func (s *toolsCallServerStreamEventWriter) finish() {
	if s.started {
		s.w.Write([]byte("\n\n"))
		http.NewResponseController(s.w).Flush()
	}
}

// Send sends a JSON-RPC notification to the client.
// Notifications do not expect a response from the client.
func (s *ToolsCallServerStream) Send(ctx context.Context, event mcpassistant.ToolsCallEvent) error {
	// Check if stream is closed
	s.mu.Lock()
	if s.closed {
		s.mu.Unlock()
		return fmt.Errorf("stream closed")
	}
	s.mu.Unlock()

	// Type assert to the specific result type
	result, ok := event.(*mcpassistant.ToolsCallResult)
	if !ok {
		return fmt.Errorf("unexpected event type: %T", event)
	}
	// Convert to response body type for proper JSON encoding
	body := NewToolsCallResponseBody(result)

	// Send as notification (no ID)
	message := map[string]any{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params":  body,
	}

	return s.sendSSEEvent("notification", message)
}

// SendAndClose sends a final JSON-RPC response to the client and closes the
// stream.
// The response will include the original request ID unless the result has an
// ID field populated.
// After calling this method, no more events can be sent on this stream.
func (s *ToolsCallServerStream) SendAndClose(ctx context.Context, event mcpassistant.ToolsCallEvent) error {
	// Check if stream is already closed
	s.mu.Lock()
	if s.closed {
		s.mu.Unlock()
		return fmt.Errorf("stream already closed")
	}
	s.closed = true
	s.mu.Unlock()

	// Type assert to the specific result type
	result, ok := event.(*mcpassistant.ToolsCallResult)
	if !ok {
		return fmt.Errorf("unexpected event type: %T", event)
	}

	// Determine the ID to use for the response
	var id any = s.requestID
	// Convert to response body type for proper JSON encoding
	body := NewToolsCallResponseBody(result)

	// Send as response with ID
	message := map[string]any{
		"jsonrpc": "2.0",
		"id":      id,
		"result":  body,
	}

	return s.sendSSEEvent("response", message)
}

// SendError sends a JSON-RPC error response.
func (s *ToolsCallServerStream) SendError(ctx context.Context, id string, err error) error {
	// No custom errors defined - check if it's a validation error, otherwise use
	// internal error
	code := jsonrpc.InternalError
	if _, ok := err.(*goa.ServiceError); ok {
		code = jsonrpc.InvalidParams
	}
	return s.sendError(ctx, id, code, err.Error(), nil)
}

// sendError sends a JSON-RPC error response via SSE.
func (s *ToolsCallServerStream) sendError(ctx context.Context, id any, code jsonrpc.Code, message string, data any) error {
	response := jsonrpc.MakeErrorResponse(id, code, message, data)
	return s.sendSSEEvent("error", response)
}

// sendSSEEvent sends a single SSE event by creating an encoder that writes to
// the event writer
func (s *ToolsCallServerStream) sendSSEEvent(eventType string, v any) error {
	// Ensure headers are sent once
	s.once.Do(func() {
		s.w.Header().Set("Content-Type", "text/event-stream")
		s.w.Header().Set("Cache-Control", "no-cache")
		s.w.Header().Set("Connection", "keep-alive")
		s.w.Header().Set("X-Accel-Buffering", "no")
		s.w.WriteHeader(http.StatusOK)
	})

	// Create SSE event writer that wraps the response writer
	ew := &toolsCallServerStreamEventWriter{w: s.w, eventType: eventType}

	// Create encoder with the event writer and encode the value
	err := s.encoder(context.Background(), ew).Encode(v)

	// Finish the SSE event (adds newlines and flushes)
	ew.finish()

	return err
}

// EventsStreamServerStream implements the
// mcpassistant.EventsStreamServerStream interface using Server-Sent Events.
type EventsStreamServerStream struct {
	// once ensures headers are written once
	once sync.Once
	// encoder is the SSE event encoder
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder
	// w is the HTTP response writer
	w http.ResponseWriter
	// r is the HTTP request
	r *http.Request
	// requestID is the JSON-RPC request ID for sending final response
	requestID any
	// closed indicates if the stream has been closed via SendAndClose
	closed bool
	// mu protects the closed flag
	mu sync.Mutex
}

// sseEventWriter wraps http.ResponseWriter to format output as SSE events.
type eventsStreamServerStreamEventWriter struct {
	w         http.ResponseWriter
	eventType string
	started   bool
}

func (s *eventsStreamServerStreamEventWriter) Header() http.Header { return s.w.Header() }
func (s *eventsStreamServerStreamEventWriter) WriteHeader(statusCode int) {
	s.w.WriteHeader(statusCode)
}
func (s *eventsStreamServerStreamEventWriter) Write(data []byte) (int, error) {
	if !s.started {
		s.started = true
		if s.eventType != "" {
			fmt.Fprintf(s.w, "event: %s\n", s.eventType)
		}
		s.w.Write([]byte("data: "))
	}
	return s.w.Write(data)
}

func (s *eventsStreamServerStreamEventWriter) finish() {
	if s.started {
		s.w.Write([]byte("\n\n"))
		http.NewResponseController(s.w).Flush()
	}
}

// Send sends a JSON-RPC notification to the client.
// Notifications do not expect a response from the client.
func (s *EventsStreamServerStream) Send(ctx context.Context, event mcpassistant.EventsStreamEvent) error {
	// Check if stream is closed
	s.mu.Lock()
	if s.closed {
		s.mu.Unlock()
		return fmt.Errorf("stream closed")
	}
	s.mu.Unlock()

	// Type assert to the specific result type
	result, ok := event.(*mcpassistant.EventsStreamResult)
	if !ok {
		return fmt.Errorf("unexpected event type: %T", event)
	}
	// Convert to response body type for proper JSON encoding
	body := NewEventsStreamResponseBody(result)

	// Send as notification (no ID)
	message := map[string]any{
		"jsonrpc": "2.0",
		"method":  "events/stream",
		"params":  body,
	}

	return s.sendSSEEvent("notification", message)
}

// SendAndClose sends a final JSON-RPC response to the client and closes the
// stream.
// The response will include the original request ID unless the result has an
// ID field populated.
// After calling this method, no more events can be sent on this stream.
func (s *EventsStreamServerStream) SendAndClose(ctx context.Context, event mcpassistant.EventsStreamEvent) error {
	// Check if stream is already closed
	s.mu.Lock()
	if s.closed {
		s.mu.Unlock()
		return fmt.Errorf("stream already closed")
	}
	s.closed = true
	s.mu.Unlock()

	// Type assert to the specific result type
	result, ok := event.(*mcpassistant.EventsStreamResult)
	if !ok {
		return fmt.Errorf("unexpected event type: %T", event)
	}

	// Determine the ID to use for the response
	var id any = s.requestID
	// Convert to response body type for proper JSON encoding
	body := NewEventsStreamResponseBody(result)

	// Send as response with ID
	message := map[string]any{
		"jsonrpc": "2.0",
		"id":      id,
		"result":  body,
	}

	return s.sendSSEEvent("response", message)
}

// SendError sends a JSON-RPC error response.
func (s *EventsStreamServerStream) SendError(ctx context.Context, id string, err error) error {
	// No custom errors defined - check if it's a validation error, otherwise use
	// internal error
	code := jsonrpc.InternalError
	if _, ok := err.(*goa.ServiceError); ok {
		code = jsonrpc.InvalidParams
	}
	return s.sendError(ctx, id, code, err.Error(), nil)
}

// sendError sends a JSON-RPC error response via SSE.
func (s *EventsStreamServerStream) sendError(ctx context.Context, id any, code jsonrpc.Code, message string, data any) error {
	response := jsonrpc.MakeErrorResponse(id, code, message, data)
	return s.sendSSEEvent("error", response)
}

// sendSSEEvent sends a single SSE event by creating an encoder that writes to
// the event writer
func (s *EventsStreamServerStream) sendSSEEvent(eventType string, v any) error {
	// Ensure headers are sent once
	s.once.Do(func() {
		s.w.Header().Set("Content-Type", "text/event-stream")
		s.w.Header().Set("Cache-Control", "no-cache")
		s.w.Header().Set("Connection", "keep-alive")
		s.w.Header().Set("X-Accel-Buffering", "no")
		s.w.WriteHeader(http.StatusOK)
	})

	// Create SSE event writer that wraps the response writer
	ew := &eventsStreamServerStreamEventWriter{w: s.w, eventType: eventType}

	// Create encoder with the event writer and encode the value
	err := s.encoder(context.Background(), ew).Encode(v)

	// Finish the SSE event (adds newlines and flushes)
	ew.finish()

	return err
}
