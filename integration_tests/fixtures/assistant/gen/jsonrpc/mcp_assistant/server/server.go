// Code generated by goa v3.24.1, DO NOT EDIT.
//
// mcp_assistant JSON-RPC server
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"

	mcpassistant "example.com/assistant/gen/mcp_assistant"
	goahttp "goa.design/goa/v3/http"
	"goa.design/goa/v3/jsonrpc"
	goa "goa.design/goa/v3/pkg"
)

// Server handles JSON-RPC requests for the mcp_assistant service.
type Server struct {
	http.Handler
	// Methods is the list of methods served by this server.
	Methods []string

	// Initialize is the handler for the initialize method.
	Initialize func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// Ping is the handler for the ping method.
	Ping func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ToolsList is the handler for the tools/list method.
	ToolsList func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ToolsCall is the handler for the tools/call method.
	ToolsCall func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ResourcesList is the handler for the resources/list method.
	ResourcesList func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ResourcesRead is the handler for the resources/read method.
	ResourcesRead func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ResourcesSubscribe is the handler for the resources/subscribe method.
	ResourcesSubscribe func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ResourcesUnsubscribe is the handler for the resources/unsubscribe method.
	ResourcesUnsubscribe func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// PromptsList is the handler for the prompts/list method.
	PromptsList func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// PromptsGet is the handler for the prompts/get method.
	PromptsGet func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// NotifyStatusUpdate is the handler for the notify_status_update method.
	NotifyStatusUpdate func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// EventsStream is the handler for the events/stream method.
	EventsStream func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error

	decoder    func(*http.Request) goahttp.Decoder
	encoder    func(context.Context, http.ResponseWriter) goahttp.Encoder
	errhandler func(context.Context, http.ResponseWriter, error)
}

// New creates a JSON-RPC server which loads HTTP requests and calls the
// "mcp_assistant" service methods.
func New(
	endpoints *mcpassistant.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) *Server {
	s := &Server{
		Methods: []string{
			"initialize",
			"ping",
			"tools/list",
			"tools/call",
			"resources/list",
			"resources/read",
			"resources/subscribe",
			"resources/unsubscribe",
			"prompts/list",
			"prompts/get",
			"notify_status_update",
			"events/stream",
		},
		Initialize:           NewInitializeHandler(endpoints.Initialize, mux, decoder, encoder, errhandler),
		Ping:                 NewPingHandler(endpoints.Ping, mux, decoder, encoder, errhandler),
		ToolsList:            NewToolsListHandler(endpoints.ToolsList, mux, decoder, encoder, errhandler),
		ToolsCall:            NewToolsCallHandler(endpoints.ToolsCall, mux, decoder, encoder, errhandler),
		ResourcesList:        NewResourcesListHandler(endpoints.ResourcesList, mux, decoder, encoder, errhandler),
		ResourcesRead:        NewResourcesReadHandler(endpoints.ResourcesRead, mux, decoder, encoder, errhandler),
		ResourcesSubscribe:   NewResourcesSubscribeHandler(endpoints.ResourcesSubscribe, mux, decoder, encoder, errhandler),
		ResourcesUnsubscribe: NewResourcesUnsubscribeHandler(endpoints.ResourcesUnsubscribe, mux, decoder, encoder, errhandler),
		PromptsList:          NewPromptsListHandler(endpoints.PromptsList, mux, decoder, encoder, errhandler),
		PromptsGet:           NewPromptsGetHandler(endpoints.PromptsGet, mux, decoder, encoder, errhandler),
		NotifyStatusUpdate:   NewNotifyStatusUpdateHandler(endpoints.NotifyStatusUpdate, mux, decoder, encoder, errhandler),
		EventsStream:         NewEventsStreamHandler(endpoints.EventsStream, mux, decoder, encoder, errhandler),
		decoder:              decoder,
		encoder:              encoder,
		errhandler:           errhandler,
	}
	// Default HTTP handler per transport kind
	// Plain HTTP JSON-RPC
	s.Handler = http.HandlerFunc(s.ServeHTTP)
	return s
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "mcp_assistant" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.Handler = m(s.Handler)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return mcpassistant.MethodNames[:] }

// ServeHTTP handles JSON-RPC requests with content negotiation for mixed HTTP/SSE transports.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Check Accept header for SSE
	accept := r.Header.Get("Accept")
	if strings.Contains(accept, "text/event-stream") {
		// Route to SSE handler for streaming methods
		s.handleSSE(w, r)
		return
	}

	// Otherwise handle as regular JSON-RPC HTTP request
	s.handleHTTP(w, r)
}

// handleHTTP handles JSON-RPC requests.
func (s *Server) handleHTTP(w http.ResponseWriter, r *http.Request) {
	// Peek at the first byte to determine request type
	bufReader := bufio.NewReader(r.Body)
	peek, err := bufReader.Peek(1)
	if err != nil && err != io.EOF {
		r.Body.Close()
		s.errhandler(r.Context(), w, fmt.Errorf("failed to read request body: %w", err))
		return
	}

	// Wrap the buffered reader with the original closer
	r.Body = struct {
		io.Reader
		io.Closer
	}{
		Reader: bufReader,
		Closer: r.Body,
	}
	defer func(r *http.Request) {
		if err := r.Body.Close(); err != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to close request body: %w", err))
		}
	}(r)

	// Route to appropriate handler
	if len(peek) > 0 && peek[0] == '[' {
		s.handleBatch(w, r)
		return
	}
	s.handleSingle(w, r)
}

// handleSingle handles a single JSON-RPC request.
func (s *Server) handleSingle(w http.ResponseWriter, r *http.Request) {
	var req jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&req); err != nil {
		// JSON-RPC parse error with null id and generic message
		response := jsonrpc.MakeErrorResponse(nil, jsonrpc.ParseError, "Parse error", nil)
		if encErr := s.encoder(r.Context(), w).Encode(response); encErr != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to encode parse error response: %w", encErr))
		}
		return
	}
	s.processRequest(r.Context(), r, &req, w)
}

// handleBatch handles a batch of JSON-RPC requests.
func (s *Server) handleBatch(w http.ResponseWriter, r *http.Request) {
	var reqs []jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&reqs); err != nil {
		// JSON-RPC parse error for batch with null id and generic message
		response := jsonrpc.MakeErrorResponse(nil, jsonrpc.ParseError, "Parse error", nil)
		if encErr := s.encoder(r.Context(), w).Encode(response); encErr != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to encode parse error response: %w", encErr))
		}
		return
	}

	// Write responses
	w.Header().Set("Content-Type", "application/json")
	writer := &batchWriter{Writer: w}

	for _, req := range reqs {
		// Process the request with batch writer
		s.processRequest(r.Context(), r, &req, writer)
	}

	// Close the batch array
	if writer.written {
		writer.Writer.Write([]byte{']'})
	}
}

// ProcessRequest processes a single JSON-RPC request.
func (s *Server) processRequest(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) {
	if req.JSONRPC != "2.0" {
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidRequest, "Invalid request", nil)
		return
	}

	if req.Method == "" {
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidRequest, "Missing method field", nil)
		return
	}

	switch req.Method {
	case "initialize":
		if err := s.Initialize(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "initialize", err))
		}
	case "ping":
		if err := s.Ping(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "ping", err))
		}
	case "tools/list":
		if err := s.ToolsList(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "tools/list", err))
		}
	case "tools/call":
		if err := s.ToolsCall(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "tools/call", err))
		}
	case "resources/list":
		if err := s.ResourcesList(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "resources/list", err))
		}
	case "resources/read":
		if err := s.ResourcesRead(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "resources/read", err))
		}
	case "resources/subscribe":
		if err := s.ResourcesSubscribe(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "resources/subscribe", err))
		}
	case "resources/unsubscribe":
		if err := s.ResourcesUnsubscribe(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "resources/unsubscribe", err))
		}
	case "prompts/list":
		if err := s.PromptsList(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "prompts/list", err))
		}
	case "prompts/get":
		if err := s.PromptsGet(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "prompts/get", err))
		}
	case "notify_status_update":
		if err := s.NotifyStatusUpdate(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "notify_status_update", err))
		}
	case "events/stream":
		if err := s.EventsStream(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "events/stream", err))
		}
	default:
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, "Method not found", nil)
	}
}

// batchWriter is a helper type that implements http.ResponseWriter for writing multiple JSON-RPC responses
type batchWriter struct {
	io.Writer
	header     http.Header
	statusCode int
	written    bool
}

func (rb *batchWriter) Header() http.Header {
	if rb.header == nil {
		rb.header = make(http.Header)
	}
	return rb.header
}

func (rb *batchWriter) WriteHeader(statusCode int) {
	if rb.written {
		return
	}
	rb.statusCode = statusCode
}

func (rb *batchWriter) Write(data []byte) (int, error) {
	if !rb.written {
		rb.written = true
		rb.Writer.Write([]byte{'['})
	} else {
		rb.Writer.Write([]byte{','})
	}
	return rb.Writer.Write(data)
}

// handleSSE handles JSON-RPC SSE requests by dispatching to the appropriate method.
func (s *Server) handleSSE(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Read the JSON-RPC request
	var req jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&req); err != nil {
		// Emit JSON-RPC parse error as SSE event
		stream := &mcpAssistantSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, nil, jsonrpc.ParseError, "Parse error", nil)
		return
	}

	// Validate JSON-RPC request
	if req.JSONRPC != "2.0" {
		stream := &mcpAssistantSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.InvalidRequest, "Invalid request", nil)
		return
	}

	if req.Method == "" {
		stream := &mcpAssistantSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.InvalidRequest, "Invalid request", nil)
		return
	}

	// Find the appropriate handler based on method name
	var handler func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	switch req.Method {
	case "tools/call":
		handler = s.ToolsCall
	case "events/stream":
		handler = s.EventsStream
	default:
		stream := &mcpAssistantSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.MethodNotFound, "Method not found", nil)
		return
	}

	// Call the handler for the specific method
	if err := handler(ctx, r, &req, w); err != nil {
		s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", req.Method, err))
		return
	}

	// For notifications (requests without ID) that don't stream, return 204 No Content
	switch req.Method {
	}
} // Mount configures the mux to serve the JSON-RPC mcp_assistant service methods.
func Mount(mux goahttp.Muxer, h *Server) {
	// Mixed transports: mount unified handler that negotiates HTTP vs SSE by Accept header.
	//
	// MCP policy headers are propagated via request context so the service
	// implementation can enforce per-request allow/deny lists.
	mux.Handle("POST", "/rpc", withMCPPolicyHeaders(h.ServeHTTP))
}

// Mount configures the mux to serve the JSON-RPC mcp_assistant service methods.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// withMCPPolicyHeaders propagates MCP policy header values into the request context.
//
// The MCP adapter enforces resource allow/deny policies based on context values:
//   - "mcp_allow_names" (CSV list of resource names)
//   - "mcp_deny_names"  (CSV list of resource names)
//
// This helper maps those values from the corresponding HTTP headers:
//   - x-mcp-allow-names
//   - x-mcp-deny-names
//
// It is installed by the JSON-RPC Mount functions so consumers do not need
// to patch example servers or wire middleware manually.
func withMCPPolicyHeaders(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		if allow := r.Header.Get("x-mcp-allow-names"); allow != "" {
			ctx = context.WithValue(ctx, "mcp_allow_names", allow)
		}
		if deny := r.Header.Get("x-mcp-deny-names"); deny != "" {
			ctx = context.WithValue(ctx, "mcp_deny_names", deny)
		}
		next(w, r.WithContext(ctx))
	}
}

// NewInitializeHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "initialize" endpoint.
func NewInitializeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeInitializeRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "initialize")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewInitializeResponseBody(res.(*mcpassistant.InitializeResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewPingHandler creates a JSON-RPC handler which calls the "mcp_assistant"
// service "ping" endpoint.
func NewPingHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "ping")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		res, err := endpoint(ctx, nil)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewPingResponseBody(res.(*mcpassistant.PingResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewToolsListHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "tools/list" endpoint.
func NewToolsListHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeToolsListRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "tools/list")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewToolsListResponseBody(res.(*mcpassistant.ToolsListResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewToolsCallHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "tools/call" endpoint.
func NewToolsCallHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "tools/call")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		// Initialize SSE stream early so decode errors can be sent as SSE error events
		strm := &ToolsCallServerStream{
			w:         w,
			r:         r,
			encoder:   encoder,
			requestID: req.ID,
		}
		decodeParams := DecodeToolsCallRequest(mux, decoder)
		params, err := decodeParams(r, req)
		if err != nil {
			// Send error via SSE (JSON-RPC error event) to match SSE transport semantics
			if req.ID != nil && req.ID != "" {
				strm.SendError(ctx, jsonrpc.IDToString(req.ID), err)
			}
			return nil
		}
		v := &mcpassistant.ToolsCallEndpointInput{
			Stream:  strm,
			Payload: params,
		}
		if _, err := endpoint(ctx, v); err != nil {
			// Send error response via SSE with proper JSON-RPC code mapping
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if errors.As(err, &en) {
					switch en.GoaErrorName() {
					case "invalid_params":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.InvalidParams, err.Error(), nil)
					case "method_not_found":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.MethodNotFound, err.Error(), nil)
					}
				}
				// Fallback
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				return strm.sendError(ctx, jsonrpc.IDToString(req.ID), code, err.Error(), nil)
			}
			return nil
		}
		return nil
	}
}

// NewResourcesListHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "resources/list" endpoint.
func NewResourcesListHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeResourcesListRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "resources/list")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewResourcesListResponseBody(res.(*mcpassistant.ResourcesListResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewResourcesReadHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "resources/read" endpoint.
func NewResourcesReadHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeResourcesReadRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "resources/read")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewResourcesReadResponseBody(res.(*mcpassistant.ResourcesReadResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewResourcesSubscribeHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "resources/subscribe" endpoint.
func NewResourcesSubscribeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeResourcesSubscribeRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "resources/subscribe")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		_, err = endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification
		if req.ID == nil || req.ID == "" {
			// Notification - no response
			return nil
		}
		// Request with no result - send empty success response
		response := jsonrpc.MakeSuccessResponse(req.ID, nil)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewResourcesUnsubscribeHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "resources/unsubscribe" endpoint.
func NewResourcesUnsubscribeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeResourcesUnsubscribeRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "resources/unsubscribe")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		_, err = endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification
		if req.ID == nil || req.ID == "" {
			// Notification - no response
			return nil
		}
		// Request with no result - send empty success response
		response := jsonrpc.MakeSuccessResponse(req.ID, nil)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewPromptsListHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "prompts/list" endpoint.
func NewPromptsListHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodePromptsListRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "prompts/list")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewPromptsListResponseBody(res.(*mcpassistant.PromptsListResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewPromptsGetHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "prompts/get" endpoint.
func NewPromptsGetHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodePromptsGetRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "prompts/get")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewPromptsGetResponseBody(res.(*mcpassistant.PromptsGetResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewNotifyStatusUpdateHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "notify_status_update" endpoint.
func NewNotifyStatusUpdateHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeNotifyStatusUpdateRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "notify_status_update")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		_, err = endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				case "invalid_params":
					encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidParams, err.Error(), nil, encoder, errhandler)
				case "method_not_found":
					encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, err.Error(), nil, encoder, errhandler)
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification
		if req.ID == nil || req.ID == "" {
			// Notification - no response
			return nil
		}
		// Request with no result - send empty success response
		response := jsonrpc.MakeSuccessResponse(req.ID, nil)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewEventsStreamHandler creates a JSON-RPC handler which calls the
// "mcp_assistant" service "events/stream" endpoint.
func NewEventsStreamHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "events/stream")
		ctx = context.WithValue(ctx, goa.ServiceKey, "mcp_assistant")
		// Initialize SSE stream early so decode errors can be sent as SSE error events
		strm := &EventsStreamServerStream{
			w:         w,
			r:         r,
			encoder:   encoder,
			requestID: req.ID,
		}
		v := &mcpassistant.EventsStreamEndpointInput{
			Stream: strm,
		}
		if _, err := endpoint(ctx, v); err != nil {
			// Send error response via SSE with proper JSON-RPC code mapping
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if errors.As(err, &en) {
					switch en.GoaErrorName() {
					case "invalid_params":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.InvalidParams, err.Error(), nil)
					case "method_not_found":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.MethodNotFound, err.Error(), nil)
					}
				}
				// Fallback
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				return strm.sendError(ctx, jsonrpc.IDToString(req.ID), code, err.Error(), nil)
			}
			return nil
		}
		return nil
	}
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func (s *Server) encodeJSONRPCError(ctx context.Context, w http.ResponseWriter, req *jsonrpc.RawRequest, code jsonrpc.Code, message string, data any) {
	encodeJSONRPCError(ctx, w, req, code, message, data, s.encoder, s.errhandler)
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func encodeJSONRPCError(
	ctx context.Context,
	w http.ResponseWriter,
	req *jsonrpc.RawRequest,
	code jsonrpc.Code,
	message string,
	data any,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) {
	if req.ID != nil {
		response := jsonrpc.MakeErrorResponse(req.ID, code, message, data)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
	}
}
