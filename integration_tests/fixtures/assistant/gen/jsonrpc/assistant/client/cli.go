// Code generated by goa v3.22.6, DO NOT EDIT.
//
// assistant JSON-RPC client CLI support package
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"encoding/json"
	"fmt"

	assistant "example.com/assistant/gen/assistant"
	goa "goa.design/goa/v3/pkg"
)

// BuildConversationHistoryPayload builds the payload for the assistant
// conversation_history endpoint from CLI flags.
func BuildConversationHistoryPayload(assistantConversationHistoryBody string) (*assistant.ConversationHistoryPayload, error) {
	var err error
	var body ConversationHistoryRequestBody
	{
		err = json.Unmarshal([]byte(assistantConversationHistoryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"flag\": true,\n      \"limit\": 2315565867460245432,\n      \"nums\": [\n         \"Quia neque laudantium.\",\n         \"Quibusdam aliquid at sit fugiat ullam beatae.\",\n         \"Cum et.\"\n      ]\n   }'")
		}
	}
	v := &assistant.ConversationHistoryPayload{
		Limit: body.Limit,
		Flag:  body.Flag,
	}
	if body.Nums != nil {
		v.Nums = make([]any, len(body.Nums))
		for i, val := range body.Nums {
			v.Nums[i] = val
		}
	}

	return v, nil
}

// BuildGeneratePromptsPayload builds the payload for the assistant
// generate_prompts endpoint from CLI flags.
func BuildGeneratePromptsPayload(assistantGeneratePromptsBody string) (*assistant.GeneratePromptsPayload, error) {
	var err error
	var body GeneratePromptsRequestBody
	{
		err = json.Unmarshal([]byte(assistantGeneratePromptsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": \"Eaque provident odio natus repudiandae assumenda.\",\n      \"task\": \"Placeat ea aut reiciendis rerum.\"\n   }'")
		}
	}
	v := &assistant.GeneratePromptsPayload{
		Context: body.Context,
		Task:    body.Task,
	}

	return v, nil
}

// BuildSendNotificationPayload builds the payload for the assistant
// send_notification endpoint from CLI flags.
func BuildSendNotificationPayload(assistantSendNotificationBody string) (*assistant.SendNotificationPayload, error) {
	var err error
	var body SendNotificationRequestBody
	{
		err = json.Unmarshal([]byte(assistantSendNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"data\": \"Totam et reiciendis magnam beatae.\",\n      \"message\": \"Ea aut enim ea tempore corrupti.\",\n      \"type\": \"Est neque praesentium et voluptas.\"\n   }'")
		}
	}
	v := &assistant.SendNotificationPayload{
		Type:    body.Type,
		Message: body.Message,
		Data:    body.Data,
	}

	return v, nil
}

// BuildAnalyzeSentimentPayload builds the payload for the assistant
// analyze_sentiment endpoint from CLI flags.
func BuildAnalyzeSentimentPayload(assistantAnalyzeSentimentBody string) (*assistant.AnalyzeSentimentPayload, error) {
	var err error
	var body AnalyzeSentimentRequestBody
	{
		err = json.Unmarshal([]byte(assistantAnalyzeSentimentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"text\": \"Tempora quas rem inventore aut.\"\n   }'")
		}
	}
	v := &assistant.AnalyzeSentimentPayload{
		Text: body.Text,
	}

	return v, nil
}

// BuildExtractKeywordsPayload builds the payload for the assistant
// extract_keywords endpoint from CLI flags.
func BuildExtractKeywordsPayload(assistantExtractKeywordsBody string) (*assistant.ExtractKeywordsPayload, error) {
	var err error
	var body ExtractKeywordsRequestBody
	{
		err = json.Unmarshal([]byte(assistantExtractKeywordsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"text\": \"Dolore voluptas sapiente illum.\"\n   }'")
		}
	}
	v := &assistant.ExtractKeywordsPayload{
		Text: body.Text,
	}

	return v, nil
}

// BuildSummarizeTextPayload builds the payload for the assistant
// summarize_text endpoint from CLI flags.
func BuildSummarizeTextPayload(assistantSummarizeTextBody string) (*assistant.SummarizeTextPayload, error) {
	var err error
	var body SummarizeTextRequestBody
	{
		err = json.Unmarshal([]byte(assistantSummarizeTextBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"text\": \"Libero corrupti velit et.\"\n   }'")
		}
	}
	v := &assistant.SummarizeTextPayload{
		Text: body.Text,
	}

	return v, nil
}

// BuildSearchPayload builds the payload for the assistant search endpoint from
// CLI flags.
func BuildSearchPayload(assistantSearchBody string) (*assistant.SearchPayload, error) {
	var err error
	var body SearchRequestBody
	{
		err = json.Unmarshal([]byte(assistantSearchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 4931069413336628370,\n      \"query\": \"Aut molestiae ea.\"\n   }'")
		}
	}
	v := &assistant.SearchPayload{
		Query: body.Query,
		Limit: body.Limit,
	}

	return v, nil
}

// BuildExecuteCodePayload builds the payload for the assistant execute_code
// endpoint from CLI flags.
func BuildExecuteCodePayload(assistantExecuteCodeBody string) (*assistant.ExecuteCodePayload, error) {
	var err error
	var body ExecuteCodeRequestBody
	{
		err = json.Unmarshal([]byte(assistantExecuteCodeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"code\": \"Aliquid hic commodi nam.\",\n      \"language\": \"javascript\"\n   }'")
		}
		if !(body.Language == "python" || body.Language == "javascript") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.language", body.Language, []any{"python", "javascript"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ExecuteCodePayload{
		Language: body.Language,
		Code:     body.Code,
	}

	return v, nil
}

// BuildProcessBatchPayload builds the payload for the assistant process_batch
// endpoint from CLI flags.
func BuildProcessBatchPayload(assistantProcessBatchBody string) (*assistant.ProcessBatchPayload, error) {
	var err error
	var body ProcessBatchRequestBody
	{
		err = json.Unmarshal([]byte(assistantProcessBatchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"blob\": \"Iusto sapiente.\",\n      \"format\": \"uri\",\n      \"items\": [\n         \"Aperiam cum est harum velit et vel.\",\n         \"Doloribus et.\",\n         \"Rerum et magni.\"\n      ],\n      \"mimeType\": \"Placeat explicabo voluptatum.\",\n      \"uri\": \"Vel nobis.\"\n   }'")
		}
		if body.Items == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
		}
		if body.Format != nil {
			if !(*body.Format == "json" || *body.Format == "text" || *body.Format == "blob" || *body.Format == "uri") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"json", "text", "blob", "uri"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ProcessBatchPayload{
		Format:   body.Format,
		Blob:     body.Blob,
		URI:      body.URI,
		MimeType: body.MimeType,
	}
	if body.Items != nil {
		v.Items = make([]string, len(body.Items))
		for i, val := range body.Items {
			v.Items[i] = val
		}
	} else {
		v.Items = []string{}
	}

	return v, nil
}
