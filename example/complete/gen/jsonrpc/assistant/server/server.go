// Code generated by goa v3.21.5, DO NOT EDIT.
//
// assistant JSON-RPC server
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"

	assistant "example.com/assistant/gen/assistant"
	goahttp "goa.design/goa/v3/http"
	"goa.design/goa/v3/jsonrpc"
	goa "goa.design/goa/v3/pkg"
)

// Server handles JSON-RPC requests for the assistant service.
type Server struct {
	http.Handler
	// Methods is the list of methods served by this server.
	Methods []string

	// AnalyzeText is the handler for the analyze_text method.
	AnalyzeText func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// SearchKnowledge is the handler for the search_knowledge method.
	SearchKnowledge func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ExecuteCode is the handler for the execute_code method.
	ExecuteCode func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ListDocuments is the handler for the list_documents method.
	ListDocuments func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// GetSystemInfo is the handler for the get_system_info method.
	GetSystemInfo func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// GetConversationHistory is the handler for the get_conversation_history
	// method.
	GetConversationHistory func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// GeneratePrompts is the handler for the generate_prompts method.
	GeneratePrompts func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// RequestCompletion is the handler for the request_completion method.
	RequestCompletion func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// GetWorkspaceInfo is the handler for the get_workspace_info method.
	GetWorkspaceInfo func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// SendNotification is the handler for the send_notification method.
	SendNotification func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// SubscribeToUpdates is the handler for the subscribe_to_updates method.
	SubscribeToUpdates func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// ProcessBatch is the handler for the process_batch method.
	ProcessBatch func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// MonitorResourceChanges is the handler for the monitor_resource_changes
	// method.
	MonitorResourceChanges func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	// StreamLogs is the handler for the stream_logs method.
	StreamLogs func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error

	decoder    func(*http.Request) goahttp.Decoder
	encoder    func(context.Context, http.ResponseWriter) goahttp.Encoder
	errhandler func(context.Context, http.ResponseWriter, error)
}

// New creates a JSON-RPC server which loads HTTP requests and calls the
// "assistant" service methods.
func New(
	endpoints *assistant.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) *Server {
	s := &Server{
		Methods: []string{
			"analyze_text",
			"search_knowledge",
			"execute_code",
			"list_documents",
			"get_system_info",
			"get_conversation_history",
			"generate_prompts",
			"request_completion",
			"get_workspace_info",
			"send_notification",
			"subscribe_to_updates",
			"process_batch",
			"monitor_resource_changes",
			"stream_logs",
		},
		AnalyzeText:            NewAnalyzeTextHandler(endpoints.AnalyzeText, mux, decoder, encoder, errhandler),
		SearchKnowledge:        NewSearchKnowledgeHandler(endpoints.SearchKnowledge, mux, decoder, encoder, errhandler),
		ExecuteCode:            NewExecuteCodeHandler(endpoints.ExecuteCode, mux, decoder, encoder, errhandler),
		ListDocuments:          NewListDocumentsHandler(endpoints.ListDocuments, mux, decoder, encoder, errhandler),
		GetSystemInfo:          NewGetSystemInfoHandler(endpoints.GetSystemInfo, mux, decoder, encoder, errhandler),
		GetConversationHistory: NewGetConversationHistoryHandler(endpoints.GetConversationHistory, mux, decoder, encoder, errhandler),
		GeneratePrompts:        NewGeneratePromptsHandler(endpoints.GeneratePrompts, mux, decoder, encoder, errhandler),
		RequestCompletion:      NewRequestCompletionHandler(endpoints.RequestCompletion, mux, decoder, encoder, errhandler),
		GetWorkspaceInfo:       NewGetWorkspaceInfoHandler(endpoints.GetWorkspaceInfo, mux, decoder, encoder, errhandler),
		SendNotification:       NewSendNotificationHandler(endpoints.SendNotification, mux, decoder, encoder, errhandler),
		SubscribeToUpdates:     NewSubscribeToUpdatesHandler(endpoints.SubscribeToUpdates, mux, decoder, encoder, errhandler),
		ProcessBatch:           NewProcessBatchHandler(endpoints.ProcessBatch, mux, decoder, encoder, errhandler),
		MonitorResourceChanges: NewMonitorResourceChangesHandler(endpoints.MonitorResourceChanges, mux, decoder, encoder, errhandler),
		StreamLogs:             NewStreamLogsHandler(endpoints.StreamLogs, mux, decoder, encoder, errhandler),
		decoder:                decoder,
		encoder:                encoder,
		errhandler:             errhandler,
	}
	s.Handler = s
	return s
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "assistant" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.Handler = m(s.Handler)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return assistant.MethodNames[:] }

// ServeHTTP handles JSON-RPC requests.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Peek at the first byte to determine request type
	bufReader := bufio.NewReader(r.Body)
	peek, err := bufReader.Peek(1)
	if err != nil && err != io.EOF {
		r.Body.Close()
		s.errhandler(r.Context(), w, fmt.Errorf("failed to read request body: %w", err))
		return
	}

	// Wrap the buffered reader with the original closer
	r.Body = struct {
		io.Reader
		io.Closer
	}{
		Reader: bufReader,
		Closer: r.Body,
	}
	defer func(r *http.Request) {
		if err := r.Body.Close(); err != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to close request body: %w", err))
		}
	}(r)

	// Route to appropriate handler
	if len(peek) > 0 && peek[0] == '[' {
		s.handleBatch(w, r)
		return
	}
	s.handleSingle(w, r)
}

// handleSingle handles a single JSON-RPC request.
func (s *Server) handleSingle(w http.ResponseWriter, r *http.Request) {
	var req jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&req); err != nil {
		// Send JSON-RPC parse error response with error details
		response := jsonrpc.MakeErrorResponse(nil, jsonrpc.ParseError, "Parse error", err.Error())
		if encErr := s.encoder(r.Context(), w).Encode(response); encErr != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to encode parse error response: %w", encErr))
		}
		return
	}
	s.processRequest(r.Context(), r, &req, w)
}

// handleBatch handles a batch of JSON-RPC requests.
func (s *Server) handleBatch(w http.ResponseWriter, r *http.Request) {
	var reqs []jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&reqs); err != nil {
		// Send JSON-RPC parse error response for batch with error details
		response := jsonrpc.MakeErrorResponse(nil, jsonrpc.ParseError, "Parse error", err.Error())
		if encErr := s.encoder(r.Context(), w).Encode(response); encErr != nil {
			s.errhandler(r.Context(), w, fmt.Errorf("failed to encode parse error response: %w", encErr))
		}
		return
	}

	// Write responses
	w.Header().Set("Content-Type", "application/json")
	writer := &batchWriter{Writer: w}

	for _, req := range reqs {
		// Process the request with batch writer
		s.processRequest(r.Context(), r, &req, writer)
	}

	// Close the batch array
	if writer.written {
		writer.Writer.Write([]byte{']'})
	}
}

// ProcessRequest processes a single JSON-RPC request.
func (s *Server) processRequest(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) {
	if req.JSONRPC != "2.0" {
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidRequest, fmt.Sprintf("Invalid JSON-RPC version, must be 2.0, got %q", req.JSONRPC), nil)
		return
	}

	if req.Method == "" {
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.InvalidRequest, "Missing method field", nil)
		return
	}

	switch req.Method {
	case "analyze_text":
		if err := s.AnalyzeText(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "analyze_text", err))
		}
	case "search_knowledge":
		if err := s.SearchKnowledge(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "search_knowledge", err))
		}
	case "execute_code":
		if err := s.ExecuteCode(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "execute_code", err))
		}
	case "list_documents":
		if err := s.ListDocuments(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "list_documents", err))
		}
	case "get_system_info":
		if err := s.GetSystemInfo(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "get_system_info", err))
		}
	case "get_conversation_history":
		if err := s.GetConversationHistory(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "get_conversation_history", err))
		}
	case "generate_prompts":
		if err := s.GeneratePrompts(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "generate_prompts", err))
		}
	case "request_completion":
		if err := s.RequestCompletion(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "request_completion", err))
		}
	case "get_workspace_info":
		if err := s.GetWorkspaceInfo(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "get_workspace_info", err))
		}
	case "send_notification":
		if err := s.SendNotification(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "send_notification", err))
		}
	case "subscribe_to_updates":
		if err := s.SubscribeToUpdates(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "subscribe_to_updates", err))
		}
	case "process_batch":
		if err := s.ProcessBatch(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "process_batch", err))
		}
	case "monitor_resource_changes":
		if err := s.MonitorResourceChanges(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "monitor_resource_changes", err))
		}
	case "stream_logs":
		if err := s.StreamLogs(ctx, r, req, w); err != nil {
			s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", "stream_logs", err))
		}
	default:
		s.encodeJSONRPCError(ctx, w, req, jsonrpc.MethodNotFound, fmt.Sprintf("Method %q not found", req.Method), nil)
	}
}

// batchWriter is a helper type that implements http.ResponseWriter for writing multiple JSON-RPC responses
type batchWriter struct {
	io.Writer
	header     http.Header
	statusCode int
	written    bool
}

func (rb *batchWriter) Header() http.Header {
	if rb.header == nil {
		rb.header = make(http.Header)
	}
	return rb.header
}

func (rb *batchWriter) WriteHeader(statusCode int) {
	if rb.written {
		return
	}
	rb.statusCode = statusCode
}

func (rb *batchWriter) Write(data []byte) (int, error) {
	if !rb.written {
		rb.written = true
		rb.Writer.Write([]byte{'['})
	} else {
		rb.Writer.Write([]byte{','})
	}
	return rb.Writer.Write(data)
}

// Mount configures the mux to serve the JSON-RPC assistant service methods.
func Mount(mux goahttp.Muxer, h *Server) {
	mux.Handle("POST", "/rpc", h.ServeHTTP)
}

// Mount configures the mux to serve the JSON-RPC assistant service methods.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// NewAnalyzeTextHandler creates a JSON-RPC handler which calls the "assistant"
// service "analyze_text" endpoint.
func NewAnalyzeTextHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeAnalyzeTextRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "analyze_text")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewAnalyzeTextResponseBody(res.(*assistant.AnalysisResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewSearchKnowledgeHandler creates a JSON-RPC handler which calls the
// "assistant" service "search_knowledge" endpoint.
func NewSearchKnowledgeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeSearchKnowledgeRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "search_knowledge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewSearchKnowledgeResponseBody(res.([]*assistant.SearchResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewExecuteCodeHandler creates a JSON-RPC handler which calls the "assistant"
// service "execute_code" endpoint.
func NewExecuteCodeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeExecuteCodeRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "execute_code")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewExecuteCodeResponseBody(res.(*assistant.ExecutionResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewListDocumentsHandler creates a JSON-RPC handler which calls the
// "assistant" service "list_documents" endpoint.
func NewListDocumentsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "list_documents")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		res, err := endpoint(ctx, nil)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewListDocumentsResponseBody(res.([]*assistant.Document))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewGetSystemInfoHandler creates a JSON-RPC handler which calls the
// "assistant" service "get_system_info" endpoint.
func NewGetSystemInfoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "get_system_info")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		res, err := endpoint(ctx, nil)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewGetSystemInfoResponseBody(res.(*assistant.SystemInfo))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewGetConversationHistoryHandler creates a JSON-RPC handler which calls the
// "assistant" service "get_conversation_history" endpoint.
func NewGetConversationHistoryHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeGetConversationHistoryRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "get_conversation_history")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewGetConversationHistoryResponseBody(res.([]*assistant.ChatMessage))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewGeneratePromptsHandler creates a JSON-RPC handler which calls the
// "assistant" service "generate_prompts" endpoint.
func NewGeneratePromptsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeGeneratePromptsRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "generate_prompts")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewGeneratePromptsResponseBody(res.([]*assistant.PromptTemplate))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewRequestCompletionHandler creates a JSON-RPC handler which calls the
// "assistant" service "request_completion" endpoint.
func NewRequestCompletionHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeRequestCompletionRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "request_completion")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewRequestCompletionResponseBody(res.(*assistant.RequestCompletionResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewGetWorkspaceInfoHandler creates a JSON-RPC handler which calls the
// "assistant" service "get_workspace_info" endpoint.
func NewGetWorkspaceInfoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "get_workspace_info")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		res, err := endpoint(ctx, nil)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewGetWorkspaceInfoResponseBody(res.(*assistant.GetWorkspaceInfoResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewSendNotificationHandler creates a JSON-RPC handler which calls the
// "assistant" service "send_notification" endpoint.
func NewSendNotificationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeSendNotificationRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "send_notification")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		_, err = endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification
		if req.ID == nil || req.ID == "" {
			// Notification - no response
			return nil
		}
		// Request with no result - send empty success response
		response := jsonrpc.MakeSuccessResponse(req.ID, nil)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewSubscribeToUpdatesHandler creates a JSON-RPC handler which calls the
// "assistant" service "subscribe_to_updates" endpoint.
func NewSubscribeToUpdatesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeSubscribeToUpdatesRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "subscribe_to_updates")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewSubscribeToUpdatesResponseBody(res.(*assistant.SubscriptionInfo))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewProcessBatchHandler creates a JSON-RPC handler which calls the
// "assistant" service "process_batch" endpoint.
func NewProcessBatchHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeProcessBatchRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "process_batch")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewProcessBatchResponseBody(res.(*assistant.BatchResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewMonitorResourceChangesHandler creates a JSON-RPC handler which calls the
// "assistant" service "monitor_resource_changes" endpoint.
func NewMonitorResourceChangesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeMonitorResourceChangesRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "monitor_resource_changes")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewMonitorResourceChangesResponseBody(res.(*assistant.MonitorResourceChangesResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// NewStreamLogsHandler creates a JSON-RPC handler which calls the "assistant"
// service "stream_logs" endpoint.
func NewStreamLogsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	decodeParams := DecodeStreamLogsRequest(mux, decoder)
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "stream_logs")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		params, err := decodeParams(r, req)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("failed to decode parameters: %w", err))
			}
			return nil
		}
		res, err := endpoint(ctx, params)
		if err != nil {
			// Only send error response if request has ID (not nil or empty string)
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if !errors.As(err, &en) {
					encodeJSONRPCError(ctx, w, req, jsonrpc.InternalError, err.Error(), nil, encoder, errhandler)
					return nil
				}
				switch en.GoaErrorName() {
				default:
					code := jsonrpc.InternalError
					if _, ok := err.(*goa.ServiceError); ok {
						code = jsonrpc.InvalidParams
					}
					encodeJSONRPCError(ctx, w, req, code, err.Error(), nil, encoder, errhandler)
				}
			} else {
				// No ID means notification - just log error
				errhandler(ctx, w, fmt.Errorf("endpoint error: %w", err))
			}
			return nil
		}

		// For methods with no result, check if this is a notification

		// For methods with results, determine the ID to use for the response
		var id any
		// No ID field in result - use request ID
		id = req.ID

		if id == nil || id == "" {
			// Notification - no response
			return nil
		}

		// Send response with the result
		// Convert result to response body with proper JSON tags
		body := NewStreamLogsResponseBody(res.(*assistant.StreamLogsResult))
		response := jsonrpc.MakeSuccessResponse(id, body)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
		return nil
	}
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func (s *Server) encodeJSONRPCError(ctx context.Context, w http.ResponseWriter, req *jsonrpc.RawRequest, code jsonrpc.Code, message string, data any) {
	encodeJSONRPCError(ctx, w, req, code, message, data, s.encoder, s.errhandler)
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func encodeJSONRPCError(
	ctx context.Context,
	w http.ResponseWriter,
	req *jsonrpc.RawRequest,
	code jsonrpc.Code,
	message string,
	data any,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) {
	if req.ID != nil {
		response := jsonrpc.MakeErrorResponse(req.ID, code, "", message)
		if data != nil {
			response.Error.Data = data
		}
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
	}
}
