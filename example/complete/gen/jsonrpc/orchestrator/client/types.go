// Code generated by goa v3.22.6, DO NOT EDIT.
//
// orchestrator HTTP client types
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"unicode/utf8"

	orchestrator "example.com/assistant/gen/orchestrator"
	goa "goa.design/goa/v3/pkg"
)

// RunRequestBody is the type of the "orchestrator" service "run" endpoint HTTP
// request body.
type RunRequestBody struct {
	// Agent identifier to invoke (optional when bound to a single agent)
	AgentID *string `form:"agent_id,omitempty" json:"agent_id,omitempty" xml:"agent_id,omitempty"`
	// Caller-provided run identifier
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Session identifier used for grouping runs
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty" xml:"session_id,omitempty"`
	// Turn identifier associated with the run
	TurnID *string `form:"turn_id,omitempty" json:"turn_id,omitempty" xml:"turn_id,omitempty"`
	// Complete conversation history supplied to the agent
	Messages []*AgentMessageRequestBody `form:"messages" json:"messages" xml:"messages"`
	// Caller-supplied labels forwarded to the runtime
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// Arbitrary metadata forwarded to the runtime
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// RunResponseBody is the type of the "orchestrator" service "run" endpoint
// HTTP response body.
type RunResponseBody struct {
	// Kind of chunk being delivered
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Assistant message fragment.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Tool call scheduling notification.
	ToolCall *AgentToolCallChunkResponseBody `form:"tool_call,omitempty" json:"tool_call,omitempty" xml:"tool_call,omitempty"`
	// Tool result payload notification.
	ToolResult *AgentToolResultChunkResponseBody `form:"tool_result,omitempty" json:"tool_result,omitempty" xml:"tool_result,omitempty"`
	// Run status update.
	Status *AgentRunStatusChunkResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// AgentMessageRequestBody is used to define fields on request body types.
type AgentMessageRequestBody struct {
	// Role that produced the message
	Role string `form:"role" json:"role" xml:"role"`
	// Message content
	Content string `form:"content" json:"content" xml:"content"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// AgentToolCallChunkResponseBody is used to define fields on response body
// types.
type AgentToolCallChunkResponseBody struct {
	// Tool call identifier
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Tool name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Payload submitted to the tool
	Payload any `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// AgentToolResultChunkResponseBody is used to define fields on response body
// types.
type AgentToolResultChunkResponseBody struct {
	// Tool call identifier
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Decoded tool result payload
	Result any `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
	// Tool error, when the call failed
	Error *AgentToolErrorResponseBody `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// AgentToolErrorResponseBody is used to define fields on response body types.
type AgentToolErrorResponseBody struct {
	// Human-readable error summary
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Nested cause describing the underlying failure
	Cause *AgentToolErrorResponseBody `form:"cause,omitempty" json:"cause,omitempty" xml:"cause,omitempty"`
}

// AgentRunStatusChunkResponseBody is used to define fields on response body
// types.
type AgentRunStatusChunkResponseBody struct {
	// Current run state
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// Optional status annotation
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// NewRunRequestBody builds the HTTP request body from the payload of the "run"
// endpoint of the "orchestrator" service.
func NewRunRequestBody(p *orchestrator.AgentRunPayload) *RunRequestBody {
	body := &RunRequestBody{
		AgentID:   p.AgentID,
		RunID:     p.RunID,
		SessionID: p.SessionID,
		TurnID:    p.TurnID,
	}
	if p.Messages != nil {
		body.Messages = make([]*AgentMessageRequestBody, len(p.Messages))
		for i, val := range p.Messages {
			if val == nil {
				body.Messages[i] = nil
				continue
			}
			body.Messages[i] = marshalOrchestratorAgentMessageToAgentMessageRequestBody(val)
		}
	} else {
		body.Messages = []*AgentMessageRequestBody{}
	}
	if p.Labels != nil {
		body.Labels = make(map[string]string, len(p.Labels))
		for key, val := range p.Labels {
			tk := key
			tv := val
			body.Labels[tk] = tv
		}
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]any, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewRunAgentRunChunkOK builds a "orchestrator" service "run" endpoint result
// from a HTTP "OK" response.
func NewRunAgentRunChunkOK(body *RunResponseBody) *orchestrator.AgentRunChunk {
	v := &orchestrator.AgentRunChunk{
		Type:    *body.Type,
		Message: body.Message,
	}
	if body.ToolCall != nil {
		v.ToolCall = unmarshalAgentToolCallChunkResponseBodyToOrchestratorAgentToolCallChunk(body.ToolCall)
	}
	if body.ToolResult != nil {
		v.ToolResult = unmarshalAgentToolResultChunkResponseBodyToOrchestratorAgentToolResultChunk(body.ToolResult)
	}
	if body.Status != nil {
		v.Status = unmarshalAgentRunStatusChunkResponseBodyToOrchestratorAgentRunStatusChunk(body.Status)
	}

	return v
}

// ValidateRunResponseBody runs the validations defined on RunResponseBody
func ValidateRunResponseBody(body *RunResponseBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "message" || *body.Type == "tool_call" || *body.Type == "tool_result" || *body.Type == "status") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"message", "tool_call", "tool_result", "status"}))
		}
	}
	if body.ToolCall != nil {
		if err2 := ValidateAgentToolCallChunkResponseBody(body.ToolCall); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.ToolResult != nil {
		if err2 := ValidateAgentToolResultChunkResponseBody(body.ToolResult); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Status != nil {
		if err2 := ValidateAgentRunStatusChunkResponseBody(body.Status); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateAgentMessageRequestBody runs the validations defined on
// AgentMessageRequestBody
func ValidateAgentMessageRequestBody(body *AgentMessageRequestBody) (err error) {
	if !(body.Role == "user" || body.Role == "assistant" || body.Role == "tool" || body.Role == "system") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", body.Role, []any{"user", "assistant", "tool", "system"}))
	}
	if utf8.RuneCountInString(body.Content) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", body.Content, utf8.RuneCountInString(body.Content), 1, true))
	}
	return
}

// ValidateAgentToolCallChunkResponseBody runs the validations defined on
// AgentToolCallChunkResponseBody
func ValidateAgentToolCallChunkResponseBody(body *AgentToolCallChunkResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
		}
	}
	return
}

// ValidateAgentToolResultChunkResponseBody runs the validations defined on
// AgentToolResultChunkResponseBody
func ValidateAgentToolResultChunkResponseBody(body *AgentToolResultChunkResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 1, true))
		}
	}
	return
}

// ValidateAgentRunStatusChunkResponseBody runs the validations defined on
// AgentRunStatusChunkResponseBody
func ValidateAgentRunStatusChunkResponseBody(body *AgentRunStatusChunkResponseBody) (err error) {
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	if body.State != nil {
		if !(*body.State == "started" || *body.State == "paused" || *body.State == "resumed" || *body.State == "completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.state", *body.State, []any{"started", "paused", "resumed", "completed"}))
		}
	}
	return
}
