// Code generated by goa v3.22.2, DO NOT EDIT.
//
// assistant HTTP server
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"context"
	"net/http"
	"strings"

	assistant "example.com/assistant/gen/assistant"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// Server lists the assistant service endpoint HTTP handlers.
type Server struct {
	Mounts                 []*MountPoint
	AnalyzeText            http.Handler
	SearchKnowledge        http.Handler
	ExecuteCode            http.Handler
	ListDocuments          http.Handler
	GetSystemInfo          http.Handler
	GetConversationHistory http.Handler
	GeneratePrompts        http.Handler
	GetWorkspaceInfo       http.Handler
	SendNotification       http.Handler
	SubscribeToUpdates     http.Handler
	ProcessBatch           http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the assistant service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *assistant.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) *Server {
	return &Server{
		Mounts: []*MountPoint{
			{"AnalyzeText", "POST", "/api/analyze"},
			{"SearchKnowledge", "POST", "/api/search"},
			{"ExecuteCode", "POST", "/api/execute"},
			{"ListDocuments", "GET", "/api/documents"},
			{"GetSystemInfo", "GET", "/api/system"},
			{"GetConversationHistory", "GET", "/api/conversation"},
			{"GeneratePrompts", "POST", "/api/prompts/generate"},
			{"GetWorkspaceInfo", "GET", "/api/workspace"},
			{"SendNotification", "POST", "/api/notify"},
			{"SubscribeToUpdates", "POST", "/api/subscribe"},
			{"ProcessBatch", "POST", "/api/batch"},
		},
		AnalyzeText:            NewAnalyzeTextHandler(e.AnalyzeText, mux, decoder, encoder, errhandler, formatter),
		SearchKnowledge:        NewSearchKnowledgeHandler(e.SearchKnowledge, mux, decoder, encoder, errhandler, formatter),
		ExecuteCode:            NewExecuteCodeHandler(e.ExecuteCode, mux, decoder, encoder, errhandler, formatter),
		ListDocuments:          NewListDocumentsHandler(e.ListDocuments, mux, decoder, encoder, errhandler, formatter),
		GetSystemInfo:          NewGetSystemInfoHandler(e.GetSystemInfo, mux, decoder, encoder, errhandler, formatter),
		GetConversationHistory: NewGetConversationHistoryHandler(e.GetConversationHistory, mux, decoder, encoder, errhandler, formatter),
		GeneratePrompts:        NewGeneratePromptsHandler(e.GeneratePrompts, mux, decoder, encoder, errhandler, formatter),
		GetWorkspaceInfo:       NewGetWorkspaceInfoHandler(e.GetWorkspaceInfo, mux, decoder, encoder, errhandler, formatter),
		SendNotification:       NewSendNotificationHandler(e.SendNotification, mux, decoder, encoder, errhandler, formatter),
		SubscribeToUpdates:     NewSubscribeToUpdatesHandler(e.SubscribeToUpdates, mux, decoder, encoder, errhandler, formatter),
		ProcessBatch:           NewProcessBatchHandler(e.ProcessBatch, mux, decoder, encoder, errhandler, formatter),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "assistant" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.AnalyzeText = m(s.AnalyzeText)
	s.SearchKnowledge = m(s.SearchKnowledge)
	s.ExecuteCode = m(s.ExecuteCode)
	s.ListDocuments = m(s.ListDocuments)
	s.GetSystemInfo = m(s.GetSystemInfo)
	s.GetConversationHistory = m(s.GetConversationHistory)
	s.GeneratePrompts = m(s.GeneratePrompts)
	s.GetWorkspaceInfo = m(s.GetWorkspaceInfo)
	s.SendNotification = m(s.SendNotification)
	s.SubscribeToUpdates = m(s.SubscribeToUpdates)
	s.ProcessBatch = m(s.ProcessBatch)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return assistant.MethodNames[:] }

// Mount configures the mux to serve the assistant endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAnalyzeTextHandler(mux, h.AnalyzeText)
	MountSearchKnowledgeHandler(mux, h.SearchKnowledge)
	MountExecuteCodeHandler(mux, h.ExecuteCode)
	MountListDocumentsHandler(mux, h.ListDocuments)
	MountGetSystemInfoHandler(mux, h.GetSystemInfo)
	MountGetConversationHistoryHandler(mux, h.GetConversationHistory)
	MountGeneratePromptsHandler(mux, h.GeneratePrompts)
	MountGetWorkspaceInfoHandler(mux, h.GetWorkspaceInfo)
	MountSendNotificationHandler(mux, h.SendNotification)
	MountSubscribeToUpdatesHandler(mux, h.SubscribeToUpdates)
	MountProcessBatchHandler(mux, h.ProcessBatch)
}

// Mount configures the mux to serve the assistant endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountAnalyzeTextHandler configures the mux to serve the "assistant" service
// "analyze_text" endpoint.
func MountAnalyzeTextHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/analyze", f)
}

// NewAnalyzeTextHandler creates a HTTP handler which loads the HTTP request
// and calls the "assistant" service "analyze_text" endpoint.
func NewAnalyzeTextHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAnalyzeTextRequest(mux, decoder)
		encodeResponse = EncodeAnalyzeTextResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "analyze_text")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountSearchKnowledgeHandler configures the mux to serve the "assistant"
// service "search_knowledge" endpoint.
func MountSearchKnowledgeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/search", f)
}

// NewSearchKnowledgeHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "search_knowledge" endpoint.
func NewSearchKnowledgeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSearchKnowledgeRequest(mux, decoder)
		encodeResponse = EncodeSearchKnowledgeResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "search_knowledge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountExecuteCodeHandler configures the mux to serve the "assistant" service
// "execute_code" endpoint.
func MountExecuteCodeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/execute", f)
}

// NewExecuteCodeHandler creates a HTTP handler which loads the HTTP request
// and calls the "assistant" service "execute_code" endpoint.
func NewExecuteCodeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeExecuteCodeRequest(mux, decoder)
		encodeResponse = EncodeExecuteCodeResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "execute_code")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountListDocumentsHandler configures the mux to serve the "assistant"
// service "list_documents" endpoint.
func MountListDocumentsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/documents", f)
}

// NewListDocumentsHandler creates a HTTP handler which loads the HTTP request
// and calls the "assistant" service "list_documents" endpoint.
func NewListDocumentsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeListDocumentsResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list_documents")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountGetSystemInfoHandler configures the mux to serve the "assistant"
// service "get_system_info" endpoint.
func MountGetSystemInfoHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/system", f)
}

// NewGetSystemInfoHandler creates a HTTP handler which loads the HTTP request
// and calls the "assistant" service "get_system_info" endpoint.
func NewGetSystemInfoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeGetSystemInfoResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "get_system_info")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountGetConversationHistoryHandler configures the mux to serve the
// "assistant" service "get_conversation_history" endpoint.
func MountGetConversationHistoryHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/conversation", f)
}

// NewGetConversationHistoryHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "get_conversation_history"
// endpoint.
func NewGetConversationHistoryHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetConversationHistoryRequest(mux, decoder)
		encodeResponse = EncodeGetConversationHistoryResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "get_conversation_history")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountGeneratePromptsHandler configures the mux to serve the "assistant"
// service "generate_prompts" endpoint.
func MountGeneratePromptsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/prompts/generate", f)
}

// NewGeneratePromptsHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "generate_prompts" endpoint.
func NewGeneratePromptsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGeneratePromptsRequest(mux, decoder)
		encodeResponse = EncodeGeneratePromptsResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "generate_prompts")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountGetWorkspaceInfoHandler configures the mux to serve the "assistant"
// service "get_workspace_info" endpoint.
func MountGetWorkspaceInfoHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/api/workspace", f)
}

// NewGetWorkspaceInfoHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "get_workspace_info" endpoint.
func NewGetWorkspaceInfoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeGetWorkspaceInfoResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "get_workspace_info")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountSendNotificationHandler configures the mux to serve the "assistant"
// service "send_notification" endpoint.
func MountSendNotificationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/notify", f)
}

// NewSendNotificationHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "send_notification" endpoint.
func NewSendNotificationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSendNotificationRequest(mux, decoder)
		encodeResponse = EncodeSendNotificationResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "send_notification")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountSubscribeToUpdatesHandler configures the mux to serve the "assistant"
// service "subscribe_to_updates" endpoint.
func MountSubscribeToUpdatesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/subscribe", f)
}

// NewSubscribeToUpdatesHandler creates a HTTP handler which loads the HTTP
// request and calls the "assistant" service "subscribe_to_updates" endpoint.
func NewSubscribeToUpdatesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSubscribeToUpdatesRequest(mux, decoder)
		encodeResponse = EncodeSubscribeToUpdatesResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "subscribe_to_updates")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			if errhandler != nil {
				errhandler(ctx, w, err)
			}
		}
	})
}

// MountProcessBatchHandler configures the mux to serve the "assistant" service
// "process_batch" endpoint.
func MountProcessBatchHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/api/batch", f)
}

// NewProcessBatchHandler creates a HTTP handler which loads the HTTP request
// and calls the "assistant" service "process_batch" endpoint.
func NewProcessBatchHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeProcessBatchRequest(mux, decoder)
		encodeResponse = EncodeProcessBatchResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "process_batch")
		ctx = context.WithValue(ctx, goa.ServiceKey, "assistant")

		// Content negotiation for mixed results (standard HTTP vs SSE)
		acceptHeader := r.Header.Get("Accept")
		if strings.Contains(acceptHeader, "text/event-stream") {
			// Handle SSE request
			payload, err := decodeRequest(r)
			if err != nil {
				if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			v := &assistant.ProcessBatchEndpointInput{
				Stream: &ProcessBatchServerStream{
					w: w,
					r: r,
				},
				Payload: payload,
			}
			_, err = endpoint(ctx, v)
			if err != nil {
				if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
					errhandler(ctx, w, err)
				}
			}
		} else {
			// Handle standard HTTP request
			payload, err := decodeRequest(r)
			if err != nil {
				if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			res, err := endpoint(ctx, payload)
			if err != nil {
				if err := encodeError(ctx, w, err); err != nil && errhandler != nil {
					errhandler(ctx, w, err)
				}
				return
			}
			if err := encodeResponse(ctx, w, res); err != nil {
				if errhandler != nil {
					errhandler(ctx, w, err)
				}
			}
		}
	})
}
