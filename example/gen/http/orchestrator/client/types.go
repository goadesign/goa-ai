// Code generated by goa v3.22.6, DO NOT EDIT.
//
// orchestrator HTTP client types
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"unicode/utf8"

	orchestrator "example.com/assistant/gen/orchestrator"
	goa "goa.design/goa/v3/pkg"
)

// RunRequestBody is the type of the "orchestrator" service "run" endpoint HTTP
// request body.
type RunRequestBody struct {
	// Agent identifier to invoke (optional when bound to a single agent)
	AgentID *string `form:"agent_id,omitempty" json:"agent_id,omitempty" xml:"agent_id,omitempty"`
	// Caller-provided run identifier
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Session identifier used for grouping runs
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty" xml:"session_id,omitempty"`
	// Turn identifier associated with the run
	TurnID *string `form:"turn_id,omitempty" json:"turn_id,omitempty" xml:"turn_id,omitempty"`
	// Complete conversation history supplied to the agent
	Messages []*AgentMessageRequestBody `form:"messages" json:"messages" xml:"messages"`
	// Caller-supplied labels forwarded to the runtime
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// Arbitrary metadata forwarded to the runtime
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// RunResponseBody is the type of the "orchestrator" service "run" endpoint
// HTTP response body.
type RunResponseBody struct {
	// Identifier of the agent that produced the result
	AgentID *string `form:"agent_id,omitempty" json:"agent_id,omitempty" xml:"agent_id,omitempty"`
	// Identifier of the completed run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Final assistant response returned to the caller
	Final *AgentMessageResponseBody `form:"final,omitempty" json:"final,omitempty" xml:"final,omitempty"`
	// Tool events emitted during the final turn
	ToolEvents []*AgentToolEventResponseBody `form:"tool_events,omitempty" json:"tool_events,omitempty" xml:"tool_events,omitempty"`
	// Planner annotations captured during completion
	Notes []*AgentPlannerAnnotationResponseBody `form:"notes,omitempty" json:"notes,omitempty" xml:"notes,omitempty"`
}

// AgentMessageRequestBody is used to define fields on request body types.
type AgentMessageRequestBody struct {
	// Role that produced the message
	Role string `form:"role" json:"role" xml:"role"`
	// Message content
	Content string `form:"content" json:"content" xml:"content"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// AgentMessageResponseBody is used to define fields on response body types.
type AgentMessageResponseBody struct {
	// Role that produced the message
	Role *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// Message content
	Content *string `form:"content,omitempty" json:"content,omitempty" xml:"content,omitempty"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// AgentToolEventResponseBody is used to define fields on response body types.
type AgentToolEventResponseBody struct {
	// Tool identifier
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Tool result payload when the call succeeds
	Payload any `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
	// Structured error returned by the tool
	Error *AgentToolErrorResponseBody `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Retry guidance emitted by the tool on failure
	RetryHint *AgentRetryHintResponseBody `form:"retry_hint,omitempty" json:"retry_hint,omitempty" xml:"retry_hint,omitempty"`
	// Telemetry metadata captured during execution
	Telemetry *AgentToolTelemetryResponseBody `form:"telemetry,omitempty" json:"telemetry,omitempty" xml:"telemetry,omitempty"`
}

// AgentToolErrorResponseBody is used to define fields on response body types.
type AgentToolErrorResponseBody struct {
	// Human-readable error summary
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Nested cause describing the underlying failure
	Cause *AgentToolErrorResponseBody `form:"cause,omitempty" json:"cause,omitempty" xml:"cause,omitempty"`
}

// AgentRetryHintResponseBody is used to define fields on response body types.
type AgentRetryHintResponseBody struct {
	// Categorized reason for the retry guidance
	Reason *string `form:"reason,omitempty" json:"reason,omitempty" xml:"reason,omitempty"`
	// Qualified tool name associated with the hint
	Tool *string `form:"tool,omitempty" json:"tool,omitempty" xml:"tool,omitempty"`
	// Restrict subsequent planner turns to this tool
	RestrictToTool *bool `form:"restrict_to_tool,omitempty" json:"restrict_to_tool,omitempty" xml:"restrict_to_tool,omitempty"`
	// Missing or invalid fields that caused the failure
	MissingFields []string `form:"missing_fields,omitempty" json:"missing_fields,omitempty" xml:"missing_fields,omitempty"`
	// Representative payload that satisfies validation
	ExampleInput map[string]any `form:"example_input,omitempty" json:"example_input,omitempty" xml:"example_input,omitempty"`
	// Payload that triggered the failure
	PriorInput map[string]any `form:"prior_input,omitempty" json:"prior_input,omitempty" xml:"prior_input,omitempty"`
	// Question that callers should answer to proceed
	ClarifyingQuestion *string `form:"clarifying_question,omitempty" json:"clarifying_question,omitempty" xml:"clarifying_question,omitempty"`
	// Human-readable guidance for logs or UI
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// AgentToolTelemetryResponseBody is used to define fields on response body
// types.
type AgentToolTelemetryResponseBody struct {
	// Wall-clock duration in milliseconds
	DurationMs *int64 `form:"duration_ms,omitempty" json:"duration_ms,omitempty" xml:"duration_ms,omitempty"`
	// Total tokens consumed by the tool call
	TokensUsed *int `form:"tokens_used,omitempty" json:"tokens_used,omitempty" xml:"tokens_used,omitempty"`
	// Identifier of the model used by the tool
	Model *string `form:"model,omitempty" json:"model,omitempty" xml:"model,omitempty"`
	// Tool-specific telemetry key/value pairs
	Extra map[string]any `form:"extra,omitempty" json:"extra,omitempty" xml:"extra,omitempty"`
}

// AgentPlannerAnnotationResponseBody is used to define fields on response body
// types.
type AgentPlannerAnnotationResponseBody struct {
	// Annotation emitted by the planner
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
	// Structured metadata associated with the note
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
}

// NewRunRequestBody builds the HTTP request body from the payload of the "run"
// endpoint of the "orchestrator" service.
func NewRunRequestBody(p *orchestrator.AgentRunPayload) *RunRequestBody {
	body := &RunRequestBody{
		AgentID:   p.AgentID,
		RunID:     p.RunID,
		SessionID: p.SessionID,
		TurnID:    p.TurnID,
	}
	if p.Messages != nil {
		body.Messages = make([]*AgentMessageRequestBody, len(p.Messages))
		for i, val := range p.Messages {
			if val == nil {
				body.Messages[i] = nil
				continue
			}
			body.Messages[i] = marshalOrchestratorAgentMessageToAgentMessageRequestBody(val)
		}
	} else {
		body.Messages = []*AgentMessageRequestBody{}
	}
	if p.Labels != nil {
		body.Labels = make(map[string]string, len(p.Labels))
		for key, val := range p.Labels {
			tk := key
			tv := val
			body.Labels[tk] = tv
		}
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]any, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewRunAgentRunResultOK builds a "orchestrator" service "run" endpoint result
// from a HTTP "OK" response.
func NewRunAgentRunResultOK(body *RunResponseBody) *orchestrator.AgentRunResult {
	v := &orchestrator.AgentRunResult{
		AgentID: *body.AgentID,
		RunID:   *body.RunID,
	}
	v.Final = unmarshalAgentMessageResponseBodyToOrchestratorAgentMessage(body.Final)
	if body.ToolEvents != nil {
		v.ToolEvents = make([]*orchestrator.AgentToolEvent, len(body.ToolEvents))
		for i, val := range body.ToolEvents {
			if val == nil {
				v.ToolEvents[i] = nil
				continue
			}
			v.ToolEvents[i] = unmarshalAgentToolEventResponseBodyToOrchestratorAgentToolEvent(val)
		}
	}
	if body.Notes != nil {
		v.Notes = make([]*orchestrator.AgentPlannerAnnotation, len(body.Notes))
		for i, val := range body.Notes {
			if val == nil {
				v.Notes[i] = nil
				continue
			}
			v.Notes[i] = unmarshalAgentPlannerAnnotationResponseBodyToOrchestratorAgentPlannerAnnotation(val)
		}
	}

	return v
}

// ValidateRunResponseBody runs the validations defined on RunResponseBody
func ValidateRunResponseBody(body *RunResponseBody) (err error) {
	if body.AgentID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("agent_id", "body"))
	}
	if body.RunID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("run_id", "body"))
	}
	if body.Final == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("final", "body"))
	}
	if body.AgentID != nil {
		if utf8.RuneCountInString(*body.AgentID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.agent_id", *body.AgentID, utf8.RuneCountInString(*body.AgentID), 1, true))
		}
	}
	if body.RunID != nil {
		if utf8.RuneCountInString(*body.RunID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.run_id", *body.RunID, utf8.RuneCountInString(*body.RunID), 1, true))
		}
	}
	if body.Final != nil {
		if err2 := ValidateAgentMessageResponseBody(body.Final); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.ToolEvents {
		if e != nil {
			if err2 := ValidateAgentToolEventResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Notes {
		if e != nil {
			if err2 := ValidateAgentPlannerAnnotationResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateAgentMessageRequestBody runs the validations defined on
// AgentMessageRequestBody
func ValidateAgentMessageRequestBody(body *AgentMessageRequestBody) (err error) {
	if !(body.Role == "user" || body.Role == "assistant" || body.Role == "tool" || body.Role == "system") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", body.Role, []any{"user", "assistant", "tool", "system"}))
	}
	if utf8.RuneCountInString(body.Content) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", body.Content, utf8.RuneCountInString(body.Content), 1, true))
	}
	return
}

// ValidateAgentMessageResponseBody runs the validations defined on
// AgentMessageResponseBody
func ValidateAgentMessageResponseBody(body *AgentMessageResponseBody) (err error) {
	if body.Role == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("role", "body"))
	}
	if body.Content == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("content", "body"))
	}
	if body.Role != nil {
		if !(*body.Role == "user" || *body.Role == "assistant" || *body.Role == "tool" || *body.Role == "system") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"user", "assistant", "tool", "system"}))
		}
	}
	if body.Content != nil {
		if utf8.RuneCountInString(*body.Content) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", *body.Content, utf8.RuneCountInString(*body.Content), 1, true))
		}
	}
	return
}

// ValidateAgentToolEventResponseBody runs the validations defined on
// AgentToolEventResponseBody
func ValidateAgentToolEventResponseBody(body *AgentToolEventResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 1, true))
		}
	}
	if body.RetryHint != nil {
		if err2 := ValidateAgentRetryHintResponseBody(body.RetryHint); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Telemetry != nil {
		if err2 := ValidateAgentToolTelemetryResponseBody(body.Telemetry); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateAgentRetryHintResponseBody runs the validations defined on
// AgentRetryHintResponseBody
func ValidateAgentRetryHintResponseBody(body *AgentRetryHintResponseBody) (err error) {
	if body.Reason == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("reason", "body"))
	}
	if body.Tool == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("tool", "body"))
	}
	if body.Reason != nil {
		if !(*body.Reason == "invalid_arguments" || *body.Reason == "missing_fields" || *body.Reason == "malformed_response" || *body.Reason == "timeout" || *body.Reason == "rate_limited" || *body.Reason == "tool_unavailable") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.reason", *body.Reason, []any{"invalid_arguments", "missing_fields", "malformed_response", "timeout", "rate_limited", "tool_unavailable"}))
		}
	}
	if body.Tool != nil {
		if utf8.RuneCountInString(*body.Tool) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tool", *body.Tool, utf8.RuneCountInString(*body.Tool), 1, true))
		}
	}
	return
}

// ValidateAgentToolTelemetryResponseBody runs the validations defined on
// AgentToolTelemetryResponseBody
func ValidateAgentToolTelemetryResponseBody(body *AgentToolTelemetryResponseBody) (err error) {
	if body.DurationMs != nil {
		if *body.DurationMs < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration_ms", *body.DurationMs, 0, true))
		}
	}
	if body.TokensUsed != nil {
		if *body.TokensUsed < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.tokens_used", *body.TokensUsed, 0, true))
		}
	}
	return
}

// ValidateAgentPlannerAnnotationResponseBody runs the validations defined on
// AgentPlannerAnnotationResponseBody
func ValidateAgentPlannerAnnotationResponseBody(body *AgentPlannerAnnotationResponseBody) (err error) {
	if body.Text != nil {
		if utf8.RuneCountInString(*body.Text) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.text", *body.Text, utf8.RuneCountInString(*body.Text), 1, true))
		}
	}
	return
}
