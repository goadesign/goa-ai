// Code generated by goa v3.22.2, DO NOT EDIT.
//
// websocket HTTP server types
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	websocketsvc "example.com/assistant/gen/websocket"
	goa "goa.design/goa/v3/pkg"
)

// UploadChunksStreamingBody is the type of the "websocket" service
// "upload_chunks" endpoint HTTP request body.
type UploadChunksStreamingBody DocumentChunkStreamingBody

// UploadDocumentsStreamingBody is the type of the "websocket" service
// "upload_documents" endpoint HTTP request body.
type UploadDocumentsStreamingBody DocumentChunkStreamingBody

// ChatStreamingBody is the type of the "websocket" service "chat" endpoint
// HTTP request body.
type ChatStreamingBody ChatInputStreamingBody

// InteractiveChatStreamingBody is the type of the "websocket" service
// "interactive_chat" endpoint HTTP request body.
type InteractiveChatStreamingBody ChatInputStreamingBody

// UploadChunksResponseBody is the type of the "websocket" service
// "upload_chunks" endpoint HTTP response body.
type UploadChunksResponseBody struct {
	// Total size
	TotalSize int `form:"total_size" json:"total_size" xml:"total_size"`
	// Number of chunks
	ChunkCount int `form:"chunk_count" json:"chunk_count" xml:"chunk_count"`
}

// UploadDocumentsResponseBody is the type of the "websocket" service
// "upload_documents" endpoint HTTP response body.
type UploadDocumentsResponseBody struct {
	// Total size
	TotalSize int `form:"total_size" json:"total_size" xml:"total_size"`
	// Number of documents
	DocumentCount int `form:"document_count" json:"document_count" xml:"document_count"`
}

// ChatResponseBody is the type of the "websocket" service "chat" endpoint HTTP
// response body.
type ChatResponseBody struct {
	// Assistant response
	Response string `form:"response" json:"response" xml:"response"`
	// Whether assistant is still thinking
	Thinking bool `form:"thinking" json:"thinking" xml:"thinking"`
	// Response metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// InteractiveChatResponseBody is the type of the "websocket" service
// "interactive_chat" endpoint HTTP response body.
type InteractiveChatResponseBody struct {
	// Assistant response
	Response string `form:"response" json:"response" xml:"response"`
	// Whether assistant is still thinking
	Thinking bool `form:"thinking" json:"thinking" xml:"thinking"`
	// Response metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// DocumentChunkStreamingBody is used to define fields on request body types.
type DocumentChunkStreamingBody struct {
	// Document ID
	DocumentID *string `form:"document_id,omitempty" json:"document_id,omitempty" xml:"document_id,omitempty"`
	// Chunk index
	ChunkIndex *int `form:"chunk_index,omitempty" json:"chunk_index,omitempty" xml:"chunk_index,omitempty"`
	// Total number of chunks
	TotalChunks *int `form:"total_chunks,omitempty" json:"total_chunks,omitempty" xml:"total_chunks,omitempty"`
	// Chunk data
	Data []byte `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// Document metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// ChatInputStreamingBody is used to define fields on request body types.
type ChatInputStreamingBody struct {
	// User message
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Additional context
	Context map[string]any `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Stream control command
	StreamControl *string `form:"stream_control,omitempty" json:"stream_control,omitempty" xml:"stream_control,omitempty"`
}

// NewUploadChunksResponseBody builds the HTTP response body from the result of
// the "upload_chunks" endpoint of the "websocket" service.
func NewUploadChunksResponseBody(res *websocketsvc.UploadChunksResult) *UploadChunksResponseBody {
	body := &UploadChunksResponseBody{
		TotalSize:  res.TotalSize,
		ChunkCount: res.ChunkCount,
	}
	return body
}

// NewUploadDocumentsResponseBody builds the HTTP response body from the result
// of the "upload_documents" endpoint of the "websocket" service.
func NewUploadDocumentsResponseBody(res *websocketsvc.UploadDocumentsResult) *UploadDocumentsResponseBody {
	body := &UploadDocumentsResponseBody{
		TotalSize:     res.TotalSize,
		DocumentCount: res.DocumentCount,
	}
	return body
}

// NewChatResponseBody builds the HTTP response body from the result of the
// "chat" endpoint of the "websocket" service.
func NewChatResponseBody(res *websocketsvc.ChatResponse) *ChatResponseBody {
	body := &ChatResponseBody{
		Response: res.Response,
		Thinking: res.Thinking,
	}
	if res.Metadata != nil {
		body.Metadata = make(map[string]any, len(res.Metadata))
		for key, val := range res.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewInteractiveChatResponseBody builds the HTTP response body from the result
// of the "interactive_chat" endpoint of the "websocket" service.
func NewInteractiveChatResponseBody(res *websocketsvc.ChatResponse) *InteractiveChatResponseBody {
	body := &InteractiveChatResponseBody{
		Response: res.Response,
		Thinking: res.Thinking,
	}
	if res.Metadata != nil {
		body.Metadata = make(map[string]any, len(res.Metadata))
		for key, val := range res.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewUploadChunksStreamingBody builds a websocket service upload_chunks
// endpoint payload.
func NewUploadChunksStreamingBody(body *UploadChunksStreamingBody) *websocketsvc.DocumentChunk {
	v := &websocketsvc.DocumentChunk{
		DocumentID:  *body.DocumentID,
		ChunkIndex:  *body.ChunkIndex,
		TotalChunks: body.TotalChunks,
		Data:        body.Data,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// NewUploadDocumentsStreamingBody builds a websocket service upload_documents
// endpoint payload.
func NewUploadDocumentsStreamingBody(body *UploadDocumentsStreamingBody) *websocketsvc.DocumentChunk {
	v := &websocketsvc.DocumentChunk{
		DocumentID:  *body.DocumentID,
		ChunkIndex:  *body.ChunkIndex,
		TotalChunks: body.TotalChunks,
		Data:        body.Data,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// NewChatStreamingBody builds a websocket service chat endpoint payload.
func NewChatStreamingBody(body *ChatStreamingBody) *websocketsvc.ChatInput {
	v := &websocketsvc.ChatInput{
		Message:       *body.Message,
		StreamControl: body.StreamControl,
	}
	if body.Context != nil {
		v.Context = make(map[string]any, len(body.Context))
		for key, val := range body.Context {
			tk := key
			tv := val
			v.Context[tk] = tv
		}
	}

	return v
}

// NewInteractiveChatStreamingBody builds a websocket service interactive_chat
// endpoint payload.
func NewInteractiveChatStreamingBody(body *InteractiveChatStreamingBody) *websocketsvc.ChatInput {
	v := &websocketsvc.ChatInput{
		Message:       *body.Message,
		StreamControl: body.StreamControl,
	}
	if body.Context != nil {
		v.Context = make(map[string]any, len(body.Context))
		for key, val := range body.Context {
			tk := key
			tv := val
			v.Context[tk] = tv
		}
	}

	return v
}

// ValidateUploadChunksStreamingBody runs the validations defined on
// upload_chunks_streaming_body
func ValidateUploadChunksStreamingBody(body *UploadChunksStreamingBody) (err error) {
	if body.DocumentID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("document_id", "body"))
	}
	if body.ChunkIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chunk_index", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	return
}

// ValidateUploadDocumentsStreamingBody runs the validations defined on
// upload_documents_streaming_body
func ValidateUploadDocumentsStreamingBody(body *UploadDocumentsStreamingBody) (err error) {
	if body.DocumentID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("document_id", "body"))
	}
	if body.ChunkIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chunk_index", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	return
}

// ValidateChatStreamingBody runs the validations defined on ChatStreamingBody
func ValidateChatStreamingBody(body *ChatStreamingBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.StreamControl != nil {
		if !(*body.StreamControl == "continue" || *body.StreamControl == "pause" || *body.StreamControl == "stop") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.stream_control", *body.StreamControl, []any{"continue", "pause", "stop"}))
		}
	}
	return
}

// ValidateInteractiveChatStreamingBody runs the validations defined on
// interactive_chat_streaming_body
func ValidateInteractiveChatStreamingBody(body *InteractiveChatStreamingBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.StreamControl != nil {
		if !(*body.StreamControl == "continue" || *body.StreamControl == "pause" || *body.StreamControl == "stop") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.stream_control", *body.StreamControl, []any{"continue", "pause", "stop"}))
		}
	}
	return
}

// ValidateDocumentChunkStreamingBody runs the validations defined on
// DocumentChunkStreamingBody
func ValidateDocumentChunkStreamingBody(body *DocumentChunkStreamingBody) (err error) {
	if body.DocumentID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("document_id", "body"))
	}
	if body.ChunkIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chunk_index", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	return
}

// ValidateChatInputStreamingBody runs the validations defined on
// ChatInputStreamingBody
func ValidateChatInputStreamingBody(body *ChatInputStreamingBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.StreamControl != nil {
		if !(*body.StreamControl == "continue" || *body.StreamControl == "pause" || *body.StreamControl == "stop") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.stream_control", *body.StreamControl, []any{"continue", "pause", "stop"}))
		}
	}
	return
}
