// Code generated by goa v3.22.2, DO NOT EDIT.
//
// websocket HTTP client types
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	websocketsvc "example.com/assistant/gen/websocket"
	goa "goa.design/goa/v3/pkg"
)

// UploadChunksStreamingBody is the type of the "websocket" service
// "upload_chunks" endpoint HTTP request body.
type UploadChunksStreamingBody DocumentChunkStreamingBody

// UploadDocumentsStreamingBody is the type of the "websocket" service
// "upload_documents" endpoint HTTP request body.
type UploadDocumentsStreamingBody DocumentChunkStreamingBody

// ChatStreamingBody is the type of the "websocket" service "chat" endpoint
// HTTP request body.
type ChatStreamingBody ChatInputStreamingBody

// InteractiveChatStreamingBody is the type of the "websocket" service
// "interactive_chat" endpoint HTTP request body.
type InteractiveChatStreamingBody ChatInputStreamingBody

// UploadChunksResponseBody is the type of the "websocket" service
// "upload_chunks" endpoint HTTP response body.
type UploadChunksResponseBody struct {
	// Total size
	TotalSize *int `form:"total_size,omitempty" json:"total_size,omitempty" xml:"total_size,omitempty"`
	// Number of chunks
	ChunkCount *int `form:"chunk_count,omitempty" json:"chunk_count,omitempty" xml:"chunk_count,omitempty"`
}

// UploadDocumentsResponseBody is the type of the "websocket" service
// "upload_documents" endpoint HTTP response body.
type UploadDocumentsResponseBody struct {
	// Total size
	TotalSize *int `form:"total_size,omitempty" json:"total_size,omitempty" xml:"total_size,omitempty"`
	// Number of documents
	DocumentCount *int `form:"document_count,omitempty" json:"document_count,omitempty" xml:"document_count,omitempty"`
}

// ChatResponseBody is the type of the "websocket" service "chat" endpoint HTTP
// response body.
type ChatResponseBody struct {
	// Assistant response
	Response *string `form:"response,omitempty" json:"response,omitempty" xml:"response,omitempty"`
	// Whether assistant is still thinking
	Thinking *bool `form:"thinking,omitempty" json:"thinking,omitempty" xml:"thinking,omitempty"`
	// Response metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// InteractiveChatResponseBody is the type of the "websocket" service
// "interactive_chat" endpoint HTTP response body.
type InteractiveChatResponseBody struct {
	// Assistant response
	Response *string `form:"response,omitempty" json:"response,omitempty" xml:"response,omitempty"`
	// Whether assistant is still thinking
	Thinking *bool `form:"thinking,omitempty" json:"thinking,omitempty" xml:"thinking,omitempty"`
	// Response metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// DocumentChunkStreamingBody is used to define fields on request body types.
type DocumentChunkStreamingBody struct {
	// Document ID
	DocumentID string `form:"document_id" json:"document_id" xml:"document_id"`
	// Chunk index
	ChunkIndex int `form:"chunk_index" json:"chunk_index" xml:"chunk_index"`
	// Total number of chunks
	TotalChunks *int `form:"total_chunks,omitempty" json:"total_chunks,omitempty" xml:"total_chunks,omitempty"`
	// Chunk data
	Data []byte `form:"data" json:"data" xml:"data"`
	// Document metadata
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// ChatInputStreamingBody is used to define fields on request body types.
type ChatInputStreamingBody struct {
	// User message
	Message string `form:"message" json:"message" xml:"message"`
	// Additional context
	Context map[string]any `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Stream control command
	StreamControl *string `form:"stream_control,omitempty" json:"stream_control,omitempty" xml:"stream_control,omitempty"`
}

// NewUploadChunksStreamingBody builds the HTTP request body from the payload
// of the "upload_chunks" endpoint of the "websocket" service.
func NewUploadChunksStreamingBody(p *websocketsvc.DocumentChunk) *UploadChunksStreamingBody {
	body := &UploadChunksStreamingBody{
		DocumentID:  p.DocumentID,
		ChunkIndex:  p.ChunkIndex,
		TotalChunks: p.TotalChunks,
		Data:        p.Data,
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]any, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewUploadDocumentsStreamingBody builds the HTTP request body from the
// payload of the "upload_documents" endpoint of the "websocket" service.
func NewUploadDocumentsStreamingBody(p *websocketsvc.DocumentChunk) *UploadDocumentsStreamingBody {
	body := &UploadDocumentsStreamingBody{
		DocumentID:  p.DocumentID,
		ChunkIndex:  p.ChunkIndex,
		TotalChunks: p.TotalChunks,
		Data:        p.Data,
	}
	if p.Metadata != nil {
		body.Metadata = make(map[string]any, len(p.Metadata))
		for key, val := range p.Metadata {
			tk := key
			tv := val
			body.Metadata[tk] = tv
		}
	}
	return body
}

// NewChatStreamingBody builds the HTTP request body from the payload of the
// "chat" endpoint of the "websocket" service.
func NewChatStreamingBody(p *websocketsvc.ChatInput) *ChatStreamingBody {
	body := &ChatStreamingBody{
		Message:       p.Message,
		StreamControl: p.StreamControl,
	}
	if p.Context != nil {
		body.Context = make(map[string]any, len(p.Context))
		for key, val := range p.Context {
			tk := key
			tv := val
			body.Context[tk] = tv
		}
	}
	return body
}

// NewInteractiveChatStreamingBody builds the HTTP request body from the
// payload of the "interactive_chat" endpoint of the "websocket" service.
func NewInteractiveChatStreamingBody(p *websocketsvc.ChatInput) *InteractiveChatStreamingBody {
	body := &InteractiveChatStreamingBody{
		Message:       p.Message,
		StreamControl: p.StreamControl,
	}
	if p.Context != nil {
		body.Context = make(map[string]any, len(p.Context))
		for key, val := range p.Context {
			tk := key
			tv := val
			body.Context[tk] = tv
		}
	}
	return body
}

// NewUploadChunksResultOK builds a "websocket" service "upload_chunks"
// endpoint result from a HTTP "OK" response.
func NewUploadChunksResultOK(body *UploadChunksResponseBody) *websocketsvc.UploadChunksResult {
	v := &websocketsvc.UploadChunksResult{
		TotalSize:  *body.TotalSize,
		ChunkCount: *body.ChunkCount,
	}

	return v
}

// NewUploadDocumentsResultOK builds a "websocket" service "upload_documents"
// endpoint result from a HTTP "OK" response.
func NewUploadDocumentsResultOK(body *UploadDocumentsResponseBody) *websocketsvc.UploadDocumentsResult {
	v := &websocketsvc.UploadDocumentsResult{
		TotalSize:     *body.TotalSize,
		DocumentCount: *body.DocumentCount,
	}

	return v
}

// NewChatResponseOK builds a "websocket" service "chat" endpoint result from a
// HTTP "OK" response.
func NewChatResponseOK(body *ChatResponseBody) *websocketsvc.ChatResponse {
	v := &websocketsvc.ChatResponse{
		Response: *body.Response,
		Thinking: *body.Thinking,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// NewInteractiveChatChatResponseOK builds a "websocket" service
// "interactive_chat" endpoint result from a HTTP "OK" response.
func NewInteractiveChatChatResponseOK(body *InteractiveChatResponseBody) *websocketsvc.ChatResponse {
	v := &websocketsvc.ChatResponse{
		Response: *body.Response,
		Thinking: *body.Thinking,
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// ValidateUploadChunksResponseBody runs the validations defined on
// upload_chunks_response_body
func ValidateUploadChunksResponseBody(body *UploadChunksResponseBody) (err error) {
	if body.TotalSize == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("total_size", "body"))
	}
	if body.ChunkCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chunk_count", "body"))
	}
	return
}

// ValidateUploadDocumentsResponseBody runs the validations defined on
// upload_documents_response_body
func ValidateUploadDocumentsResponseBody(body *UploadDocumentsResponseBody) (err error) {
	if body.TotalSize == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("total_size", "body"))
	}
	if body.DocumentCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("document_count", "body"))
	}
	return
}

// ValidateChatResponseBody runs the validations defined on ChatResponseBody
func ValidateChatResponseBody(body *ChatResponseBody) (err error) {
	if body.Response == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("response", "body"))
	}
	if body.Thinking == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("thinking", "body"))
	}
	return
}

// ValidateInteractiveChatResponseBody runs the validations defined on
// interactive_chat_response_body
func ValidateInteractiveChatResponseBody(body *InteractiveChatResponseBody) (err error) {
	if body.Response == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("response", "body"))
	}
	if body.Thinking == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("thinking", "body"))
	}
	return
}

// ValidateDocumentChunkStreamingBody runs the validations defined on
// DocumentChunkStreamingBody
func ValidateDocumentChunkStreamingBody(body *DocumentChunkStreamingBody) (err error) {
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	return
}

// ValidateChatInputStreamingBody runs the validations defined on
// ChatInputStreamingBody
func ValidateChatInputStreamingBody(body *ChatInputStreamingBody) (err error) {
	if body.StreamControl != nil {
		if !(*body.StreamControl == "continue" || *body.StreamControl == "pause" || *body.StreamControl == "stop") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.stream_control", *body.StreamControl, []any{"continue", "pause", "stop"}))
		}
	}
	return
}
