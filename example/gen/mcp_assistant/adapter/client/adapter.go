// Code generated by goa v3.22.2, DO NOT EDIT.
//
// MCP client adapter exposing original service endpoints
//
// Command:
// $ goa gen example.com/assistant/design

package mcpAssistantadapter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"sort"
	"strings"

	assistant "example.com/assistant/gen/assistant"
	assistantjsonrpcc "example.com/assistant/gen/jsonrpc/assistant/client"
	mcpAssistantjsonrpcc "example.com/assistant/gen/jsonrpc/mcp_assistant/client"
	mcpAssistant "example.com/assistant/gen/mcp_assistant"
	retry "goa.design/goa-ai/retry"
	goahttp "goa.design/goa/v3/http"
	jsonrpc "goa.design/goa/v3/jsonrpc"
)

// NewEndpoints creates endpoints that expose the original service API while
// invoking the MCP transport under the hood for mapped methods. Unmapped
// methods transparently fall back to the original JSON-RPC transport.
// NewEndpoints creates an Endpoints set that routes mapped methods through
// the MCP transport while leaving unmapped methods on the original transport.
func NewEndpoints(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Endpoints {
	// Transport clients
	mcpC := mcpAssistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)
	origC := assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)

	// Build endpoints matching the original service
	e := &assistant.Endpoints{}
	// Tool: analyze_text -> AnalyzeText
	e.AnalyzeText = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.AnalyzeTextPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "analyze_text", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:analyze_text", err.Error(), "{\"mode\":\"sentiment\",\"text\":\"I love this new feature! It works perfectly.\"}", "{\"additionalProperties\":false,\"properties\":{\"mode\":{\"enum\":[\"sentiment\",\"keywords\",\"summary\"],\"type\":\"string\"},\"text\":{\"maxLength\":10000,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"text\",\"mode\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for analyze_text")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:analyze_text", recvErr.Error(), "{\"mode\":\"sentiment\",\"text\":\"I love this new feature! It works perfectly.\"}", "{\"additionalProperties\":false,\"properties\":{\"mode\":{\"enum\":[\"sentiment\",\"keywords\",\"summary\"],\"type\":\"string\"},\"text\":{\"maxLength\":10000,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"text\",\"mode\"],\"type\":\"object\"}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:analyze_text", "empty MCP tool response", "{\"mode\":\"sentiment\",\"text\":\"I love this new feature! It works perfectly.\"}", "{\"additionalProperties\":false,\"properties\":{\"mode\":{\"enum\":[\"sentiment\",\"keywords\",\"summary\"],\"type\":\"string\"},\"text\":{\"maxLength\":10000,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"text\",\"mode\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for analyze_text")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildAnalyzeTextRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeAnalyzeTextResponse(dec, false)
		return decode(resp)
	}
	// Tool: search -> SearchKnowledge
	e.SearchKnowledge = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.SearchKnowledgePayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "search", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:search", err.Error(), "{\"limit\":5,\"query\":\"MCP protocol\"}", "{\"additionalProperties\":false,\"properties\":{\"limit\":{\"maximum\":100,\"minimum\":1,\"type\":\"integer\"},\"query\":{\"maxLength\":256,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"query\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for search")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:search", recvErr.Error(), "{\"limit\":5,\"query\":\"MCP protocol\"}", "{\"additionalProperties\":false,\"properties\":{\"limit\":{\"maximum\":100,\"minimum\":1,\"type\":\"integer\"},\"query\":{\"maxLength\":256,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"query\"],\"type\":\"object\"}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:search", "empty MCP tool response", "{\"limit\":5,\"query\":\"MCP protocol\"}", "{\"additionalProperties\":false,\"properties\":{\"limit\":{\"maximum\":100,\"minimum\":1,\"type\":\"integer\"},\"query\":{\"maxLength\":256,\"minLength\":1,\"type\":\"string\"}},\"required\":[\"query\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for search")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildSearchKnowledgeRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeSearchKnowledgeResponse(dec, false)
		return decode(resp)
	}
	// Tool: execute_code -> ExecuteCode
	e.ExecuteCode = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.ExecuteCodePayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "execute_code", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:execute_code", err.Error(), "{\"code\":\"print(2 + 2)\",\"language\":\"python\"}", "{\"additionalProperties\":false,\"properties\":{\"code\":{\"maxLength\":20000,\"minLength\":1,\"type\":\"string\"},\"language\":{\"enum\":[\"python\",\"javascript\",\"go\"],\"type\":\"string\"}},\"required\":[\"language\",\"code\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for execute_code")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:execute_code", recvErr.Error(), "{\"code\":\"print(2 + 2)\",\"language\":\"python\"}", "{\"additionalProperties\":false,\"properties\":{\"code\":{\"maxLength\":20000,\"minLength\":1,\"type\":\"string\"},\"language\":{\"enum\":[\"python\",\"javascript\",\"go\"],\"type\":\"string\"}},\"required\":[\"language\",\"code\"],\"type\":\"object\"}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:execute_code", "empty MCP tool response", "{\"code\":\"print(2 + 2)\",\"language\":\"python\"}", "{\"additionalProperties\":false,\"properties\":{\"code\":{\"maxLength\":20000,\"minLength\":1,\"type\":\"string\"},\"language\":{\"enum\":[\"python\",\"javascript\",\"go\"],\"type\":\"string\"}},\"required\":[\"language\",\"code\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for execute_code")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildExecuteCodeRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeExecuteCodeResponse(dec, false)
		return decode(resp)
	}
	// Tool: process_batch -> ProcessBatch
	e.ProcessBatch = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to raw JSON using Goa encoder (no JSON-RPC envelope)
		var args []byte
		{
			var payload any
			payload = v.(*assistant.ProcessBatchPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}

		// Call MCP tools/call via transport endpoint (SSE stream)
		streamAny, err := mcpC.ToolsCall()(ctx, &mcpAssistant.ToolsCallPayload{Name: "process_batch", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("tools/call:process_batch", err.Error(), "{\"blob\":\"aGVsbG8=\",\"format\":\"text\",\"items\":[\"item1\",\"item2\"],\"mimeType\":\"text/plain\",\"uri\":\"system://info\"}", "{\"additionalProperties\":false,\"properties\":{\"blob\":{\"contentEncoding\":\"base64\",\"type\":\"string\"},\"format\":{\"enum\":[\"text\",\"blob\",\"uri\"],\"type\":\"string\"},\"items\":{\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"mimeType\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"}},\"required\":[\"items\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		stream, ok := streamAny.(*mcpAssistantjsonrpcc.ToolsCallClientStream)
		if !ok {
			return nil, fmt.Errorf("unexpected stream type for process_batch")
		}
		var r *mcpAssistant.ToolsCallResult
		for {
			ev, recvErr := stream.Recv(ctx)
			if recvErr == io.EOF {
				break
			}
			if recvErr != nil {
				prompt := retry.BuildRepairPrompt("tools/call:process_batch", recvErr.Error(), "{\"blob\":\"aGVsbG8=\",\"format\":\"text\",\"items\":[\"item1\",\"item2\"],\"mimeType\":\"text/plain\",\"uri\":\"system://info\"}", "{\"additionalProperties\":false,\"properties\":{\"blob\":{\"contentEncoding\":\"base64\",\"type\":\"string\"},\"format\":{\"enum\":[\"text\",\"blob\",\"uri\"],\"type\":\"string\"},\"items\":{\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"mimeType\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"}},\"required\":[\"items\"],\"type\":\"object\"}")
				return nil, &retry.RetryableError{Prompt: prompt, Cause: recvErr}
			}
			r = ev
		}
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			prompt := retry.BuildRepairPrompt("tools/call:process_batch", "empty MCP tool response", "{\"blob\":\"aGVsbG8=\",\"format\":\"text\",\"items\":[\"item1\",\"item2\"],\"mimeType\":\"text/plain\",\"uri\":\"system://info\"}", "{\"additionalProperties\":false,\"properties\":{\"blob\":{\"contentEncoding\":\"base64\",\"type\":\"string\"},\"format\":{\"enum\":[\"text\",\"blob\",\"uri\"],\"type\":\"string\"},\"items\":{\"items\":{\"type\":\"string\"},\"minItems\":1,\"type\":\"array\"},\"mimeType\":{\"type\":\"string\"},\"uri\":{\"type\":\"string\"}},\"required\":[\"items\"],\"type\":\"object\"}")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP tool response for process_batch")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildProcessBatchRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeProcessBatchResponse(dec, false)
		return decode(resp)
	}
	// Resource: doc://list -> ListDocuments
	e.ListDocuments = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "doc://list"
		{
			var payload any
			payload = struct{}{}
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for doc://list")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildListDocumentsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeListDocumentsResponse(dec, false)
		return decode(resp)
	}
	// Resource: system://info -> GetSystemInfo
	e.GetSystemInfo = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "system://info"
		{
			var payload any
			payload = struct{}{}
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for system://info")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildGetSystemInfoRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGetSystemInfoResponse(dec, false)
		return decode(resp)
	}
	// Resource: conversation://history -> GetConversationHistory
	e.GetConversationHistory = func(ctx context.Context, v any) (any, error) {
		// Forward original payload parameters via URI query string when applicable
		uri := "conversation://history"
		{
			var payload any
			payload = v.(*assistant.GetConversationHistoryPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err == nil {
				b, rerr := io.ReadAll(reqArgs.Body)
				if rerr == nil && len(b) > 0 {
					var m map[string]any
					if jerr := json.Unmarshal(b, &m); jerr == nil && len(m) > 0 {
						var keys []string
						for k := range m {
							keys = append(keys, k)
						}
						sort.Strings(keys)
						var q []string
						for _, k := range keys {
							switch vv := m[k].(type) {
							case []any:
								for _, e := range vv {
									q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(e))))
								}
							default:
								q = append(q, fmt.Sprintf("%s=%v", url.QueryEscape(k), url.QueryEscape(fmt.Sprint(vv))))
							}
						}
						if len(q) > 0 {
							uri = uri + "?" + strings.Join(q, "&")
						}
					}
				}
			}
		}
		ires, err := mcpC.ResourcesRead()(ctx, &mcpAssistant.ResourcesReadPayload{URI: uri})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpAssistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for conversation://history")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildGetConversationHistoryRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGetConversationHistoryResponse(dec, false)
		return decode(resp)
	}
	// Dynamic Prompt: contextual_prompts -> GeneratePrompts
	e.GeneratePrompts = func(ctx context.Context, v any) (any, error) {
		var args []byte
		{
			var payload any
			payload = v.(*assistant.GeneratePromptsPayload)
			reqArgs, _ := http.NewRequestWithContext(ctx, http.MethodPost, "", nil)
			if err := enc(reqArgs).Encode(payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(reqArgs.Body)
			if err != nil {
				return nil, err
			}
			args = b
		}
		ires, err := mcpC.PromptsGet()(ctx, &mcpAssistant.PromptsGetPayload{Name: "contextual_prompts", Arguments: args})
		if err != nil {
			prompt := retry.BuildRepairPrompt("prompts/get:contextual_prompts", err.Error(), "{\"context\":\"testing\",\"task\":\"unit-test\"}", "")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: err}
		}
		r := ires.(*mcpAssistant.PromptsGetResult)
		if r == nil || r.Messages == nil || len(r.Messages) == 0 || r.Messages[0] == nil || r.Messages[0].Content == nil || r.Messages[0].Content.Text == nil {
			prompt := retry.BuildRepairPrompt("prompts/get:contextual_prompts", "empty MCP prompt response", "{\"context\":\"testing\",\"task\":\"unit-test\"}", "")
			return nil, &retry.RetryableError{Prompt: prompt, Cause: fmt.Errorf("empty MCP prompt response for contextual_prompts")}
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Messages[0].Content.Text)}
		req3, _ := origC.BuildGeneratePromptsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGeneratePromptsResponse(dec, false)
		return decode(resp)
	}

	return e
}

// NewClient returns *assistant.Client using MCP-backed endpoints.
func NewClient(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Client {
	e := NewEndpoints(scheme, host, doer, enc, dec, restore)
	origClient := assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)
	return assistant.NewClient(
		e.AnalyzeText,
		e.SearchKnowledge,
		e.ExecuteCode,
		e.ListDocuments,
		e.GetSystemInfo,
		e.GetConversationHistory,
		e.GeneratePrompts,
		origClient.SendNotification(),
		origClient.SubscribeToUpdates(),
		e.ProcessBatch,
	)
}
