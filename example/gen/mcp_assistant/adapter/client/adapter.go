// Code generated by goa v3.22.2, DO NOT EDIT.
//
// MCP client adapter exposing original service endpoints
//
// Command:
// $ goa gen example.com/assistant/design

package mcpassistantadapter

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"

	assistant "example.com/assistant/gen/assistant"
	assistantjsonrpcc "example.com/assistant/gen/jsonrpc/assistant/client"
	mcpassistantjsonrpcc "example.com/assistant/gen/jsonrpc/mcp_assistant/client"
	mcpassistant "example.com/assistant/gen/mcp_assistant"
	goahttp "goa.design/goa/v3/http"
	jsonrpc "goa.design/goa/v3/jsonrpc"
)

// NewEndpoints creates endpoints that expose the original service API while
// invoking the MCP transport under the hood for mapped methods. Unmapped
// methods transparently fall back to the original JSON-RPC transport.
// NewEndpoints creates an Endpoints set that routes mapped methods through
// the MCP transport while leaving unmapped methods on the original transport.
func NewEndpoints(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Endpoints {
	// Transport clients
	mcpC := mcpassistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)
	origC := assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore)

	// Build endpoints matching the original service
	e := &assistant.Endpoints{}
	// Tool: analyze_text -> AnalyzeText
	e.AnalyzeText = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to JSON-RPC request using Goa encoder, then extract params
		var args []byte
		{
			req, err := origC.BuildAnalyzeTextRequest(ctx, v)
			if err != nil {
				return nil, err
			}
			encReq := assistantjsonrpcc.EncodeAnalyzeTextRequest(enc)
			var payload any
			payload = v.(*assistant.AnalyzeTextPayload)
			if err := encReq(req, payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(req.Body)
			if err != nil {
				return nil, err
			}
			resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(b))}
			var jr jsonrpc.Request
			if err := dec(resp).Decode(&jr); err != nil {
				return nil, err
			}
			// Re-encode params using Goa encoder to get raw bytes
			req2, _ := origC.BuildAnalyzeTextRequest(ctx, v)
			if err := enc(req2).Encode(jr.Params); err != nil {
				return nil, err
			}
			args, err = io.ReadAll(req2.Body)
			if err != nil {
				return nil, err
			}
		}

		// Call MCP tools/call via transport endpoint
		ires, err := mcpC.ToolsCall()(ctx, &mcpassistant.ToolsCallPayload{Name: "analyze_text", Arguments: args})
		if err != nil {
			return nil, err
		}
		r := ires.(*mcpassistant.ToolsCallResult)
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			return nil, fmt.Errorf("empty MCP tool response for analyze_text")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildAnalyzeTextRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeAnalyzeTextResponse(dec, false)
		return decode(resp)
	}
	// Tool: search -> SearchKnowledge
	e.SearchKnowledge = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to JSON-RPC request using Goa encoder, then extract params
		var args []byte
		{
			req, err := origC.BuildSearchKnowledgeRequest(ctx, v)
			if err != nil {
				return nil, err
			}
			encReq := assistantjsonrpcc.EncodeSearchKnowledgeRequest(enc)
			var payload any
			payload = v.(*assistant.SearchKnowledgePayload)
			if err := encReq(req, payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(req.Body)
			if err != nil {
				return nil, err
			}
			resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(b))}
			var jr jsonrpc.Request
			if err := dec(resp).Decode(&jr); err != nil {
				return nil, err
			}
			// Re-encode params using Goa encoder to get raw bytes
			req2, _ := origC.BuildSearchKnowledgeRequest(ctx, v)
			if err := enc(req2).Encode(jr.Params); err != nil {
				return nil, err
			}
			args, err = io.ReadAll(req2.Body)
			if err != nil {
				return nil, err
			}
		}

		// Call MCP tools/call via transport endpoint
		ires, err := mcpC.ToolsCall()(ctx, &mcpassistant.ToolsCallPayload{Name: "search", Arguments: args})
		if err != nil {
			return nil, err
		}
		r := ires.(*mcpassistant.ToolsCallResult)
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			return nil, fmt.Errorf("empty MCP tool response for search")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildSearchKnowledgeRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeSearchKnowledgeResponse(dec, false)
		return decode(resp)
	}
	// Tool: execute_code -> ExecuteCode
	e.ExecuteCode = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to JSON-RPC request using Goa encoder, then extract params
		var args []byte
		{
			req, err := origC.BuildExecuteCodeRequest(ctx, v)
			if err != nil {
				return nil, err
			}
			encReq := assistantjsonrpcc.EncodeExecuteCodeRequest(enc)
			var payload any
			payload = v.(*assistant.ExecuteCodePayload)
			if err := encReq(req, payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(req.Body)
			if err != nil {
				return nil, err
			}
			resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(b))}
			var jr jsonrpc.Request
			if err := dec(resp).Decode(&jr); err != nil {
				return nil, err
			}
			// Re-encode params using Goa encoder to get raw bytes
			req2, _ := origC.BuildExecuteCodeRequest(ctx, v)
			if err := enc(req2).Encode(jr.Params); err != nil {
				return nil, err
			}
			args, err = io.ReadAll(req2.Body)
			if err != nil {
				return nil, err
			}
		}

		// Call MCP tools/call via transport endpoint
		ires, err := mcpC.ToolsCall()(ctx, &mcpassistant.ToolsCallPayload{Name: "execute_code", Arguments: args})
		if err != nil {
			return nil, err
		}
		r := ires.(*mcpassistant.ToolsCallResult)
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			return nil, fmt.Errorf("empty MCP tool response for execute_code")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildExecuteCodeRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeExecuteCodeResponse(dec, false)
		return decode(resp)
	}
	// Tool: process_batch -> ProcessBatch
	e.ProcessBatch = func(ctx context.Context, v any) (any, error) {
		// Encode original payload to JSON-RPC request using Goa encoder, then extract params
		var args []byte
		{
			req, err := origC.BuildProcessBatchRequest(ctx, v)
			if err != nil {
				return nil, err
			}
			encReq := assistantjsonrpcc.EncodeProcessBatchRequest(enc)
			var payload any
			payload = v.(*assistant.ProcessBatchPayload)
			if err := encReq(req, payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(req.Body)
			if err != nil {
				return nil, err
			}
			resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(b))}
			var jr jsonrpc.Request
			if err := dec(resp).Decode(&jr); err != nil {
				return nil, err
			}
			// Re-encode params using Goa encoder to get raw bytes
			req2, _ := origC.BuildProcessBatchRequest(ctx, v)
			if err := enc(req2).Encode(jr.Params); err != nil {
				return nil, err
			}
			args, err = io.ReadAll(req2.Body)
			if err != nil {
				return nil, err
			}
		}

		// Call MCP tools/call via transport endpoint
		ires, err := mcpC.ToolsCall()(ctx, &mcpassistant.ToolsCallPayload{Name: "process_batch", Arguments: args})
		if err != nil {
			return nil, err
		}
		r := ires.(*mcpassistant.ToolsCallResult)
		if r == nil || r.Content == nil || len(r.Content) == 0 || r.Content[0] == nil || r.Content[0].Text == nil {
			return nil, fmt.Errorf("empty MCP tool response for process_batch")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		rr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Content[0].Text)}
		req3, _ := origC.BuildProcessBatchRequest(ctx, v)
		if err := enc(req3).Encode(rr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeProcessBatchResponse(dec, false)
		return decode(resp)
	}
	// Resource: doc://list -> ListDocuments
	e.ListDocuments = func(ctx context.Context, v any) (any, error) {
		// Resources in MCP don't support parameters, only URI
		ires, err := mcpC.ResourcesRead()(ctx, &mcpassistant.ResourcesReadPayload{URI: "doc://list"})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpassistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for doc://list")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildListDocumentsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeListDocumentsResponse(dec, false)
		return decode(resp)
	}
	// Resource: system://info -> GetSystemInfo
	e.GetSystemInfo = func(ctx context.Context, v any) (any, error) {
		// Resources in MCP don't support parameters, only URI
		ires, err := mcpC.ResourcesRead()(ctx, &mcpassistant.ResourcesReadPayload{URI: "system://info"})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpassistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for system://info")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildGetSystemInfoRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGetSystemInfoResponse(dec, false)
		return decode(resp)
	}
	// Resource: conversation://history -> GetConversationHistory
	e.GetConversationHistory = func(ctx context.Context, v any) (any, error) {
		// Resources in MCP don't support parameters, only URI
		ires, err := mcpC.ResourcesRead()(ctx, &mcpassistant.ResourcesReadPayload{URI: "conversation://history"})
		if err != nil {
			return nil, err
		}
		rr := ires.(*mcpassistant.ResourcesReadResult)
		if rr == nil || rr.Contents == nil || len(rr.Contents) == 0 || rr.Contents[0] == nil || rr.Contents[0].Text == nil {
			return nil, fmt.Errorf("empty MCP resource response for conversation://history")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*rr.Contents[0].Text)}
		req3, _ := origC.BuildGetConversationHistoryRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGetConversationHistoryResponse(dec, false)
		return decode(resp)
	}
	// Dynamic Prompt: contextual_prompts -> GeneratePrompts
	e.GeneratePrompts = func(ctx context.Context, v any) (any, error) {
		var args []byte
		{
			req, err := origC.BuildGeneratePromptsRequest(ctx, v)
			if err != nil {
				return nil, err
			}
			encReq := assistantjsonrpcc.EncodeGeneratePromptsRequest(enc)
			var payload any
			payload = v.(*assistant.GeneratePromptsPayload)
			if err := encReq(req, payload); err != nil {
				return nil, err
			}
			b, err := io.ReadAll(req.Body)
			if err != nil {
				return nil, err
			}
			resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(b))}
			var jr jsonrpc.Request
			if err := dec(resp).Decode(&jr); err != nil {
				return nil, err
			}
			req2, _ := origC.BuildGeneratePromptsRequest(ctx, v)
			if err := enc(req2).Encode(jr.Params); err != nil {
				return nil, err
			}
			args, err = io.ReadAll(req2.Body)
			if err != nil {
				return nil, err
			}
		}
		ires, err := mcpC.PromptsGet()(ctx, &mcpassistant.PromptsGetPayload{Name: "contextual_prompts", Arguments: args})
		if err != nil {
			return nil, err
		}
		r := ires.(*mcpassistant.PromptsGetResult)
		if r == nil || r.Messages == nil || len(r.Messages) == 0 || r.Messages[0] == nil || r.Messages[0].Content == nil || r.Messages[0].Content.Text == nil {
			return nil, fmt.Errorf("empty MCP prompt response for contextual_prompts")
		}
		// Build JSON-RPC response envelope and decode using Goa-generated decoder
		jrr := &jsonrpc.RawResponse{JSONRPC: "2.0", Result: []byte(*r.Messages[0].Content.Text)}
		req3, _ := origC.BuildGeneratePromptsRequest(ctx, v)
		if err := enc(req3).Encode(jrr); err != nil {
			return nil, err
		}
		bodyBytes, err := io.ReadAll(req3.Body)
		if err != nil {
			return nil, err
		}
		resp := &http.Response{StatusCode: http.StatusOK, Body: io.NopCloser(bytes.NewReader(bodyBytes))}
		decode := assistantjsonrpcc.DecodeGeneratePromptsResponse(dec, false)
		return decode(resp)
	}

	return e
}

// NewClient returns *assistant.Client using MCP-backed endpoints.
func NewClient(
	scheme string,
	host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) *assistant.Client {
	e := NewEndpoints(scheme, host, doer, enc, dec, restore)
	return assistant.NewClient(
		e.AnalyzeText,
		e.SearchKnowledge,
		e.ExecuteCode,
		e.ListDocuments,
		e.GetSystemInfo,
		e.GetConversationHistory,
		e.GeneratePrompts,
		assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore).GetWorkspaceInfo(),
		assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore).SendNotification(),
		assistantjsonrpcc.NewClient(scheme, host, doer, enc, dec, restore).SubscribeToUpdates(),
		e.ProcessBatch,
	)
}
