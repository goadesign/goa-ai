// Code generated by goa v3.22.2, DO NOT EDIT.
//
// MCP server adapter for assistant service
//
// Command:
// $ goa gen example.com/assistant/design

package mcpassistant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"

	assistant "example.com/assistant/gen/assistant"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// MCPAdapter core: types, options, constructor, helpers

type MCPAdapter struct {
	service        assistant.Service
	initialized    bool
	mu             sync.RWMutex
	opts           *MCPAdapterOptions
	promptProvider PromptProvider
	// Minimal subscription registry keyed by resource URI
	subs   map[string]int
	subsMu sync.Mutex
	// Broadcaster for server-initiated events (notifications/resources)
	broadcaster Broadcaster
	// resourceNameToURI holds DSL-derived mapping for policy and lookups
	resourceNameToURI map[string]string
}

// MCPAdapterOptions allows customizing adapter behavior.
type MCPAdapterOptions struct {
	// Logger is an optional hook called with internal adapter events.
	Logger func(ctx context.Context, event string, details any)
	// ErrorMapper allows mapping arbitrary errors to framework-friendly errors
	ErrorMapper func(error) error
	// Allowed/Deny lists for resource URIs; Denied takes precedence unless header allow overrides
	AllowedResourceURIs []string
	DeniedResourceURIs  []string
	// Name-based policy resolved to URIs at construction
	AllowedResourceNames    []string
	DeniedResourceNames     []string
	StructuredStreamJSON    bool
	ProtocolVersionOverride string
	// Pluggable broadcaster, else default channel broadcaster
	Broadcaster     Broadcaster
	BroadcastBuffer int
	DropIfSlow      bool
}

// mcpProtocolVersion resolves the protocol version from options or default.
func (a *MCPAdapter) mcpProtocolVersion() string {
	if a != nil && a.opts != nil && a.opts.ProtocolVersionOverride != "" {
		return a.opts.ProtocolVersionOverride
	}
	return DefaultProtocolVersion
}

// bufferResponseWriter writes to a buffer to reuse Goa encoders without HTTP response.
type bufferResponseWriter struct {
	headers http.Header
	buf     bytes.Buffer
}

func (w *bufferResponseWriter) Header() http.Header {
	if w.headers == nil {
		w.headers = make(http.Header)
	}
	return w.headers
}
func (w *bufferResponseWriter) WriteHeader(statusCode int)  {}
func (w *bufferResponseWriter) Write(p []byte) (int, error) { return w.buf.Write(p) }

func encodeJSONToString(ctx context.Context, v any) (string, error) {
	bw := &bufferResponseWriter{}
	if err := goahttp.ResponseEncoder(ctx, bw).Encode(v); err != nil {
		return "", err
	}
	return bw.buf.String(), nil
}

// parseQueryParamsToJSON converts URI query params into JSON.
func parseQueryParamsToJSON(uri string) ([]byte, error) {
	u, err := url.Parse(uri)
	if err != nil {
		return nil, fmt.Errorf("invalid resource URI: %w", err)
	}
	q := u.Query()
	if len(q) == 0 {
		return []byte("{}"), nil
	}
	m := make(map[string]any, len(q))
	for k, vals := range q {
		if len(vals) == 1 {
			m[k] = coerce(vals[0])
			continue
		}
		arr := make([]any, len(vals))
		for i := range vals {
			arr[i] = coerce(vals[i])
		}
		m[k] = arr
	}
	return json.Marshal(m)
}

func coerce(s string) any {
	ls := strings.ToLower(s)
	switch ls {
	case "true", "t", "1":
		return true
	case "false", "f", "0":
		return false
	}
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	return s
}

func NewMCPAdapter(service assistant.Service, promptProvider PromptProvider, opts *MCPAdapterOptions) *MCPAdapter {
	// Resolve name-based policy to URIs
	if opts != nil && (len(opts.AllowedResourceNames) > 0 || len(opts.DeniedResourceNames) > 0) {
		nameToURI := map[string]string{
			"documents":            "doc://list",
			"system_info":          "system://info",
			"conversation_history": "conversation://history",
		}
		seen := map[string]struct{}{}
		for _, n := range opts.AllowedResourceNames {
			if u, ok := nameToURI[n]; ok {
				if _, dup := seen["allow:"+u]; !dup {
					opts.AllowedResourceURIs = append(opts.AllowedResourceURIs, u)
					seen["allow:"+u] = struct{}{}
				}
			}
		}
		for _, n := range opts.DeniedResourceNames {
			if u, ok := nameToURI[n]; ok {
				if _, dup := seen["deny:"+u]; !dup {
					opts.DeniedResourceURIs = append(opts.DeniedResourceURIs, u)
					seen["deny:"+u] = struct{}{}
				}
			}
		}
	}
	// Broadcaster
	var bc Broadcaster
	if opts != nil && opts.Broadcaster != nil {
		bc = opts.Broadcaster
	} else {
		buf := 32
		drop := true
		if opts != nil {
			if opts.BroadcastBuffer > 0 {
				buf = opts.BroadcastBuffer
			}
			if opts.DropIfSlow == false {
				drop = false
			}
		}
		bc = newChannelBroadcaster(buf, drop)
	}
	// Build name->URI map from generated resources
	nameToURI := map[string]string{
		"documents":            "doc://list",
		"system_info":          "system://info",
		"conversation_history": "conversation://history",
	}
	return &MCPAdapter{
		service:           service,
		opts:              opts,
		promptProvider:    promptProvider,
		subs:              make(map[string]int),
		broadcaster:       bc,
		resourceNameToURI: nameToURI,
	}
}

func (a *MCPAdapter) isInitialized() bool {
	a.mu.RLock()
	ok := a.initialized
	a.mu.RUnlock()
	return ok
}

func (a *MCPAdapter) log(ctx context.Context, event string, details any) {
	if a != nil && a.opts != nil && a.opts.Logger != nil {
		a.opts.Logger(ctx, event, details)
	}
}

func (a *MCPAdapter) mapError(err error) error {
	if a != nil && a.opts != nil && a.opts.ErrorMapper != nil && err != nil {
		if m := a.opts.ErrorMapper(err); m != nil {
			return m
		}
	}
	return err
}

func stringPtr(s string) *string { return &s }

func isLikelyJSON(s string) bool { return json.Valid([]byte(s)) }

// buildContentItem returns a ContentItem honoring StructuredStreamJSON option.
func buildContentItem(a *MCPAdapter, s string) *ContentItem {
	if a != nil && a.opts != nil && a.opts.StructuredStreamJSON && isLikelyJSON(s) {
		mt := stringPtr("application/json")
		return &ContentItem{Type: "text", MimeType: mt, Text: &s}
	}
	return &ContentItem{Type: "text", Text: &s}
}

// Initialize handles the MCP initialize request.
func (a *MCPAdapter) Initialize(ctx context.Context, p *InitializePayload) (*InitializeResult, error) {
	if p == nil || p.ProtocolVersion == "" {
		return nil, goa.PermanentError("invalid_params", "Missing protocolVersion")
	}
	switch p.ProtocolVersion {
	case a.mcpProtocolVersion():
	default:
		return nil, goa.PermanentError("invalid_params", "Unsupported protocol version")
	}

	a.mu.Lock()
	if a.initialized {
		a.mu.Unlock()
		return nil, goa.PermanentError("invalid_params", "Already initialized")
	}
	a.initialized = true
	a.mu.Unlock()

	serverInfo := &ServerInfo{
		Name:    "assistant-mcp",
		Version: "1.0.0",
	}

	capabilities := &ServerCapabilities{}
	capabilities.Tools = &ToolsCapability{}
	capabilities.Resources = &ResourcesCapability{}
	capabilities.Prompts = &PromptsCapability{}

	return &InitializeResult{
		ProtocolVersion: a.mcpProtocolVersion(),
		ServerInfo:      serverInfo,
		Capabilities:    capabilities,
	}, nil
}

// Ping handles the MCP ping request.
func (a *MCPAdapter) Ping(ctx context.Context) (*PingResult, error) {
	a.log(ctx, "request", map[string]any{"method": "ping"})
	res := &PingResult{Pong: true}
	a.log(ctx, "response", map[string]any{"method": "ping"})
	return res, nil
}

// Broadcaster and publish helpers for server-initiated events

// Broadcaster defines a simple publish/subscribe API for server-initiated events.
type Broadcaster interface {
	Subscribe(ctx context.Context) (Subscription, error)
	Publish(ev *EventsStreamResult)
	Close() error
}

// Subscription represents a subscriber to broadcast events.
type Subscription interface {
	C() <-chan *EventsStreamResult
	Close() error
}

// channelBroadcaster is a default in-memory broadcaster.
type channelBroadcaster struct {
	mu     sync.RWMutex
	subs   map[chan *EventsStreamResult]struct{}
	buf    int
	drop   bool
	closed bool
}

func newChannelBroadcaster(buf int, drop bool) *channelBroadcaster {
	return &channelBroadcaster{subs: make(map[chan *EventsStreamResult]struct{}), buf: buf, drop: drop}
}

func (b *channelBroadcaster) Subscribe(ctx context.Context) (Subscription, error) {
	ch := make(chan *EventsStreamResult, b.buf)
	b.mu.Lock()
	if b.closed {
		b.mu.Unlock()
		close(ch)
		return &subscription{ch: ch, parent: b}, nil
	}
	b.subs[ch] = struct{}{}
	b.mu.Unlock()
	return &subscription{ch: ch, parent: b}, nil
}

func (b *channelBroadcaster) Publish(ev *EventsStreamResult) {
	if ev == nil {
		return
	}
	b.mu.RLock()
	for ch := range b.subs {
		if b.drop {
			select {
			case ch <- ev:
			default:
			}
		} else {
			ch <- ev
		}
	}
	b.mu.RUnlock()
}

func (b *channelBroadcaster) Close() error {
	b.mu.Lock()
	if b.closed {
		b.mu.Unlock()
		return nil
	}
	b.closed = true
	for ch := range b.subs {
		close(ch)
		delete(b.subs, ch)
	}
	b.mu.Unlock()
	return nil
}

type subscription struct {
	ch     chan *EventsStreamResult
	parent *channelBroadcaster
	once   sync.Once
}

func (s *subscription) C() <-chan *EventsStreamResult { return s.ch }

func (s *subscription) Close() error {
	s.once.Do(func() {
		if s.parent != nil {
			s.parent.mu.Lock()
			delete(s.parent.subs, s.ch)
			s.parent.mu.Unlock()
		}
		close(s.ch)
	})
	return nil
}

// Publish sends an event to all event stream subscribers.
func (a *MCPAdapter) Publish(ev *EventsStreamResult) {
	if a == nil || a.broadcaster == nil {
		return
	}
	a.broadcaster.Publish(ev)
}

// PublishStatus is a convenience to publish a status_update message.
func (a *MCPAdapter) PublishStatus(ctx context.Context, typ string, message string, data any) {
	m := map[string]any{"type": typ, "message": message}
	if data != nil {
		m["data"] = data
	}
	s, err := encodeJSONToString(ctx, m)
	if err != nil {
		return
	}
	a.Publish(&EventsStreamResult{
		Content: []*ContentItem{buildContentItem(a, s)},
	})
}

// Tools handling

func (a *MCPAdapter) ToolsList(ctx context.Context, p *ToolsListPayload) (*ToolsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "tools/list"})
	tools := []*ToolInfo{
		{
			Name:        "analyze_text",
			Description: stringPtr("Analyze text with various modes"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"mode":{"enum":["sentiment","keywords","summary"],"type":"string"},"text":{"maxLength":10000,"minLength":1,"type":"string"}},"required":["text","mode"],"type":"object"}`),
		},
		{
			Name:        "search",
			Description: stringPtr("Search the knowledge base"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"limit":{"maximum":100,"minimum":1,"type":"integer"},"query":{"maxLength":256,"minLength":1,"type":"string"}},"required":["query"],"type":"object"}`),
		},
		{
			Name:        "execute_code",
			Description: stringPtr("Execute code safely in sandbox"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"code":{"maxLength":20000,"minLength":1,"type":"string"},"language":{"enum":["python","javascript","go"],"type":"string"}},"required":["language","code"],"type":"object"}`),
		},
		{
			Name:        "process_batch",
			Description: stringPtr("Process items with progress updates"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"blob":{"contentEncoding":"base64","type":"string"},"format":{"enum":["text","blob","uri"],"type":"string"},"items":{"items":{"type":"string"},"minItems":1,"type":"array"},"mimeType":{"type":"string"},"uri":{"type":"string"}},"required":["items"],"type":"object"}`),
		},
	}
	res := &ToolsListResult{Tools: tools}
	a.log(ctx, "response", map[string]any{"method": "tools/list"})
	return res, nil
}

type ProcessBatchStreamBridge struct {
	out     ToolsCallServerStream
	adapter *MCPAdapter
}

func (b *ProcessBatchStreamBridge) Send(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	s, e := encodeJSONToString(ctx, ev)
	if e != nil {
		return e
	}
	return b.out.Send(ctx, &ToolsCallResult{Content: []*ContentItem{buildContentItem(b.adapter, s)}})
}
func (b *ProcessBatchStreamBridge) SendAndClose(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	s, e := encodeJSONToString(ctx, ev)
	if e != nil {
		return e
	}
	return b.out.SendAndClose(ctx, &ToolsCallResult{Content: []*ContentItem{buildContentItem(b.adapter, s)}})
}
func (b *ProcessBatchStreamBridge) SendError(ctx context.Context, id string, err error) error {
	return b.out.SendError(ctx, id, err)
}

func (a *MCPAdapter) ToolsCall(ctx context.Context, p *ToolsCallPayload, stream ToolsCallServerStream) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "tools/call", "name": p.Name})
	switch p.Name {
	case "analyze_text":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.AnalyzeTextPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Text == "" {
				return goa.PermanentError("invalid_params", "Missing required field: text")
			}
			if payload.Mode == "" {
				return goa.PermanentError("invalid_params", "Missing required field: mode")
			}
		}
		{
			{
				var __val string
				__val = payload.Mode
				ok := false
				switch __val {
				case "sentiment":
					ok = true
				case "keywords":
					ok = true
				case "summary":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for mode")
				}
			}
		}
		result, err := a.service.AnalyzeText(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{Content: []*ContentItem{buildContentItem(a, s)}}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "search":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.SearchKnowledgePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Query == "" {
				return goa.PermanentError("invalid_params", "Missing required field: query")
			}
		}
		result, err := a.service.SearchKnowledge(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{Content: []*ContentItem{buildContentItem(a, s)}}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "execute_code":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ExecuteCodePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Language == "" {
				return goa.PermanentError("invalid_params", "Missing required field: language")
			}
			if payload.Code == "" {
				return goa.PermanentError("invalid_params", "Missing required field: code")
			}
		}
		{
			{
				var __val string
				__val = payload.Language
				ok := false
				switch __val {
				case "python":
					ok = true
				case "javascript":
					ok = true
				case "go":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for language")
				}
			}
		}
		result, err := a.service.ExecuteCode(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{Content: []*ContentItem{buildContentItem(a, s)}}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "process_batch":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ProcessBatchPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			{
				var __val string
				if payload.Format != nil {
					__val = *payload.Format
				}
				ok := false
				switch __val {
				case "text":
					ok = true
				case "blob":
					ok = true
				case "uri":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for format")
				}
			}
		}
		bridge := &ProcessBatchStreamBridge{out: stream, adapter: a}
		if err := a.service.ProcessBatch(ctx, payload, bridge); err != nil {
			return a.mapError(err)
		}
		return nil
	default:
		return goa.PermanentError("method_not_found", "Unknown tool: %s", p.Name)
	}
}

// Resources handling

func (a *MCPAdapter) ResourcesList(ctx context.Context, p *ResourcesListPayload) (*ResourcesListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "resources/list"})
	resources := []*ResourceInfo{
		{URI: "doc://list", Name: stringPtr("documents"), Description: stringPtr("List available documents"), MimeType: stringPtr("application/json")},
		{URI: "system://info", Name: stringPtr("system_info"), Description: stringPtr("Get system information and status"), MimeType: stringPtr("application/json")},
		{URI: "conversation://history", Name: stringPtr("conversation_history"), Description: stringPtr("Get conversation history with optional filtering"), MimeType: stringPtr("application/json")},
	}
	res := &ResourcesListResult{Resources: resources}
	a.log(ctx, "response", map[string]any{"method": "resources/list"})
	return res, nil
}

func (a *MCPAdapter) ResourcesRead(ctx context.Context, p *ResourcesReadPayload) (*ResourcesReadResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if err := a.assertResourceURIAllowed(ctx, p.URI); err != nil {
		return nil, goa.PermanentError("invalid_params", "%s", err.Error())
	}
	a.log(ctx, "request", map[string]any{"method": "resources/read", "uri": p.URI})
	baseURI := p.URI
	if i := strings.Index(baseURI, "?"); i >= 0 {
		baseURI = baseURI[:i]
	}
	switch baseURI {
	case "doc://list":
		result, err := a.service.ListDocuments(ctx)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	case "system://info":
		result, err := a.service.GetSystemInfo(ctx)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	case "conversation://history":
		args, aerr := parseQueryParamsToJSON(p.URI)
		if aerr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", aerr.Error())
		}
		req := &http.Request{Body: io.NopCloser(bytes.NewReader(args)), Header: http.Header{"Content-Type": []string{"application/json"}}}
		var payload *assistant.GetConversationHistoryPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return nil, goa.PermanentError("invalid_params", "%s", err.Error())
		}
		result, err := a.service.GetConversationHistory(ctx, payload)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	default:
		return nil, goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

// assertResourceURIAllowed verifies pURI passes allow/deny filters when configured.
func (a *MCPAdapter) assertResourceURIAllowed(ctx context.Context, pURI string) error {
	base := pURI
	if i := strings.Index(base, "?"); i >= 0 {
		base = base[:i]
	}
	// Merge header-driven allow/deny lists from context (CSV of names)
	var extraAllowURIs, extraDenyURIs []string
	if ctx != nil {
		if v := ctx.Value("mcp_allow_names"); v != nil {
			if s, ok := v.(string); ok {
				for _, n := range strings.Split(s, ",") {
					n = strings.TrimSpace(n)
					if u, ok2 := a.resourceNameToURI[n]; ok2 {
						extraAllowURIs = append(extraAllowURIs, u)
					}
				}
			}
		}
		if v := ctx.Value("mcp_deny_names"); v != nil {
			if s, ok := v.(string); ok {
				for _, n := range strings.Split(s, ",") {
					n = strings.TrimSpace(n)
					if u, ok2 := a.resourceNameToURI[n]; ok2 {
						extraDenyURIs = append(extraDenyURIs, u)
					}
				}
			}
		}
	}
	for _, allow := range extraAllowURIs {
		if allow == base {
			return nil
		}
	}
	for _, d := range append(a.opts.DeniedResourceURIs, extraDenyURIs...) {
		if d == base {
			return fmt.Errorf("resource URI denied: %s", pURI)
		}
	}
	if len(a.opts.AllowedResourceURIs) == 0 && len(extraAllowURIs) == 0 {
		return nil
	}
	for _, allow := range append(a.opts.AllowedResourceURIs, extraAllowURIs...) {
		if allow == base {
			return nil
		}
	}
	return fmt.Errorf("resource URI not allowed: %s", pURI)
}

func (a *MCPAdapter) ResourcesSubscribe(ctx context.Context, p *ResourcesSubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	switch p.URI {
	default:
		return goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

func (a *MCPAdapter) ResourcesUnsubscribe(ctx context.Context, p *ResourcesUnsubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	switch p.URI {
	default:
		return goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

// Prompts handling

func (a *MCPAdapter) PromptsList(ctx context.Context, p *PromptsListPayload) (*PromptsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "prompts/list"})
	prompts := []*PromptInfo{

		{Name: "contextual_prompts", Description: stringPtr("Generate prompts based on context"), Arguments: []*PromptArgument{

			{Name: "context", Description: stringPtr("Current context"), Required: true},

			{Name: "task", Description: stringPtr("Task type"), Required: true},
		}},

		{Name: "code_review", Description: stringPtr("Template for code review")},
	}
	res := &PromptsListResult{Prompts: prompts}
	a.log(ctx, "response", map[string]any{"method": "prompts/list"})
	return res, nil
}

func (a *MCPAdapter) PromptsGet(ctx context.Context, p *PromptsGetPayload) (*PromptsGetResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if p == nil || p.Name == "" {
		return nil, goa.PermanentError("invalid_params", "Missing prompt name")
	}
	a.log(ctx, "request", map[string]any{"method": "prompts/get", "name": p.Name})
	switch p.Name {

	case "code_review":
		if a.promptProvider != nil {
			if res, err := a.promptProvider.GetCodeReviewPrompt(p.Arguments); err == nil && res != nil {
				a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
				return res, nil
			} else if err != nil {
				return nil, err
			}
		}
		msgs := make([]*PromptMessage, 0, 3)

		msgs = append(msgs, &PromptMessage{
			Role: "system",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("You are an expert code reviewer."),
			},
		})

		msgs = append(msgs, &PromptMessage{
			Role: "user",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("Please review this code: {{.code}}"),
			},
		})

		msgs = append(msgs, &PromptMessage{
			Role: "assistant",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("I'll analyze the code for quality, bugs, and improvements."),
			},
		})

		res := &PromptsGetResult{
			Description: stringPtr("Template for code review"),
			Messages:    msgs,
		}
		a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
		return res, nil

	}

	switch p.Name {

	case "contextual_prompts":
		{

			var args map[string]any
			if len(p.Arguments) > 0 {
				if err := json.Unmarshal(p.Arguments, &args); err != nil {
					return nil, goa.PermanentError("invalid_params", "%s", err.Error())
				}
			}

			if _, ok := args["context"]; !ok {
				return nil, goa.PermanentError("invalid_params", "Missing required argument: context")
			}

			if _, ok := args["task"]; !ok {
				return nil, goa.PermanentError("invalid_params", "Missing required argument: task")
			}

		}
		if a.promptProvider == nil {
			return nil, goa.PermanentError("invalid_params", "No prompt provider configured for dynamic prompts")
		}
		res, err := a.promptProvider.GetContextualPromptsPrompt(ctx, p.Arguments)
		if err != nil {
			return nil, a.mapError(err)
		}
		a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
		return res, nil

	}

	return nil, goa.PermanentError("method_not_found", "Unknown prompt: %s", p.Name)
}

// Notifications and events stream

func (a *MCPAdapter) NotifyStatusUpdate(ctx context.Context, p *SendNotificationPayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	if p == nil || p.Type == "" {
		return goa.PermanentError("invalid_params", "Missing notification type")
	}
	m := map[string]any{"type": p.Type}
	if p.Message != nil {
		m["message"] = *p.Message
	}
	if p.Data != nil {
		m["data"] = p.Data
	}
	s, err := encodeJSONToString(ctx, m)
	if err != nil {
		return err
	}
	ev := &EventsStreamResult{
		Content: []*ContentItem{buildContentItem(a, s)},
	}
	a.Publish(ev)
	return nil
}

func (a *MCPAdapter) EventsStream(ctx context.Context, stream EventsStreamServerStream) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	if a.broadcaster == nil {
		return goa.PermanentError("invalid_params", "No broadcaster configured")
	}
	sub, _ := a.broadcaster.Subscribe(ctx)
	defer sub.Close()
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case ev, ok := <-sub.C():
			if !ok {
				return nil
			}
			if err := stream.Send(ctx, ev); err != nil {
				return err
			}
		}
	}
}

// General subscriptions handling

func (a *MCPAdapter) Subscribe(ctx context.Context, p *SubscribePayload) (*SubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "subscribe"})
	res := &SubscribeResult{Success: true}
	a.log(ctx, "response", map[string]any{"method": "subscribe"})
	return res, nil
}

func (a *MCPAdapter) Unsubscribe(ctx context.Context, p *UnsubscribePayload) (*UnsubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "unsubscribe"})
	res := &UnsubscribeResult{Success: true}
	a.log(ctx, "response", map[string]any{"method": "unsubscribe"})
	return res, nil
}
