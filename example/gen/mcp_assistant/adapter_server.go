// Code generated by goa v3.22.2, DO NOT EDIT.
//
// MCP server adapter for assistant service
//
// Command:
// $ goa gen example.com/assistant/design

package mcpassistant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"

	assistant "example.com/assistant/gen/assistant"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// MCPAdapter handles MCP protocol requests and adapts them to the original
// service
// Required imports:
// - bytes, context, encoding/json, io, net/http, sync
// - goahttp, jsonrpc, goa and original service packages are included via header
type MCPAdapter struct {
	service        assistant.Service
	mux            goahttp.Muxer
	initialized    bool
	mu             sync.RWMutex
	opts           *MCPAdapterOptions
	promptProvider PromptProvider
}

// MCPAdapterOptions allows customizing adapter behavior.
type MCPAdapterOptions struct {
	// Logger is an optional hook called with internal adapter events.
	// event examples: "request", "response", "error"; details is implementation-defined.
	Logger func(ctx context.Context, event string, details any)
	// ErrorMapper allows mapping arbitrary errors to framework-friendly errors
	// (e.g., goa.PermanentError with specific JSON-RPC codes).
	ErrorMapper func(error) error
	// Allowed/Deny lists for resource URIs. If AllowedResourceURIs is non-empty,
	// only URIs in that list are permitted. DeniedResourceURIs takes precedence.
	AllowedResourceURIs     []string
	DeniedResourceURIs      []string
	StructuredStreamJSON    bool
	ProtocolVersionOverride string
}

// mcpProtocolVersion resolves the protocol version from options or default.
func (a *MCPAdapter) mcpProtocolVersion() string {
	if a != nil && a.opts != nil && a.opts.ProtocolVersionOverride != "" {
		return a.opts.ProtocolVersionOverride
	}
	return DefaultProtocolVersion
}

// bufferResponseWriter is a minimal http.ResponseWriter that writes to an in-memory buffer
// used to leverage goa encoders without an actual HTTP response.
type bufferResponseWriter struct {
	headers http.Header
	buf     bytes.Buffer
}

func (w *bufferResponseWriter) Header() http.Header {
	if w.headers == nil {
		w.headers = make(http.Header)
	}
	return w.headers
}
func (w *bufferResponseWriter) WriteHeader(statusCode int)  {}
func (w *bufferResponseWriter) Write(p []byte) (int, error) { return w.buf.Write(p) }

func encodeJSONToString(ctx context.Context, v any) (string, error) {
	bw := &bufferResponseWriter{}
	if err := goahttp.ResponseEncoder(ctx, bw).Encode(v); err != nil {
		return "", err
	}
	return bw.buf.String(), nil
}

// parseQueryParamsToJSON parses the query parameters of a URI into a JSON
// object where keys are parameter names and values are best-effort typed.
// Repeated parameters become arrays. Numbers and booleans are detected.
func parseQueryParamsToJSON(uri string) ([]byte, error) {
	u, err := url.Parse(uri)
	if err != nil {
		return nil, fmt.Errorf("invalid resource URI: %w", err)
	}
	q := u.Query()
	if len(q) == 0 {
		return []byte("{}"), nil
	}
	m := make(map[string]any, len(q))
	for k, vals := range q {
		if len(vals) == 1 {
			m[k] = coerce(vals[0])
			continue
		}
		arr := make([]any, len(vals))
		for i := range vals {
			arr[i] = coerce(vals[i])
		}
		m[k] = arr
	}
	return json.Marshal(m)
}

// coerce tries to interpret s as bool, int, float, else returns s.
func coerce(s string) any {
	ls := strings.ToLower(s)
	switch ls {
	case "true", "t", "1":
		return true
	case "false", "f", "0":
		return false
	}
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	return s
}

// NewMCPAdapter creates a new MCP adapter that wraps the original service
func NewMCPAdapter(service assistant.Service, promptProvider PromptProvider, opts *MCPAdapterOptions) *MCPAdapter {
	return &MCPAdapter{
		service:        service,
		mux:            goahttp.NewMuxer(),
		opts:           opts,
		promptProvider: promptProvider,
	}
}

// Initialize handles the MCP initialize request
func (a *MCPAdapter) Initialize(ctx context.Context, p *InitializePayload) (*InitializeResult, error) {
	if p == nil || p.ProtocolVersion == "" {
		return nil, goa.PermanentError("invalid_params", "Missing protocolVersion")
	}
	switch p.ProtocolVersion {
	case a.mcpProtocolVersion():
	default:
		return nil, goa.PermanentError("invalid_params", "Unsupported protocol version")
	}
	a.mu.Lock()
	if a.initialized {
		a.mu.Unlock()
		return nil, goa.PermanentError("invalid_params", "Already initialized")
	}
	a.initialized = true
	a.mu.Unlock()
	// Build server info
	serverInfo := &ServerInfo{
		Name:    "assistant-mcp",
		Version: "1.0.0",
	}
	// Build capabilities
	capabilities := &ServerCapabilities{}
	capabilities.Tools = &ToolsCapability{}
	capabilities.Resources = &ResourcesCapability{}
	capabilities.Prompts = &PromptsCapability{}
	return &InitializeResult{
		ProtocolVersion: a.mcpProtocolVersion(),
		ServerInfo:      serverInfo,
		Capabilities:    capabilities,
	}, nil
}

func (a *MCPAdapter) isInitialized() bool {
	a.mu.RLock()
	ok := a.initialized
	a.mu.RUnlock()
	return ok
}

// Ping handles the MCP ping request
func (a *MCPAdapter) Ping(ctx context.Context) (*PingResult, error) {
	return &PingResult{Pong: true}, nil
}

// ToolsList returns the list of available tools
func (a *MCPAdapter) ToolsList(ctx context.Context, p *ToolsListPayload) (*ToolsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	tools := []*ToolInfo{
		{
			Name:        "analyze_text",
			Description: stringPtr("Analyze text with various modes"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"mode":{"enum":["sentiment","keywords","summary"],"type":"string"},"text":{"type":"string"}},"required":["text","mode"],"type":"object"}`),
		},
		{
			Name:        "search",
			Description: stringPtr("Search the knowledge base"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"limit":{"type":"integer"},"query":{"type":"string"}},"required":["query"],"type":"object"}`),
		},
		{
			Name:        "execute_code",
			Description: stringPtr("Execute code safely in sandbox"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"code":{"type":"string"},"language":{"type":"string"}},"required":["language","code"],"type":"object"}`),
		},
		{
			Name:        "process_batch",
			Description: stringPtr("Process items with progress updates"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"blob":{"contentEncoding":"base64","type":"string"},"format":{"enum":["text","blob","uri"],"type":"string"},"items":{"items":{"type":"string"},"type":"array"},"mimeType":{"type":"string"},"uri":{"type":"string"}},"required":["items"],"type":"object"}`),
		},
	}
	return &ToolsListResult{Tools: tools}, nil
}

// Stream bridges from original server-streaming methods to MCP ToolsCall stream
type ProcessBatchStreamBridge struct {
	out     ToolsCallServerStream
	sent    bool
	mu      sync.Mutex
	adapter *MCPAdapter
}

func (b *ProcessBatchStreamBridge) Send(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	b.mu.Lock()
	b.sent = true
	b.mu.Unlock()
	s, serr := encodeJSONToString(ctx, ev)
	if serr != nil {
		return serr
	}
	return b.out.Send(ctx, &ToolsCallResult{Content: []*ContentItem{buildContentItem(b.adapter, s)}})
}
func (b *ProcessBatchStreamBridge) SendAndClose(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	b.mu.Lock()
	b.sent = true
	b.mu.Unlock()
	s, serr := encodeJSONToString(ctx, ev)
	if serr != nil {
		return serr
	}
	return b.out.SendAndClose(ctx, &ToolsCallResult{Content: []*ContentItem{buildContentItem(b.adapter, s)}})
}
func (b *ProcessBatchStreamBridge) SendError(ctx context.Context, id string, err error) error {
	return b.out.SendError(ctx, id, err)
}

// ToolsCall executes a tool and streams progress and final result when
// requested via SSE
func (a *MCPAdapter) ToolsCall(ctx context.Context, p *ToolsCallPayload, stream ToolsCallServerStream) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	switch p.Name {
	case "analyze_text":
		// Decode arguments into original payload using goa HTTP decoder
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.AnalyzeTextPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Text == "" {
				return goa.PermanentError("invalid_params", "Missing required field: text")
			}
			if payload.Mode == "" {
				return goa.PermanentError("invalid_params", "Missing required field: mode")
			}
		}
		{
			{
				var __val string
				__val = payload.Mode
				ok := false
				switch __val {
				case "sentiment":
					ok = true
				case "keywords":
					ok = true
				case "summary":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for mode")
				}
			}
		}
		result, err := a.service.AnalyzeText(ctx, payload)
		if err != nil {
			return err
		}
		// Encode result to JSON string using goa encoder
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		// Emit final response and close stream
		final := &ToolsCallResult{Content: []*ContentItem{&ContentItem{Type: "text", Text: &s}}}
		return stream.SendAndClose(ctx, final)
	case "search":
		// Decode arguments into original payload using goa HTTP decoder
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.SearchKnowledgePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Query == "" {
				return goa.PermanentError("invalid_params", "Missing required field: query")
			}
		}
		result, err := a.service.SearchKnowledge(ctx, payload)
		if err != nil {
			return err
		}
		// Encode result to JSON string using goa encoder
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		// Emit final response and close stream
		final := &ToolsCallResult{Content: []*ContentItem{&ContentItem{Type: "text", Text: &s}}}
		return stream.SendAndClose(ctx, final)
	case "execute_code":
		// Decode arguments into original payload using goa HTTP decoder
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ExecuteCodePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Language == "" {
				return goa.PermanentError("invalid_params", "Missing required field: language")
			}
			if payload.Code == "" {
				return goa.PermanentError("invalid_params", "Missing required field: code")
			}
		}
		result, err := a.service.ExecuteCode(ctx, payload)
		if err != nil {
			return err
		}
		// Encode result to JSON string using goa encoder
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return serr
		}
		// Emit final response and close stream
		final := &ToolsCallResult{Content: []*ContentItem{&ContentItem{Type: "text", Text: &s}}}
		return stream.SendAndClose(ctx, final)
	case "process_batch":
		// Decode arguments into original payload using goa HTTP decoder
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ProcessBatchPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		// Enum fields check (top-level)
		{
			{
				var __val string
				if payload.Format != nil {
					__val = *payload.Format
				}
				ok := false
				switch __val {
				case "text":
					ok = true
				case "blob":
					ok = true
				case "uri":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for format")
				}
			}
		}
		// Bridge original server stream interface to MCP ToolsCall stream
		bridge := &ProcessBatchStreamBridge{out: stream, adapter: a}
		if err := a.service.ProcessBatch(ctx, payload, bridge); err != nil {
			return err
		}
		return nil
	default:
		return goa.PermanentError("method_not_found", "Unknown tool: %s", p.Name)
	}
}

// ResourcesList returns the list of available resources
func (a *MCPAdapter) ResourcesList(ctx context.Context, p *ResourcesListPayload) (*ResourcesListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	resources := []*ResourceInfo{
		{
			URI:         "doc://list",
			Name:        stringPtr("documents"),
			Description: stringPtr("List available documents"),
			MimeType:    stringPtr("application/json"),
		},
		{
			URI:         "system://info",
			Name:        stringPtr("system_info"),
			Description: stringPtr("Get system information and status"),
			MimeType:    stringPtr("application/json"),
		},
		{
			URI:         "conversation://history",
			Name:        stringPtr("conversation"),
			Description: stringPtr("Get conversation history"),
			MimeType:    stringPtr("application/json"),
		},
	}
	return &ResourcesListResult{Resources: resources}, nil
}

// ResourcesRead reads a resource and returns its content
func (a *MCPAdapter) ResourcesRead(ctx context.Context, p *ResourcesReadPayload) (*ResourcesReadResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if err := a.assertResourceURIAllowed(p.URI); err != nil {
		return nil, goa.PermanentError("invalid_params", "%s", err.Error())
	}
	baseURI := p.URI
	if i := strings.Index(baseURI, "?"); i >= 0 {
		baseURI = baseURI[:i]
	}
	switch baseURI {
	case "doc://list":
		result, err := a.service.ListDocuments(ctx)
		if err != nil {
			return nil, err
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		return &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}, nil
	case "system://info":
		result, err := a.service.GetSystemInfo(ctx)
		if err != nil {
			return nil, err
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		return &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}, nil
	case "conversation://history":
		// Map URI query parameters to original payload and decode
		args, aerr := parseQueryParamsToJSON(p.URI)
		if aerr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", aerr.Error())
		}
		req := &http.Request{Body: io.NopCloser(bytes.NewReader(args)), Header: http.Header{"Content-Type": []string{"application/json"}}}
		var payload *assistant.GetConversationHistoryPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return nil, goa.PermanentError("invalid_params", "%s", err.Error())
		}
		result, err := a.service.GetConversationHistory(ctx, payload)
		if err != nil {
			return nil, err
		}
		s, serr := encodeJSONToString(ctx, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		return &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}, nil
	default:
		return nil, goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

// assertResourceURIAllowed verifies pURI passes allow/deny filters when configured.
func (a *MCPAdapter) assertResourceURIAllowed(pURI string) error {
	if a == nil || a.opts == nil {
		return nil
	}
	// Deny list takes precedence
	for _, d := range a.opts.DeniedResourceURIs {
		if d == pURI {
			return fmt.Errorf("resource URI denied: %s", pURI)
		}
	}
	if len(a.opts.AllowedResourceURIs) == 0 {
		return nil
	}
	for _, allow := range a.opts.AllowedResourceURIs {
		if allow == pURI {
			return nil
		}
	}
	return fmt.Errorf("resource URI not allowed: %s", pURI)
}

// ResourcesSubscribe subscribes to resource changes
func (a *MCPAdapter) ResourcesSubscribe(ctx context.Context, p *ResourcesSubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	return nil
}

// ResourcesUnsubscribe unsubscribes from resource changes
func (a *MCPAdapter) ResourcesUnsubscribe(ctx context.Context, p *ResourcesUnsubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	return nil
}

// PromptsList returns the list of available prompts
func (a *MCPAdapter) PromptsList(ctx context.Context, p *PromptsListPayload) (*PromptsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	prompts := []*PromptInfo{
		{
			Name:        "contextual_prompts",
			Description: stringPtr("Generate prompts based on context"),
			Arguments: []*PromptArgument{
				{Name: "context", Description: stringPtr("Current context"), Required: true},
				{Name: "task", Description: stringPtr("Task type"), Required: true},
			},
		},
		{
			Name:        "code_review",
			Description: stringPtr("Template for code review"),
			// No explicit arguments for static prompts
		},
		{
			Name:        "explain_concept",
			Description: stringPtr("Template for explaining concepts"),
			// No explicit arguments for static prompts
		},
	}
	return &PromptsListResult{Prompts: prompts}, nil
}

// PromptsGet resolves static prompts directly and delegates dynamic prompts to
// the provider
func (a *MCPAdapter) PromptsGet(ctx context.Context, p *PromptsGetPayload) (*PromptsGetResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if p == nil || p.Name == "" {
		return nil, goa.PermanentError("invalid_params", "Missing prompt name")
	}

	// Static prompts handled inline with optional provider override
	switch p.Name {
	case "code_review":
		if a.promptProvider != nil {
			if res, err := a.promptProvider.GetCodeReviewPrompt(p.Arguments); err == nil && res != nil {
				return res, nil
			} else if err != nil {
				return nil, err
			}
		}
		// Fallback to generated static prompt content
		msgs := make([]*PromptMessage, 0, 3)
		msgs = append(msgs, &PromptMessage{Role: "system", Content: &MessageContent{Type: "text", Text: stringPtr("You are an expert code reviewer.")}})
		msgs = append(msgs, &PromptMessage{Role: "user", Content: &MessageContent{Type: "text", Text: stringPtr("Please review this code: {{.code}}")}})
		msgs = append(msgs, &PromptMessage{Role: "assistant", Content: &MessageContent{Type: "text", Text: stringPtr("I'll analyze the code for quality, bugs, and improvements.")}})
		return &PromptsGetResult{Description: stringPtr("Template for code review"), Messages: msgs}, nil
	case "explain_concept":
		if a.promptProvider != nil {
			if res, err := a.promptProvider.GetExplainConceptPrompt(p.Arguments); err == nil && res != nil {
				return res, nil
			} else if err != nil {
				return nil, err
			}
		}
		// Fallback to generated static prompt content
		msgs := make([]*PromptMessage, 0, 2)
		msgs = append(msgs, &PromptMessage{Role: "system", Content: &MessageContent{Type: "text", Text: stringPtr("You are a helpful teacher.")}})
		msgs = append(msgs, &PromptMessage{Role: "user", Content: &MessageContent{Type: "text", Text: stringPtr("Explain {{.concept}} in simple terms.")}})
		return &PromptsGetResult{Description: stringPtr("Template for explaining concepts"), Messages: msgs}, nil
	}

	// Dynamic prompts require a provider implementation
	if a.promptProvider == nil {
		return nil, goa.PermanentError("invalid_params", "No prompt provider configured for dynamic prompts")
	}
	switch p.Name {
	case "contextual_prompts":
		return a.promptProvider.GetContextualPromptsPrompt(ctx, p.Arguments)
	}

	return nil, goa.PermanentError("method_not_found", "Unknown prompt: %s", p.Name)
}

// NotifyStatusUpdate handles notifications with no response
func (a *MCPAdapter) NotifyStatusUpdate(ctx context.Context, p *SendNotificationPayload) error {
	return nil
}

// Subscribe returns a default success for demo purposes
func (a *MCPAdapter) Subscribe(ctx context.Context, p *SubscribePayload) (*SubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	return &SubscribeResult{Success: true}, nil
}

// Unsubscribe returns a default success for demo purposes
func (a *MCPAdapter) Unsubscribe(ctx context.Context, p *UnsubscribePayload) (*UnsubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	return &UnsubscribeResult{Success: true}, nil
}

// stringPtr returns a pointer to a string
func stringPtr(s string) *string {
	return &s
}

// buildContentItem returns a ContentItem honoring StructuredStreamJSON option.
func buildContentItem(a *MCPAdapter, s string) *ContentItem {
	if a != nil && a.opts != nil && a.opts.StructuredStreamJSON && isLikelyJSON(s) {
		mt := stringPtr("application/json")
		return &ContentItem{Type: "resource", MimeType: mt, Text: &s}
	}
	return &ContentItem{Type: "text", Text: &s}
}

func isLikelyJSON(s string) bool {
	t := strings.TrimSpace(s)
	return len(t) > 0 && (t[0] == '{' || t[0] == '[')
}

// mapError and log helpers (no-op if options are nil)
func (a *MCPAdapter) mapError(err error) error {
	if a != nil && a.opts != nil && a.opts.ErrorMapper != nil && err != nil {
		if m := a.opts.ErrorMapper(err); m != nil {
			return m
		}
	}
	return err
}

func (a *MCPAdapter) log(ctx context.Context, event string, details any) {
	if a != nil && a.opts != nil && a.opts.Logger != nil {
		a.opts.Logger(ctx, event, details)
	}
}
