// Code generated by goa v3.22.6, DO NOT EDIT.
//
// MCP server adapter for assistant service
//
// Command:
// $ goa gen example.com/assistant/design

package mcpassistant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"sync"

	assistant "example.com/assistant/gen/assistant"
	mcpruntime "goa.design/goa-ai/runtime/mcp"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// MCPAdapter core: types, options, constructor, helpers

type MCPAdapter struct {
	service        assistant.Service
	initialized    bool
	mu             sync.RWMutex
	opts           *MCPAdapterOptions
	promptProvider PromptProvider
	// Minimal subscription registry keyed by resource URI
	subs   map[string]int
	subsMu sync.Mutex
	// Broadcaster for server-initiated events (notifications/resources)
	broadcaster mcpruntime.Broadcaster
	// resourceNameToURI holds DSL-derived mapping for policy and lookups
	resourceNameToURI map[string]string
}

// MCPAdapterOptions allows customizing adapter behavior.
type MCPAdapterOptions struct {
	// Logger is an optional hook called with internal adapter events.
	Logger func(ctx context.Context, event string, details any)
	// ErrorMapper allows mapping arbitrary errors to framework-friendly errors
	ErrorMapper func(error) error
	// Allowed/Deny lists for resource URIs; Denied takes precedence unless header allow overrides
	AllowedResourceURIs []string
	DeniedResourceURIs  []string
	// Name-based policy resolved to URIs at construction
	AllowedResourceNames    []string
	DeniedResourceNames     []string
	StructuredStreamJSON    bool
	ProtocolVersionOverride string
	// Pluggable broadcaster, else default channel broadcaster
	Broadcaster     mcpruntime.Broadcaster
	BroadcastBuffer int
	DropIfSlow      bool
}

func NewMCPAdapter(service assistant.Service, promptProvider PromptProvider, opts *MCPAdapterOptions) *MCPAdapter {
	// Resolve name-based policy to URIs
	if opts != nil && (len(opts.AllowedResourceNames) > 0 || len(opts.DeniedResourceNames) > 0) {
		nameToURI := map[string]string{
			"documents":            "doc://list",
			"system_info":          "system://info",
			"conversation_history": "conversation://history",
		}
		seen := map[string]struct{}{}
		for _, n := range opts.AllowedResourceNames {
			if u, ok := nameToURI[n]; ok {
				if _, dup := seen["allow:"+u]; !dup {
					opts.AllowedResourceURIs = append(opts.AllowedResourceURIs, u)
					seen["allow:"+u] = struct{}{}
				}
			}
		}
		for _, n := range opts.DeniedResourceNames {
			if u, ok := nameToURI[n]; ok {
				if _, dup := seen["deny:"+u]; !dup {
					opts.DeniedResourceURIs = append(opts.DeniedResourceURIs, u)
					seen["deny:"+u] = struct{}{}
				}
			}
		}
	}
	// Broadcaster
	var bc mcpruntime.Broadcaster
	if opts != nil && opts.Broadcaster != nil {
		bc = opts.Broadcaster
	} else {
		buf := 32
		drop := true
		if opts != nil {
			if opts.BroadcastBuffer > 0 {
				buf = opts.BroadcastBuffer
			}
			if opts.DropIfSlow == false {
				drop = false
			}
		}
		bc = mcpruntime.NewChannelBroadcaster(buf, drop)
	}
	// Build name->URI map from generated resources
	nameToURI := map[string]string{
		"documents":            "doc://list",
		"system_info":          "system://info",
		"conversation_history": "conversation://history",
	}
	return &MCPAdapter{
		service:           service,
		opts:              opts,
		promptProvider:    promptProvider,
		subs:              make(map[string]int),
		broadcaster:       bc,
		resourceNameToURI: nameToURI,
	}
}

// mcpProtocolVersion resolves the protocol version from options or default.
func (a *MCPAdapter) mcpProtocolVersion() string {
	if a != nil && a.opts != nil && a.opts.ProtocolVersionOverride != "" {
		return a.opts.ProtocolVersionOverride
	}
	return DefaultProtocolVersion
}

// parseQueryParamsToJSON converts URI query params into JSON.
func parseQueryParamsToJSON(uri string) ([]byte, error) {
	u, err := url.Parse(uri)
	if err != nil {
		return nil, fmt.Errorf("invalid resource URI: %w", err)
	}
	q := u.Query()
	if len(q) == 0 {
		return []byte("{}"), nil
	}
	// Copy to plain map[string][]string to avoid depending on url.Values in helper
	m := make(map[string][]string, len(q))
	for k, v := range q {
		m[k] = v
	}
	coerced := mcpruntime.CoerceQuery(m)
	return json.Marshal(coerced)
}

func (a *MCPAdapter) isInitialized() bool {
	a.mu.RLock()
	ok := a.initialized
	a.mu.RUnlock()
	return ok
}

func (a *MCPAdapter) log(ctx context.Context, event string, details any) {
	if a != nil && a.opts != nil && a.opts.Logger != nil {
		a.opts.Logger(ctx, event, details)
	}
}

func (a *MCPAdapter) mapError(err error) error {
	if a != nil && a.opts != nil && a.opts.ErrorMapper != nil && err != nil {
		if m := a.opts.ErrorMapper(err); m != nil {
			return m
		}
	}
	return err
}

func stringPtr(s string) *string {
	return &s
}

func isLikelyJSON(s string) bool {
	return json.Valid([]byte(s))
}

// buildContentItem returns a ContentItem honoring StructuredStreamJSON option.
func buildContentItem(a *MCPAdapter, s string) *ContentItem {
	if a != nil && a.opts != nil && a.opts.StructuredStreamJSON && isLikelyJSON(s) {
		mt := stringPtr("application/json")
		return &ContentItem{
			Type:     "text",
			MimeType: mt,
			Text:     &s,
		}
	}
	return &ContentItem{
		Type: "text",
		Text: &s,
	}
}

// Initialize handles the MCP initialize request.
func (a *MCPAdapter) Initialize(ctx context.Context, p *InitializePayload) (*InitializeResult, error) {
	if p == nil || p.ProtocolVersion == "" {
		return nil, goa.PermanentError("invalid_params", "Missing protocolVersion")
	}
	switch p.ProtocolVersion {
	case a.mcpProtocolVersion():
	default:
		return nil, goa.PermanentError("invalid_params", "Unsupported protocol version")
	}

	a.mu.Lock()
	if a.initialized {
		a.mu.Unlock()
		return nil, goa.PermanentError("invalid_params", "Already initialized")
	}
	a.initialized = true
	a.mu.Unlock()

	serverInfo := &ServerInfo{
		Name:    "assistant-mcp",
		Version: "1.0.0",
	}

	capabilities := &ServerCapabilities{}
	capabilities.Tools = &ToolsCapability{}
	capabilities.Resources = &ResourcesCapability{}
	capabilities.Prompts = &PromptsCapability{}

	return &InitializeResult{
		ProtocolVersion: a.mcpProtocolVersion(),
		ServerInfo:      serverInfo,
		Capabilities:    capabilities,
	}, nil
}

// Ping handles the MCP ping request.
func (a *MCPAdapter) Ping(ctx context.Context) (*PingResult, error) {
	a.log(ctx, "request", map[string]any{"method": "ping"})
	res := &PingResult{Pong: true}
	a.log(ctx, "response", map[string]any{"method": "ping"})
	return res, nil
}

// Broadcaster and publish helpers for server-initiated events

// Publish sends an event to all event stream subscribers.
func (a *MCPAdapter) Publish(ev *EventsStreamResult) {
	if a == nil || a.broadcaster == nil {
		return
	}
	a.broadcaster.Publish(ev)
}

// PublishStatus is a convenience to publish a status_update message.
func (a *MCPAdapter) PublishStatus(ctx context.Context, typ string, message string, data any) {
	n := &mcpruntime.Notification{Type: typ, Message: &message, Data: data}
	s, err := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, n)
	if err != nil {
		return
	}
	a.Publish(&EventsStreamResult{
		Content: []*ContentItem{buildContentItem(a, s)},
	})
}

// Tools handling

func (a *MCPAdapter) ToolsList(ctx context.Context, p *ToolsListPayload) (*ToolsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "tools/list"})
	tools := []*ToolInfo{
		{
			Name:        "analyze_sentiment",
			Description: stringPtr("Analyze text sentiment"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"text":{"maxLength":10000,"minLength":1,"type":"string"}},"required":["text"],"type":"object"}`),
		},
		{
			Name:        "extract_keywords",
			Description: stringPtr("Extract keywords from text"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"text":{"maxLength":10000,"minLength":1,"type":"string"}},"required":["text"],"type":"object"}`),
		},
		{
			Name:        "summarize_text",
			Description: stringPtr("Summarize text"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"text":{"maxLength":10000,"minLength":1,"type":"string"}},"required":["text"],"type":"object"}`),
		},
		{
			Name:        "search",
			Description: stringPtr("Search the knowledge base"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"limit":{"maximum":100,"minimum":1,"type":"integer"},"query":{"maxLength":256,"minLength":1,"type":"string"}},"required":["query"],"type":"object"}`),
		},
		{
			Name:        "execute_code",
			Description: stringPtr("Execute code safely in sandbox"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"code":{"maxLength":20000,"minLength":1,"type":"string"},"language":{"enum":["python","javascript","go"],"type":"string"}},"required":["language","code"],"type":"object"}`),
		},
		{
			Name:        "process_batch",
			Description: stringPtr("Process items with progress updates"),
			InputSchema: json.RawMessage(`{"additionalProperties":false,"properties":{"blob":{"contentEncoding":"base64","type":"string"},"format":{"enum":["text","blob","uri"],"type":"string"},"items":{"items":{"type":"string"},"minItems":1,"type":"array"},"mimeType":{"type":"string"},"uri":{"type":"string"}},"required":["items"],"type":"object"}`),
		},
	}
	res := &ToolsListResult{Tools: tools}
	a.log(ctx, "response", map[string]any{"method": "tools/list"})
	return res, nil
}

type ProcessBatchStreamBridge struct {
	out     ToolsCallServerStream
	adapter *MCPAdapter
}

func (b *ProcessBatchStreamBridge) Send(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	s, e := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, ev)
	if e != nil {
		return e
	}
	return b.out.Send(ctx, &ToolsCallResult{
		Content: []*ContentItem{
			buildContentItem(b.adapter, s),
		},
	})
}
func (b *ProcessBatchStreamBridge) SendAndClose(ctx context.Context, ev assistant.ProcessBatchEvent) error {
	s, e := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, ev)
	if e != nil {
		return e
	}
	return b.out.SendAndClose(ctx, &ToolsCallResult{
		Content: []*ContentItem{
			buildContentItem(b.adapter, s),
		},
	})
}
func (b *ProcessBatchStreamBridge) SendError(ctx context.Context, id string, err error) error {
	return b.out.SendError(ctx, id, err)
}

func (a *MCPAdapter) ToolsCall(ctx context.Context, p *ToolsCallPayload, stream ToolsCallServerStream) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "tools/call", "name": p.Name})
	switch p.Name {
	case "analyze_sentiment":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.AnalyzeSentimentPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Text == "" {
				return goa.PermanentError("invalid_params", "Missing required field: text")
			}
		}
		result, err := a.service.AnalyzeSentiment(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{
			Content: []*ContentItem{
				buildContentItem(a, s),
			},
		}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "extract_keywords":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ExtractKeywordsPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Text == "" {
				return goa.PermanentError("invalid_params", "Missing required field: text")
			}
		}
		result, err := a.service.ExtractKeywords(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{
			Content: []*ContentItem{
				buildContentItem(a, s),
			},
		}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "summarize_text":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.SummarizeTextPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Text == "" {
				return goa.PermanentError("invalid_params", "Missing required field: text")
			}
		}
		result, err := a.service.SummarizeText(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{
			Content: []*ContentItem{
				buildContentItem(a, s),
			},
		}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "search":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.SearchKnowledgePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Query == "" {
				return goa.PermanentError("invalid_params", "Missing required field: query")
			}
		}
		result, err := a.service.SearchKnowledge(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{
			Content: []*ContentItem{
				buildContentItem(a, s),
			},
		}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "execute_code":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ExecuteCodePayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			if payload.Language == "" {
				return goa.PermanentError("invalid_params", "Missing required field: language")
			}
			if payload.Code == "" {
				return goa.PermanentError("invalid_params", "Missing required field: code")
			}
		}
		{
			{
				var __val string
				__val = payload.Language
				ok := false
				switch __val {
				case "python":
					ok = true
				case "javascript":
					ok = true
				case "go":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for language")
				}
			}
		}
		result, err := a.service.ExecuteCode(ctx, payload)
		if err != nil {
			return a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return serr
		}
		final := &ToolsCallResult{
			Content: []*ContentItem{
				buildContentItem(a, s),
			},
		}
		a.log(ctx, "response", map[string]any{"method": "tools/call", "name": p.Name})
		return stream.SendAndClose(ctx, final)
	case "process_batch":
		req := &http.Request{Header: http.Header{"Content-Type": []string{"application/json"}}, Body: io.NopCloser(bytes.NewReader(p.Arguments))}
		var payload *assistant.ProcessBatchPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return goa.PermanentError("invalid_params", "%s", err.Error())
		}
		{
			{
				var __val string
				if payload.Format != nil {
					__val = *payload.Format
				}
				ok := false
				switch __val {
				case "text":
					ok = true
				case "blob":
					ok = true
				case "uri":
					ok = true
				}
				if !ok && __val != "" {
					return goa.PermanentError("invalid_params", "Invalid value for format")
				}
			}
		}
		bridge := &ProcessBatchStreamBridge{out: stream, adapter: a}
		if err := a.service.ProcessBatch(ctx, payload, bridge); err != nil {
			return a.mapError(err)
		}
		return nil
	default:
		return goa.PermanentError("method_not_found", "Unknown tool: %s", p.Name)
	}
}

// Resources handling

func (a *MCPAdapter) ResourcesList(ctx context.Context, p *ResourcesListPayload) (*ResourcesListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "resources/list"})
	resources := []*ResourceInfo{
		{URI: "doc://list", Name: stringPtr("documents"), Description: stringPtr("List available documents"), MimeType: stringPtr("application/json")},
		{URI: "system://info", Name: stringPtr("system_info"), Description: stringPtr("Get system information and status"), MimeType: stringPtr("application/json")},
		{URI: "conversation://history", Name: stringPtr("conversation_history"), Description: stringPtr("Get conversation history with optional filtering"), MimeType: stringPtr("application/json")},
	}
	res := &ResourcesListResult{Resources: resources}
	a.log(ctx, "response", map[string]any{"method": "resources/list"})
	return res, nil
}

func (a *MCPAdapter) ResourcesRead(ctx context.Context, p *ResourcesReadPayload) (*ResourcesReadResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if err := a.assertResourceURIAllowed(ctx, p.URI); err != nil {
		return nil, goa.PermanentError("invalid_params", "%s", err.Error())
	}
	a.log(ctx, "request", map[string]any{"method": "resources/read", "uri": p.URI})
	baseURI := p.URI
	if i := strings.Index(baseURI, "?"); i >= 0 {
		baseURI = baseURI[:i]
	}
	switch baseURI {
	case "doc://list":
		result, err := a.service.ListDocuments(ctx)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	case "system://info":
		result, err := a.service.GetSystemInfo(ctx)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	case "conversation://history":
		args, aerr := parseQueryParamsToJSON(p.URI)
		if aerr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", aerr.Error())
		}
		req := &http.Request{Body: io.NopCloser(bytes.NewReader(args)), Header: http.Header{"Content-Type": []string{"application/json"}}}
		var payload *assistant.GetConversationHistoryPayload
		if err := goahttp.RequestDecoder(req).Decode(&payload); err != nil {
			return nil, goa.PermanentError("invalid_params", "%s", err.Error())
		}
		result, err := a.service.GetConversationHistory(ctx, payload)
		if err != nil {
			return nil, a.mapError(err)
		}
		s, serr := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, result)
		if serr != nil {
			return nil, goa.PermanentError("invalid_params", "%s", serr.Error())
		}
		res := &ResourcesReadResult{Contents: []*ResourceContent{{URI: baseURI, MimeType: stringPtr("application/json"), Text: &s}}}
		a.log(ctx, "response", map[string]any{"method": "resources/read", "uri": baseURI})
		return res, nil
	default:
		return nil, goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

// assertResourceURIAllowed verifies pURI passes allow/deny filters when configured.
func (a *MCPAdapter) assertResourceURIAllowed(ctx context.Context, pURI string) error {
	base := pURI
	if i := strings.Index(base, "?"); i >= 0 {
		base = base[:i]
	}
	// Merge header-driven allow/deny lists from context (CSV of names)
	var extraAllowURIs, extraDenyURIs []string
	if ctx != nil {
		if v := ctx.Value("mcp_allow_names"); v != nil {
			if s, ok := v.(string); ok {
				for _, n := range strings.Split(s, ",") {
					n = strings.TrimSpace(n)
					if u, ok2 := a.resourceNameToURI[n]; ok2 {
						extraAllowURIs = append(extraAllowURIs, u)
					}
				}
			}
		}
		if v := ctx.Value("mcp_deny_names"); v != nil {
			if s, ok := v.(string); ok {
				for _, n := range strings.Split(s, ",") {
					n = strings.TrimSpace(n)
					if u, ok2 := a.resourceNameToURI[n]; ok2 {
						extraDenyURIs = append(extraDenyURIs, u)
					}
				}
			}
		}
	}
	for _, allow := range extraAllowURIs {
		if allow == base {
			return nil
		}
	}
	for _, d := range append(a.opts.DeniedResourceURIs, extraDenyURIs...) {
		if d == base {
			return fmt.Errorf("resource URI denied: %s", pURI)
		}
	}
	if len(a.opts.AllowedResourceURIs) == 0 && len(extraAllowURIs) == 0 {
		return nil
	}
	for _, allow := range append(a.opts.AllowedResourceURIs, extraAllowURIs...) {
		if allow == base {
			return nil
		}
	}
	return fmt.Errorf("resource URI not allowed: %s", pURI)
}

func (a *MCPAdapter) ResourcesSubscribe(ctx context.Context, p *ResourcesSubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	switch p.URI {
	default:
		return goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

func (a *MCPAdapter) ResourcesUnsubscribe(ctx context.Context, p *ResourcesUnsubscribePayload) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	switch p.URI {
	default:
		return goa.PermanentError("method_not_found", "Unknown resource: %s", p.URI)
	}
}

// Prompts handling

func (a *MCPAdapter) PromptsList(ctx context.Context, p *PromptsListPayload) (*PromptsListResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "prompts/list"})
	prompts := []*PromptInfo{

		{Name: "contextual_prompts", Description: stringPtr("Generate prompts based on context"), Arguments: []*PromptArgument{

			{Name: "context", Description: stringPtr("Current context"), Required: true},

			{Name: "task", Description: stringPtr("Task type"), Required: true},
		}},

		{Name: "code_review", Description: stringPtr("Template for code review")},
	}
	res := &PromptsListResult{Prompts: prompts}
	a.log(ctx, "response", map[string]any{"method": "prompts/list"})
	return res, nil
}

func (a *MCPAdapter) PromptsGet(ctx context.Context, p *PromptsGetPayload) (*PromptsGetResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	if p == nil || p.Name == "" {
		return nil, goa.PermanentError("invalid_params", "Missing prompt name")
	}
	a.log(ctx, "request", map[string]any{"method": "prompts/get", "name": p.Name})
	switch p.Name {

	case "code_review":
		if a.promptProvider != nil {
			if res, err := a.promptProvider.GetCodeReviewPrompt(p.Arguments); err == nil && res != nil {
				a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
				return res, nil
			} else if err != nil {
				return nil, err
			}
		}
		msgs := make([]*PromptMessage, 0, 3)

		msgs = append(msgs, &PromptMessage{
			Role: "system",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("You are an expert code reviewer."),
			},
		})

		msgs = append(msgs, &PromptMessage{
			Role: "user",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("Please review this code: {{.code}}"),
			},
		})

		msgs = append(msgs, &PromptMessage{
			Role: "assistant",
			Content: &MessageContent{
				Type: "text",
				Text: stringPtr("I'll analyze the code for quality, bugs, and improvements."),
			},
		})

		res := &PromptsGetResult{
			Description: stringPtr("Template for code review"),
			Messages:    msgs,
		}
		a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
		return res, nil

	}

	switch p.Name {

	case "contextual_prompts":
		{

			var args map[string]any
			if len(p.Arguments) > 0 {
				if err := json.Unmarshal(p.Arguments, &args); err != nil {
					return nil, goa.PermanentError("invalid_params", "%s", err.Error())
				}
			}

			if _, ok := args["context"]; !ok {
				return nil, goa.PermanentError("invalid_params", "Missing required argument: context")
			}

			if _, ok := args["task"]; !ok {
				return nil, goa.PermanentError("invalid_params", "Missing required argument: task")
			}

		}
		if a.promptProvider == nil {
			return nil, goa.PermanentError("invalid_params", "No prompt provider configured for dynamic prompts")
		}
		res, err := a.promptProvider.GetContextualPromptsPrompt(ctx, p.Arguments)
		if err != nil {
			return nil, a.mapError(err)
		}
		a.log(ctx, "response", map[string]any{"method": "prompts/get", "name": p.Name})
		return res, nil

	}

	return nil, goa.PermanentError("method_not_found", "Unknown prompt: %s", p.Name)
}

// Notifications and events stream

func (a *MCPAdapter) NotifyStatusUpdate(ctx context.Context, n *mcpruntime.Notification) error {
	if !a.isInitialized() {
		return goa.PermanentError("invalid_params", "Not initialized")
	}
	if n == nil || n.Type == "" {
		return goa.PermanentError("invalid_params", "Missing notification type")
	}
	s, err := mcpruntime.EncodeJSONToString(ctx, goahttp.ResponseEncoder, n)
	if err != nil {
		return err
	}
	ev := &EventsStreamResult{
		Content: []*ContentItem{
			buildContentItem(a, s),
		},
	}
	a.Publish(ev)
	return nil
}

func (a *MCPAdapter) EventsStream(ctx context.Context, stream EventsStreamServerStream) error {
	if !a.isInitialized() {
		return goa.PermanentError("internal_error", "Not initialized")
	}
	sub, err := a.broadcaster.Subscribe(ctx)
	if err != nil {
		return goa.PermanentError("internal_error", "Failed to subscribe to events: %v", err)
	}
	defer sub.Close()
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case ev, ok := <-sub.C():
			if !ok {
				return nil
			}
			// Ensure published events implement the generated EventsStreamEvent marker.
			evt, ok := ev.(EventsStreamEvent)
			if !ok {
				continue
			}
			if err := stream.Send(ctx, evt); err != nil {
				return goa.PermanentError("internal_error", "Failed to send event: %v", err)
			}
		}
	}
}

// General subscriptions handling

func (a *MCPAdapter) Subscribe(ctx context.Context, p *SubscribePayload) (*SubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "subscribe"})
	res := &SubscribeResult{Success: true}
	a.log(ctx, "response", map[string]any{"method": "subscribe"})
	return res, nil
}

func (a *MCPAdapter) Unsubscribe(ctx context.Context, p *UnsubscribePayload) (*UnsubscribeResult, error) {
	if !a.isInitialized() {
		return nil, goa.PermanentError("invalid_params", "Not initialized")
	}
	a.log(ctx, "request", map[string]any{"method": "unsubscribe"})
	res := &UnsubscribeResult{Success: true}
	a.log(ctx, "response", map[string]any{"method": "unsubscribe"})
	return res, nil
}
