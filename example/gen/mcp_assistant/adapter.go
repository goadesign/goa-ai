// Code generated by goa v3.21.5, DO NOT EDIT.
//
// MCP adapter for assistant service
//
// Command:
// $ goa gen example.com/assistant/design

package mcpassistant

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	assistant "example.com/assistant/gen/assistant"
	assistanthttp "example.com/assistant/gen/http/assistant/server"
	goahttp "goa.design/goa/v3/http"
)

// MCPAdapter handles MCP protocol requests and adapts them to the original
// service
type MCPAdapter struct {
	service        assistant.Service
	mux            goahttp.Muxer
	promptProvider PromptProvider
}

// NewMCPAdapter creates a new MCP adapter that wraps the original service
func NewMCPAdapter(service assistant.Service, promptProvider PromptProvider) *MCPAdapter {
	return &MCPAdapter{
		service:        service,
		mux:            goahttp.NewMuxer(),
		promptProvider: promptProvider,
	}
}

// Initialize handles the MCP initialize request
func (a *MCPAdapter) Initialize(ctx context.Context, p *InitializePayload) (*InitializeResult, error) {
	// Build server info
	serverInfo := &ServerInfo{
		Name:    "assistant-mcp",
		Version: "1.0.0",
	}

	// Build capabilities
	capabilities := &ServerCapabilities{}
	// Add tools capability
	capabilities.Tools = &ToolsCapability{}
	// Add resources capability
	capabilities.Resources = &ResourcesCapability{}
	// Add prompts capability
	capabilities.Prompts = &PromptsCapability{}

	return &InitializeResult{
		ProtocolVersion: "2024-11-05",
		ServerInfo:      serverInfo,
		Capabilities:    capabilities,
	}, nil
}

// Ping handles the MCP ping request
func (a *MCPAdapter) Ping(ctx context.Context) error {
	// Simple ping response
	return nil
}

// ToolsList returns the list of available tools
func (a *MCPAdapter) ToolsList(ctx context.Context) (*ToolsListResult, error) {
	tools := []*ToolInfo{
		{
			Name:        "analyze_text",
			Description: stringPtr("Analyze text with various modes"),
			InputSchema: json.RawMessage(`{
				"type": "object",
				"properties": {},
				"additionalProperties": false
			}`),
		},
		{
			Name:        "search",
			Description: stringPtr("Search the knowledge base"),
			InputSchema: json.RawMessage(`{
				"type": "object",
				"properties": {},
				"additionalProperties": false
			}`),
		},
		{
			Name:        "execute_code",
			Description: stringPtr("Execute code safely in sandbox"),
			InputSchema: json.RawMessage(`{
				"type": "object",
				"properties": {},
				"additionalProperties": false
			}`),
		},
		{
			Name:        "process_batch",
			Description: stringPtr("Process items with progress updates"),
			InputSchema: json.RawMessage(`{
				"type": "object",
				"properties": {},
				"additionalProperties": false
			}`),
		},
	}

	return &ToolsListResult{Tools: tools}, nil
}

// ToolsCall executes a tool and returns the result
func (a *MCPAdapter) ToolsCall(ctx context.Context, p *ToolsCallPayload) (*ToolsCallResult, error) {
	switch p.Name {
	case "analyze_text":
		// Use HTTP decoder from the original service
		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(p.Arguments)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeAnalyzeTextRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode arguments for tool analyze_text: %w", err)
		}

		// Call the original service method
		result, err := a.service.AnalyzeText(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		txt := stringPtr(string(resultBytes))
		return &ToolsCallResult{Content: []*ContentItem{{Type: "text", Text: txt}}}, nil
	case "search":
		// Use HTTP decoder from the original service
		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(p.Arguments)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeSearchKnowledgeRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode arguments for tool search: %w", err)
		}

		// Call the original service method
		result, err := a.service.SearchKnowledge(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		txt := stringPtr(string(resultBytes))
		return &ToolsCallResult{Content: []*ContentItem{{Type: "text", Text: txt}}}, nil
	case "execute_code":
		// Use HTTP decoder from the original service
		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(p.Arguments)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeExecuteCodeRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode arguments for tool execute_code: %w", err)
		}

		// Call the original service method
		result, err := a.service.ExecuteCode(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		txt := stringPtr(string(resultBytes))
		return &ToolsCallResult{Content: []*ContentItem{{Type: "text", Text: txt}}}, nil
	case "process_batch":
		// Use HTTP decoder from the original service
		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(p.Arguments)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeProcessBatchRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode arguments for tool process_batch: %w", err)
		}

		// Call the original service method
		result, err := a.service.ProcessBatch(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		txt := stringPtr(string(resultBytes))
		return &ToolsCallResult{Content: []*ContentItem{{Type: "text", Text: txt}}}, nil
	default:
		return nil, fmt.Errorf("unknown tool: %s", p.Name)
	}
}

// ResourcesList returns the list of available resources
func (a *MCPAdapter) ResourcesList(ctx context.Context) (*ResourcesListResult, error) {
	resources := []*ResourceInfo{
		{
			URI:         "doc://list",
			Name:        stringPtr("documents"),
			Description: stringPtr("List available documents"),
			MimeType:    stringPtr("application/json"),
		},
		{
			URI:         "system://info",
			Name:        stringPtr("system_info"),
			Description: stringPtr("Get system information and status"),
			MimeType:    stringPtr("application/json"),
		},
		{
			URI:         "conversation://history",
			Name:        stringPtr("conversation"),
			Description: stringPtr("Get conversation history"),
			MimeType:    stringPtr("application/json"),
		},
	}

	return &ResourcesListResult{Resources: resources}, nil
}

// ResourcesRead reads a resource and returns its content
func (a *MCPAdapter) ResourcesRead(ctx context.Context, p *ResourcesReadPayload) (*ResourcesReadResult, error) {
	switch p.URI {
	case "doc://list":

		// Call the original service method
		result, err := a.service.ListDocuments(ctx)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		return &ResourcesReadResult{
			Contents: []*ResourceContent{
				{URI: p.URI, MimeType: stringPtr("application/json"), Text: stringPtr(string(resultBytes))},
			},
		}, nil
	case "system://info":

		// Call the original service method
		result, err := a.service.GetSystemInfo(ctx)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		return &ResourcesReadResult{
			Contents: []*ResourceContent{
				{URI: p.URI, MimeType: stringPtr("application/json"), Text: stringPtr(string(resultBytes))},
			},
		}, nil
	case "conversation://history":
		// For resources, encode the URI into a JSON payload for the decoder
		argBytes, err := json.Marshal(map[string]string{"uri": p.URI})
		if err != nil {
			return nil, fmt.Errorf("failed to encode URI: %w", err)
		}

		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(argBytes)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeGetConversationHistoryRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode payload for resource conversation://history: %w", err)
		}

		// Call the original service method
		result, err := a.service.GetConversationHistory(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Marshal the result to JSON
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}

		return &ResourcesReadResult{
			Contents: []*ResourceContent{
				{URI: p.URI, MimeType: stringPtr("application/json"), Text: stringPtr(string(resultBytes))},
			},
		}, nil
	default:
		return nil, fmt.Errorf("unknown resource: %s", p.URI)
	}
}

// ResourcesSubscribe subscribes to resource changes
func (a *MCPAdapter) ResourcesSubscribe(ctx context.Context, p *ResourcesSubscribePayload) error {
	// TODO: Implement resource subscription if needed
	return fmt.Errorf("resource subscription not implemented")
}

// ResourcesUnsubscribe unsubscribes from resource changes
func (a *MCPAdapter) ResourcesUnsubscribe(ctx context.Context, p *ResourcesUnsubscribePayload) error {
	// TODO: Implement resource unsubscription if needed
	return fmt.Errorf("resource unsubscription not implemented")
}

// PromptsList returns the list of available prompts
func (a *MCPAdapter) PromptsList(ctx context.Context) (*PromptsListResult, error) {
	prompts := []*PromptInfo{
		{
			Name:        "code_review",
			Description: stringPtr("Template for code review"),
		},
		{
			Name:        "explain_concept",
			Description: stringPtr("Template for explaining concepts"),
		},
		{
			Name:        "contextual_prompts",
			Description: stringPtr("Generate prompts based on context"),
		},
	}

	return &PromptsListResult{Prompts: prompts}, nil
}

// PromptsGet retrieves a specific prompt
func (a *MCPAdapter) PromptsGet(ctx context.Context, p *PromptsGetPayload) (*PromptsGetResult, error) {
	if a.promptProvider == nil {
		return nil, fmt.Errorf("prompt provider not configured")
	}

	switch p.Name {
	case "code_review":
		return a.promptProvider.GetCodeReviewPrompt(p.Arguments)
	case "explain_concept":
		return a.promptProvider.GetExplainConceptPrompt(p.Arguments)
	case "contextual_prompts":
		// Use HTTP decoder from the original service
		req := &http.Request{
			Body:   io.NopCloser(bytes.NewReader(p.Arguments)),
			Header: http.Header{"Content-Type": []string{"application/json"}},
		}

		// Decode using the original service's HTTP decoder
		dec := assistanthttp.DecodeGeneratePromptsRequest(a.mux, goahttp.RequestDecoder)
		payload, err := dec(req)
		if err != nil {
			return nil, fmt.Errorf("failed to decode arguments for prompt contextual_prompts: %w", err)
		}

		// Call the original service method
		result, err := a.service.GeneratePrompts(ctx, payload)
		if err != nil {
			return nil, err
		}

		// Convert service result into a single text prompt message
		resultBytes, err := json.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}
		return &PromptsGetResult{
			Description: stringPtr("Generate prompts based on context"),
			Messages: []*PromptMessage{
				{Role: "system", Content: &MessageContent{Type: "text", Text: stringPtr(string(resultBytes))}},
			},
		}, nil
	default:
		return nil, fmt.Errorf("unknown prompt: %s", p.Name)
	}
}

// stringPtr returns a pointer to a string
func stringPtr(s string) *string {
	return &s
}
