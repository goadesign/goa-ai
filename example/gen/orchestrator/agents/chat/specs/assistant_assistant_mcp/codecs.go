// Code generated by goa v3.22.6, DO NOT EDIT.
//
// ChatAgent tool codecs
//
// Command:
// $ goa gen example.com/assistant/design

package assistant_assistant_mcp

import (
	"encoding/json"
	"fmt"

	assistant "example.com/assistant/gen/assistant"
	"goa.design/goa-ai/runtime/agents/tools"
)

var (
	// AnalyzeSentimentPayloadCodec serializes values of type *assistant.AnalyzeSentimentPayload to canonical JSON.
	AnalyzeSentimentPayloadCodec = tools.JSONCodec[*assistant.AnalyzeSentimentPayload]{
		ToJSON:   MarshalAnalyzeSentimentPayload,
		FromJSON: UnmarshalAnalyzeSentimentPayload,
	}
	// AnalyzeSentimentResultCodec serializes values of type *assistant.SentimentResult to canonical JSON.
	AnalyzeSentimentResultCodec = tools.JSONCodec[*assistant.SentimentResult]{
		ToJSON:   MarshalAnalyzeSentimentResult,
		FromJSON: UnmarshalAnalyzeSentimentResult,
	}
	// ExecuteCodePayloadCodec serializes values of type *assistant.ExecuteCodePayload to canonical JSON.
	ExecuteCodePayloadCodec = tools.JSONCodec[*assistant.ExecuteCodePayload]{
		ToJSON:   MarshalExecuteCodePayload,
		FromJSON: UnmarshalExecuteCodePayload,
	}
	// ExecuteCodeResultCodec serializes values of type *assistant.ExecutionResult to canonical JSON.
	ExecuteCodeResultCodec = tools.JSONCodec[*assistant.ExecutionResult]{
		ToJSON:   MarshalExecuteCodeResult,
		FromJSON: UnmarshalExecuteCodeResult,
	}
	// ExtractKeywordsPayloadCodec serializes values of type *assistant.ExtractKeywordsPayload to canonical JSON.
	ExtractKeywordsPayloadCodec = tools.JSONCodec[*assistant.ExtractKeywordsPayload]{
		ToJSON:   MarshalExtractKeywordsPayload,
		FromJSON: UnmarshalExtractKeywordsPayload,
	}
	// ExtractKeywordsResultCodec serializes values of type *assistant.KeywordsResult to canonical JSON.
	ExtractKeywordsResultCodec = tools.JSONCodec[*assistant.KeywordsResult]{
		ToJSON:   MarshalExtractKeywordsResult,
		FromJSON: UnmarshalExtractKeywordsResult,
	}
	// ProcessBatchPayloadCodec serializes values of type *assistant.ProcessBatchPayload to canonical JSON.
	ProcessBatchPayloadCodec = tools.JSONCodec[*assistant.ProcessBatchPayload]{
		ToJSON:   MarshalProcessBatchPayload,
		FromJSON: UnmarshalProcessBatchPayload,
	}
	// ProcessBatchResultCodec serializes values of type *assistant.BatchResult to canonical JSON.
	ProcessBatchResultCodec = tools.JSONCodec[*assistant.BatchResult]{
		ToJSON:   MarshalProcessBatchResult,
		FromJSON: UnmarshalProcessBatchResult,
	}
	// SearchPayloadCodec serializes values of type *assistant.SearchKnowledgePayload to canonical JSON.
	SearchPayloadCodec = tools.JSONCodec[*assistant.SearchKnowledgePayload]{
		ToJSON:   MarshalSearchPayload,
		FromJSON: UnmarshalSearchPayload,
	}
	// SearchResultCodec serializes values of type assistant.SearchResults to canonical JSON.
	SearchResultCodec = tools.JSONCodec[assistant.SearchResults]{
		ToJSON:   MarshalSearchResult,
		FromJSON: UnmarshalSearchResult,
	}
	// SummarizeTextPayloadCodec serializes values of type *assistant.SummarizeTextPayload to canonical JSON.
	SummarizeTextPayloadCodec = tools.JSONCodec[*assistant.SummarizeTextPayload]{
		ToJSON:   MarshalSummarizeTextPayload,
		FromJSON: UnmarshalSummarizeTextPayload,
	}
	// SummarizeTextResultCodec serializes values of type *assistant.SummaryResult to canonical JSON.
	SummarizeTextResultCodec = tools.JSONCodec[*assistant.SummaryResult]{
		ToJSON:   MarshalSummarizeTextResult,
		FromJSON: UnmarshalSummarizeTextResult,
	}
	// analyzeSentimentPayloadCodec provides an untyped codec for *assistant.AnalyzeSentimentPayload.
	analyzeSentimentPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.AnalyzeSentimentPayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.AnalyzeSentimentPayload, got %T", v)
			}
			return MarshalAnalyzeSentimentPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalAnalyzeSentimentPayload(data)
		},
	}
	// analyzeSentimentResultCodec provides an untyped codec for *assistant.SentimentResult.
	analyzeSentimentResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.SentimentResult)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.SentimentResult, got %T", v)
			}
			return MarshalAnalyzeSentimentResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalAnalyzeSentimentResult(data)
		},
	}
	// executeCodePayloadCodec provides an untyped codec for *assistant.ExecuteCodePayload.
	executeCodePayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.ExecuteCodePayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.ExecuteCodePayload, got %T", v)
			}
			return MarshalExecuteCodePayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalExecuteCodePayload(data)
		},
	}
	// executeCodeResultCodec provides an untyped codec for *assistant.ExecutionResult.
	executeCodeResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.ExecutionResult)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.ExecutionResult, got %T", v)
			}
			return MarshalExecuteCodeResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalExecuteCodeResult(data)
		},
	}
	// extractKeywordsPayloadCodec provides an untyped codec for *assistant.ExtractKeywordsPayload.
	extractKeywordsPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.ExtractKeywordsPayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.ExtractKeywordsPayload, got %T", v)
			}
			return MarshalExtractKeywordsPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalExtractKeywordsPayload(data)
		},
	}
	// extractKeywordsResultCodec provides an untyped codec for *assistant.KeywordsResult.
	extractKeywordsResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.KeywordsResult)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.KeywordsResult, got %T", v)
			}
			return MarshalExtractKeywordsResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalExtractKeywordsResult(data)
		},
	}
	// processBatchPayloadCodec provides an untyped codec for *assistant.ProcessBatchPayload.
	processBatchPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.ProcessBatchPayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.ProcessBatchPayload, got %T", v)
			}
			return MarshalProcessBatchPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalProcessBatchPayload(data)
		},
	}
	// processBatchResultCodec provides an untyped codec for *assistant.BatchResult.
	processBatchResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.BatchResult)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.BatchResult, got %T", v)
			}
			return MarshalProcessBatchResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalProcessBatchResult(data)
		},
	}
	// searchPayloadCodec provides an untyped codec for *assistant.SearchKnowledgePayload.
	searchPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.SearchKnowledgePayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.SearchKnowledgePayload, got %T", v)
			}
			return MarshalSearchPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalSearchPayload(data)
		},
	}
	// searchResultCodec provides an untyped codec for assistant.SearchResults.
	searchResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(assistant.SearchResults)
			if !ok {
				return nil, fmt.Errorf("expected assistant.SearchResults, got %T", v)
			}
			return MarshalSearchResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalSearchResult(data)
		},
	}
	// summarizeTextPayloadCodec provides an untyped codec for *assistant.SummarizeTextPayload.
	summarizeTextPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.SummarizeTextPayload)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.SummarizeTextPayload, got %T", v)
			}
			return MarshalSummarizeTextPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalSummarizeTextPayload(data)
		},
	}
	// summarizeTextResultCodec provides an untyped codec for *assistant.SummaryResult.
	summarizeTextResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(*assistant.SummaryResult)
			if !ok {
				return nil, fmt.Errorf("expected *assistant.SummaryResult, got %T", v)
			}
			return MarshalSummarizeTextResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalSummarizeTextResult(data)
		},
	}
)

// ValidationError wraps a validation failure and exposes issues that callers
// can use to build retry hints. It implements error and an Issues() accessor.
type ValidationError struct {
	msg          string
	issues       []*tools.FieldIssue
	descriptions map[string]string
}

func (e ValidationError) Error() string {
	return e.msg
}
func (e ValidationError) Issues() []*tools.FieldIssue {
	if len(e.issues) == 0 {
		return nil
	}
	out := make([]*tools.FieldIssue, len(e.issues))
	copy(out, e.issues)
	return out
}
func (e ValidationError) Descriptions() map[string]string {
	if len(e.descriptions) == 0 {
		return nil
	}
	out := make(map[string]string, len(e.descriptions))
	for k, v := range e.descriptions {
		out[k] = v
	}
	return out
}

// newValidationError converts a goa.ServiceError (possibly merged) into a
// ValidationError with structured FieldIssue entries. It trims any leading
// "body." from field names for conciseness.

// PayloadCodec returns the generic codec for the named tool payload.
func PayloadCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "assistant.assistant-mcp.analyze_sentiment":
		return &analyzeSentimentPayloadCodec, true
	case "assistant.assistant-mcp.execute_code":
		return &executeCodePayloadCodec, true
	case "assistant.assistant-mcp.extract_keywords":
		return &extractKeywordsPayloadCodec, true
	case "assistant.assistant-mcp.process_batch":
		return &processBatchPayloadCodec, true
	case "assistant.assistant-mcp.search":
		return &searchPayloadCodec, true
	case "assistant.assistant-mcp.summarize_text":
		return &summarizeTextPayloadCodec, true
	default:
		return nil, false
	}
}

// ResultCodec returns the generic codec for the named tool result.
func ResultCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "assistant.assistant-mcp.analyze_sentiment":
		return &analyzeSentimentResultCodec, true
	case "assistant.assistant-mcp.execute_code":
		return &executeCodeResultCodec, true
	case "assistant.assistant-mcp.extract_keywords":
		return &extractKeywordsResultCodec, true
	case "assistant.assistant-mcp.process_batch":
		return &processBatchResultCodec, true
	case "assistant.assistant-mcp.search":
		return &searchResultCodec, true
	case "assistant.assistant-mcp.summarize_text":
		return &summarizeTextResultCodec, true
	default:
		return nil, false
	}
}

// MarshalAnalyzeSentimentPayload serializes *assistant.AnalyzeSentimentPayload into JSON.
func MarshalAnalyzeSentimentPayload(v *assistant.AnalyzeSentimentPayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("analyzeSentimentPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalAnalyzeSentimentPayload deserializes JSON into *assistant.AnalyzeSentimentPayload.
func UnmarshalAnalyzeSentimentPayload(data []byte) (*assistant.AnalyzeSentimentPayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("analyzeSentimentPayload JSON is empty")
	}
	var v *assistant.AnalyzeSentimentPayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode analyzeSentimentPayload: %w", err)
	}
	return v, nil
}

// MarshalAnalyzeSentimentResult serializes *assistant.SentimentResult into JSON.
func MarshalAnalyzeSentimentResult(v *assistant.SentimentResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("analyzeSentimentResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalAnalyzeSentimentResult deserializes JSON into *assistant.SentimentResult.
func UnmarshalAnalyzeSentimentResult(data []byte) (*assistant.SentimentResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("analyzeSentimentResult JSON is empty")
	}
	var v *assistant.SentimentResult
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode analyzeSentimentResult: %w", err)
	}
	return v, nil
}

// MarshalExecuteCodePayload serializes *assistant.ExecuteCodePayload into JSON.
func MarshalExecuteCodePayload(v *assistant.ExecuteCodePayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("executeCodePayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalExecuteCodePayload deserializes JSON into *assistant.ExecuteCodePayload.
func UnmarshalExecuteCodePayload(data []byte) (*assistant.ExecuteCodePayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("executeCodePayload JSON is empty")
	}
	var v *assistant.ExecuteCodePayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode executeCodePayload: %w", err)
	}
	return v, nil
}

// MarshalExecuteCodeResult serializes *assistant.ExecutionResult into JSON.
func MarshalExecuteCodeResult(v *assistant.ExecutionResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("executeCodeResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalExecuteCodeResult deserializes JSON into *assistant.ExecutionResult.
func UnmarshalExecuteCodeResult(data []byte) (*assistant.ExecutionResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("executeCodeResult JSON is empty")
	}
	var v *assistant.ExecutionResult
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode executeCodeResult: %w", err)
	}
	return v, nil
}

// MarshalExtractKeywordsPayload serializes *assistant.ExtractKeywordsPayload into JSON.
func MarshalExtractKeywordsPayload(v *assistant.ExtractKeywordsPayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("extractKeywordsPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalExtractKeywordsPayload deserializes JSON into *assistant.ExtractKeywordsPayload.
func UnmarshalExtractKeywordsPayload(data []byte) (*assistant.ExtractKeywordsPayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("extractKeywordsPayload JSON is empty")
	}
	var v *assistant.ExtractKeywordsPayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode extractKeywordsPayload: %w", err)
	}
	return v, nil
}

// MarshalExtractKeywordsResult serializes *assistant.KeywordsResult into JSON.
func MarshalExtractKeywordsResult(v *assistant.KeywordsResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("extractKeywordsResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalExtractKeywordsResult deserializes JSON into *assistant.KeywordsResult.
func UnmarshalExtractKeywordsResult(data []byte) (*assistant.KeywordsResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("extractKeywordsResult JSON is empty")
	}
	var v *assistant.KeywordsResult
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode extractKeywordsResult: %w", err)
	}
	return v, nil
}

// MarshalProcessBatchPayload serializes *assistant.ProcessBatchPayload into JSON.
func MarshalProcessBatchPayload(v *assistant.ProcessBatchPayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("processBatchPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalProcessBatchPayload deserializes JSON into *assistant.ProcessBatchPayload.
func UnmarshalProcessBatchPayload(data []byte) (*assistant.ProcessBatchPayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("processBatchPayload JSON is empty")
	}
	var v *assistant.ProcessBatchPayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode processBatchPayload: %w", err)
	}
	return v, nil
}

// MarshalProcessBatchResult serializes *assistant.BatchResult into JSON.
func MarshalProcessBatchResult(v *assistant.BatchResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("processBatchResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalProcessBatchResult deserializes JSON into *assistant.BatchResult.
func UnmarshalProcessBatchResult(data []byte) (*assistant.BatchResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("processBatchResult JSON is empty")
	}
	var v *assistant.BatchResult
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode processBatchResult: %w", err)
	}
	return v, nil
}

// MarshalSearchPayload serializes *assistant.SearchKnowledgePayload into JSON.
func MarshalSearchPayload(v *assistant.SearchKnowledgePayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("searchPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalSearchPayload deserializes JSON into *assistant.SearchKnowledgePayload.
func UnmarshalSearchPayload(data []byte) (*assistant.SearchKnowledgePayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("searchPayload JSON is empty")
	}
	var v *assistant.SearchKnowledgePayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode searchPayload: %w", err)
	}
	return v, nil
}

// MarshalSearchResult serializes assistant.SearchResults into JSON.
func MarshalSearchResult(v assistant.SearchResults) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("searchResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalSearchResult deserializes JSON into assistant.SearchResults.
func UnmarshalSearchResult(data []byte) (assistant.SearchResults, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("searchResult JSON is empty")
	}
	var v assistant.SearchResults
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode searchResult: %w", err)
	}
	return v, nil
}

// MarshalSummarizeTextPayload serializes *assistant.SummarizeTextPayload into JSON.
func MarshalSummarizeTextPayload(v *assistant.SummarizeTextPayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("summarizeTextPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalSummarizeTextPayload deserializes JSON into *assistant.SummarizeTextPayload.
func UnmarshalSummarizeTextPayload(data []byte) (*assistant.SummarizeTextPayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("summarizeTextPayload JSON is empty")
	}
	var v *assistant.SummarizeTextPayload
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode summarizeTextPayload: %w", err)
	}
	return v, nil
}

// MarshalSummarizeTextResult serializes *assistant.SummaryResult into JSON.
func MarshalSummarizeTextResult(v *assistant.SummaryResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("summarizeTextResult is nil")
	}
	return json.Marshal(v)
}

// UnmarshalSummarizeTextResult deserializes JSON into *assistant.SummaryResult.
func UnmarshalSummarizeTextResult(data []byte) (*assistant.SummaryResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("summarizeTextResult JSON is empty")
	}
	var v *assistant.SummaryResult
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, fmt.Errorf("decode summarizeTextResult: %w", err)
	}
	return v, nil
}
