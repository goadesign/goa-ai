// Code generated by goa v3.21.5, DO NOT EDIT.
//
// assistant JSON-RPC client CLI support package
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"encoding/json"
	"fmt"

	assistant "example.com/assistant/gen/assistant"
	goa "goa.design/goa/v3/pkg"
)

// BuildAnalyzeTextPayload builds the payload for the assistant analyze_text
// endpoint from CLI flags.
func BuildAnalyzeTextPayload(assistantAnalyzeTextBody string) (*assistant.AnalyzeTextPayload, error) {
	var err error
	var body AnalyzeTextRequestBody
	{
		err = json.Unmarshal([]byte(assistantAnalyzeTextBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"mode\": \"summary\",\n      \"text\": \"In magni.\"\n   }'")
		}
		if !(body.Mode == "sentiment" || body.Mode == "keywords" || body.Mode == "summary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.mode", body.Mode, []any{"sentiment", "keywords", "summary"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.AnalyzeTextPayload{
		Text: body.Text,
		Mode: body.Mode,
	}

	return v, nil
}

// BuildSearchKnowledgePayload builds the payload for the assistant
// search_knowledge endpoint from CLI flags.
func BuildSearchKnowledgePayload(assistantSearchKnowledgeBody string) (*assistant.SearchKnowledgePayload, error) {
	var err error
	var body SearchKnowledgeRequestBody
	{
		err = json.Unmarshal([]byte(assistantSearchKnowledgeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 5052907653549127393,\n      \"query\": \"Molestiae atque.\"\n   }'")
		}
	}
	v := &assistant.SearchKnowledgePayload{
		Query: body.Query,
		Limit: body.Limit,
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 10
		}
	}

	return v, nil
}

// BuildExecuteCodePayload builds the payload for the assistant execute_code
// endpoint from CLI flags.
func BuildExecuteCodePayload(assistantExecuteCodeBody string) (*assistant.ExecuteCodePayload, error) {
	var err error
	var body ExecuteCodeRequestBody
	{
		err = json.Unmarshal([]byte(assistantExecuteCodeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"code\": \"Temporibus et.\",\n      \"language\": \"Optio soluta numquam nostrum est et ipsa.\"\n   }'")
		}
	}
	v := &assistant.ExecuteCodePayload{
		Language: body.Language,
		Code:     body.Code,
	}

	return v, nil
}

// BuildGetConversationHistoryPayload builds the payload for the assistant
// get_conversation_history endpoint from CLI flags.
func BuildGetConversationHistoryPayload(assistantGetConversationHistoryBody string) (*assistant.GetConversationHistoryPayload, error) {
	var err error
	var body GetConversationHistoryRequestBody
	{
		err = json.Unmarshal([]byte(assistantGetConversationHistoryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 893483951657480336\n   }'")
		}
	}
	v := &assistant.GetConversationHistoryPayload{
		Limit: body.Limit,
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}

	return v, nil
}

// BuildGeneratePromptsPayload builds the payload for the assistant
// generate_prompts endpoint from CLI flags.
func BuildGeneratePromptsPayload(assistantGeneratePromptsBody string) (*assistant.GeneratePromptsPayload, error) {
	var err error
	var body GeneratePromptsRequestBody
	{
		err = json.Unmarshal([]byte(assistantGeneratePromptsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": \"Sed reprehenderit nihil tenetur.\",\n      \"task\": \"Non velit ut assumenda earum aspernatur.\"\n   }'")
		}
	}
	v := &assistant.GeneratePromptsPayload{
		Context: body.Context,
		Task:    body.Task,
	}

	return v, nil
}

// BuildRequestCompletionPayload builds the payload for the assistant
// request_completion endpoint from CLI flags.
func BuildRequestCompletionPayload(assistantRequestCompletionBody string) (*assistant.RequestCompletionPayload, error) {
	var err error
	var body RequestCompletionRequestBody
	{
		err = json.Unmarshal([]byte(assistantRequestCompletionBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"messages\": [\n         {\n            \"content\": \"Sunt occaecati aut consectetur.\",\n            \"role\": \"Quasi sit excepturi eaque ut commodi tempore.\"\n         },\n         {\n            \"content\": \"Sunt occaecati aut consectetur.\",\n            \"role\": \"Quasi sit excepturi eaque ut commodi tempore.\"\n         },\n         {\n            \"content\": \"Sunt occaecati aut consectetur.\",\n            \"role\": \"Quasi sit excepturi eaque ut commodi tempore.\"\n         },\n         {\n            \"content\": \"Sunt occaecati aut consectetur.\",\n            \"role\": \"Quasi sit excepturi eaque ut commodi tempore.\"\n         }\n      ],\n      \"model_preferences\": {\n         \"cost_priority\": 0.36497652950651066,\n         \"hints\": [\n            {\n               \"name\": \"Quia provident officia.\"\n            },\n            {\n               \"name\": \"Quia provident officia.\"\n            }\n         ],\n         \"intelligence_priority\": 0.7839813227386582,\n         \"speed_priority\": 0.008791110319153961\n      }\n   }'")
		}
		if body.Messages == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("messages", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.RequestCompletionPayload{}
	if body.Messages != nil {
		v.Messages = make([]*assistant.SamplingMessage, len(body.Messages))
		for i, val := range body.Messages {
			v.Messages[i] = marshalSamplingMessageRequestBodyToAssistantSamplingMessage(val)
		}
	} else {
		v.Messages = []*assistant.SamplingMessage{}
	}
	if body.ModelPreferences != nil {
		v.ModelPreferences = &struct {
			Hints                []*assistant.ModelHint
			CostPriority         *float64
			SpeedPriority        *float64
			IntelligencePriority *float64
		}{
			CostPriority:         body.ModelPreferences.CostPriority,
			SpeedPriority:        body.ModelPreferences.SpeedPriority,
			IntelligencePriority: body.ModelPreferences.IntelligencePriority,
		}
		if body.ModelPreferences.Hints != nil {
			v.ModelPreferences.Hints = make([]*assistant.ModelHint, len(body.ModelPreferences.Hints))
			for i, val := range body.ModelPreferences.Hints {
				v.ModelPreferences.Hints[i] = marshalModelHintRequestBodyToAssistantModelHint(val)
			}
		}
	}

	return v, nil
}

// BuildSendNotificationPayload builds the payload for the assistant
// send_notification endpoint from CLI flags.
func BuildSendNotificationPayload(assistantSendNotificationBody string) (*assistant.SendNotificationPayload, error) {
	var err error
	var body SendNotificationRequestBody
	{
		err = json.Unmarshal([]byte(assistantSendNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"data\": \"Odio consequatur rerum.\",\n      \"message\": \"Aut dolores omnis itaque et omnis.\",\n      \"type\": \"success\"\n   }'")
		}
		if !(body.Type == "info" || body.Type == "warning" || body.Type == "error" || body.Type == "success") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"info", "warning", "error", "success"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.SendNotificationPayload{
		Type:    body.Type,
		Message: body.Message,
		Data:    body.Data,
	}

	return v, nil
}

// BuildSubscribeToUpdatesPayload builds the payload for the assistant
// subscribe_to_updates endpoint from CLI flags.
func BuildSubscribeToUpdatesPayload(assistantSubscribeToUpdatesBody string) (*assistant.SubscribeToUpdatesPayload, error) {
	var err error
	var body SubscribeToUpdatesRequestBody
	{
		err = json.Unmarshal([]byte(assistantSubscribeToUpdatesBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filter\": \"Odio commodi et repudiandae illum quis.\",\n      \"resource\": \"Sit sed cum est voluptatem.\"\n   }'")
		}
	}
	v := &assistant.SubscribeToUpdatesPayload{
		Resource: body.Resource,
		Filter:   body.Filter,
	}

	return v, nil
}

// BuildProcessBatchPayload builds the payload for the assistant process_batch
// endpoint from CLI flags.
func BuildProcessBatchPayload(assistantProcessBatchBody string) (*assistant.ProcessBatchPayload, error) {
	var err error
	var body ProcessBatchRequestBody
	{
		err = json.Unmarshal([]byte(assistantProcessBatchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"items\": [\n         \"In natus.\",\n         \"Aut exercitationem ea nemo.\"\n      ]\n   }'")
		}
		if body.Items == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ProcessBatchPayload{}
	if body.Items != nil {
		v.Items = make([]string, len(body.Items))
		for i, val := range body.Items {
			v.Items[i] = val
		}
	} else {
		v.Items = []string{}
	}

	return v, nil
}

// BuildMonitorResourceChangesPayload builds the payload for the assistant
// monitor_resource_changes endpoint from CLI flags.
func BuildMonitorResourceChangesPayload(assistantMonitorResourceChangesBody string) (*assistant.MonitorResourceChangesPayload, error) {
	var err error
	var body MonitorResourceChangesRequestBody
	{
		err = json.Unmarshal([]byte(assistantMonitorResourceChangesBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"stream\": true\n   }'")
		}
	}
	v := &assistant.MonitorResourceChangesPayload{
		SubscriptionID: body.SubscriptionID,
		Stream:         body.Stream,
	}
	{
		var zero bool
		if v.Stream == zero {
			v.Stream = false
		}
	}

	return v, nil
}

// BuildStreamLogsPayload builds the payload for the assistant stream_logs
// endpoint from CLI flags.
func BuildStreamLogsPayload(assistantStreamLogsBody string) (*assistant.StreamLogsPayload, error) {
	var err error
	var body StreamLogsRequestBody
	{
		err = json.Unmarshal([]byte(assistantStreamLogsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filter\": \"Quia cum delectus nobis veniam error sunt.\",\n      \"level\": \"warning\"\n   }'")
		}
	}
	v := &assistant.StreamLogsPayload{
		Level:  body.Level,
		Filter: body.Filter,
	}
	{
		var zero string
		if v.Level == zero {
			v.Level = "info"
		}
	}

	return v, nil
}
