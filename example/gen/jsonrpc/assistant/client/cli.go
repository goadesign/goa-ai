// Code generated by goa v3.22.2, DO NOT EDIT.
//
// assistant JSON-RPC client CLI support package
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	assistant "example.com/assistant/gen/assistant"
	goa "goa.design/goa/v3/pkg"
)

// BuildAnalyzeTextPayload builds the payload for the assistant analyze_text
// endpoint from CLI flags.
func BuildAnalyzeTextPayload(assistantAnalyzeTextBody string) (*assistant.AnalyzeTextPayload, error) {
	var err error
	var body AnalyzeTextRequestBody
	{
		err = json.Unmarshal([]byte(assistantAnalyzeTextBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"mode\": \"sentiment\",\n      \"text\": \"I love this new feature! It works perfectly.\"\n   }'")
		}
		if utf8.RuneCountInString(body.Text) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.text", body.Text, utf8.RuneCountInString(body.Text), 1, true))
		}
		if utf8.RuneCountInString(body.Text) > 10000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.text", body.Text, utf8.RuneCountInString(body.Text), 10000, false))
		}
		if !(body.Mode == "sentiment" || body.Mode == "keywords" || body.Mode == "summary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.mode", body.Mode, []any{"sentiment", "keywords", "summary"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.AnalyzeTextPayload{
		Text: body.Text,
		Mode: body.Mode,
	}

	return v, nil
}

// BuildSearchKnowledgePayload builds the payload for the assistant
// search_knowledge endpoint from CLI flags.
func BuildSearchKnowledgePayload(assistantSearchKnowledgeBody string) (*assistant.SearchKnowledgePayload, error) {
	var err error
	var body SearchKnowledgeRequestBody
	{
		err = json.Unmarshal([]byte(assistantSearchKnowledgeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 5,\n      \"query\": \"MCP protocol\"\n   }'")
		}
		if utf8.RuneCountInString(body.Query) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.query", body.Query, utf8.RuneCountInString(body.Query), 1, true))
		}
		if utf8.RuneCountInString(body.Query) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.query", body.Query, utf8.RuneCountInString(body.Query), 256, false))
		}
		if body.Limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.limit", body.Limit, 1, true))
		}
		if body.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.limit", body.Limit, 100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.SearchKnowledgePayload{
		Query: body.Query,
		Limit: body.Limit,
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 10
		}
	}

	return v, nil
}

// BuildExecuteCodePayload builds the payload for the assistant execute_code
// endpoint from CLI flags.
func BuildExecuteCodePayload(assistantExecuteCodeBody string) (*assistant.ExecuteCodePayload, error) {
	var err error
	var body ExecuteCodeRequestBody
	{
		err = json.Unmarshal([]byte(assistantExecuteCodeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"code\": \"print(2 + 2)\",\n      \"language\": \"python\"\n   }'")
		}
		if !(body.Language == "python" || body.Language == "javascript" || body.Language == "go") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.language", body.Language, []any{"python", "javascript", "go"}))
		}
		if utf8.RuneCountInString(body.Code) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.code", body.Code, utf8.RuneCountInString(body.Code), 1, true))
		}
		if utf8.RuneCountInString(body.Code) > 20000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.code", body.Code, utf8.RuneCountInString(body.Code), 20000, false))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ExecuteCodePayload{
		Language: body.Language,
		Code:     body.Code,
	}

	return v, nil
}

// BuildGetConversationHistoryPayload builds the payload for the assistant
// get_conversation_history endpoint from CLI flags.
func BuildGetConversationHistoryPayload(assistantGetConversationHistoryBody string) (*assistant.GetConversationHistoryPayload, error) {
	var err error
	var body GetConversationHistoryRequestBody
	{
		err = json.Unmarshal([]byte(assistantGetConversationHistoryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"flag\": true,\n      \"limit\": 7371898376364845327,\n      \"nums\": [\n         \"Quidem dolore dolorem aliquid numquam a quas.\",\n         \"Esse omnis velit id.\",\n         \"Animi odio eius.\"\n      ]\n   }'")
		}
	}
	v := &assistant.GetConversationHistoryPayload{
		Limit: body.Limit,
		Flag:  body.Flag,
	}
	if body.Nums != nil {
		v.Nums = make([]any, len(body.Nums))
		for i, val := range body.Nums {
			v.Nums[i] = val
		}
	}

	return v, nil
}

// BuildGeneratePromptsPayload builds the payload for the assistant
// generate_prompts endpoint from CLI flags.
func BuildGeneratePromptsPayload(assistantGeneratePromptsBody string) (*assistant.GeneratePromptsPayload, error) {
	var err error
	var body GeneratePromptsRequestBody
	{
		err = json.Unmarshal([]byte(assistantGeneratePromptsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": \"testing\",\n      \"task\": \"unit-test\"\n   }'")
		}
	}
	v := &assistant.GeneratePromptsPayload{
		Context: body.Context,
		Task:    body.Task,
	}

	return v, nil
}

// BuildSendNotificationPayload builds the payload for the assistant
// send_notification endpoint from CLI flags.
func BuildSendNotificationPayload(assistantSendNotificationBody string) (*assistant.SendNotificationPayload, error) {
	var err error
	var body SendNotificationRequestBody
	{
		err = json.Unmarshal([]byte(assistantSendNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"data\": \"At iste aliquid.\",\n      \"message\": \"Testing notification\",\n      \"type\": \"success\"\n   }'")
		}
		if !(body.Type == "info" || body.Type == "warning" || body.Type == "error" || body.Type == "success") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"info", "warning", "error", "success"}))
		}
		if utf8.RuneCountInString(body.Message) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.message", body.Message, utf8.RuneCountInString(body.Message), 1, true))
		}
		if utf8.RuneCountInString(body.Message) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.message", body.Message, utf8.RuneCountInString(body.Message), 2000, false))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.SendNotificationPayload{
		Type:    body.Type,
		Message: body.Message,
		Data:    body.Data,
	}

	return v, nil
}

// BuildSubscribeToUpdatesPayload builds the payload for the assistant
// subscribe_to_updates endpoint from CLI flags.
func BuildSubscribeToUpdatesPayload(assistantSubscribeToUpdatesBody string) (*assistant.SubscribeToUpdatesPayload, error) {
	var err error
	var body SubscribeToUpdatesRequestBody
	{
		err = json.Unmarshal([]byte(assistantSubscribeToUpdatesBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filter\": \"Eveniet voluptas.\",\n      \"resource\": \"documents\"\n   }'")
		}
		if !(body.Resource == "documents" || body.Resource == "conversation" || body.Resource == "system_info") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.resource", body.Resource, []any{"documents", "conversation", "system_info"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.SubscribeToUpdatesPayload{
		Resource: body.Resource,
		Filter:   body.Filter,
	}

	return v, nil
}

// BuildProcessBatchPayload builds the payload for the assistant process_batch
// endpoint from CLI flags.
func BuildProcessBatchPayload(assistantProcessBatchBody string) (*assistant.ProcessBatchPayload, error) {
	var err error
	var body ProcessBatchRequestBody
	{
		err = json.Unmarshal([]byte(assistantProcessBatchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"blob\": \"aGVsbG8=\",\n      \"format\": \"text\",\n      \"items\": [\n         \"item1\",\n         \"item2\"\n      ],\n      \"mimeType\": \"text/plain\",\n      \"uri\": \"system://info\"\n   }'")
		}
		if body.Items == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
		}
		if len(body.Items) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.items", body.Items, len(body.Items), 1, true))
		}
		if body.Format != nil {
			if !(*body.Format == "text" || *body.Format == "blob" || *body.Format == "uri") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"text", "blob", "uri"}))
			}
		}
		if body.URI != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.uri", *body.URI, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ProcessBatchPayload{
		Format:   body.Format,
		Blob:     body.Blob,
		URI:      body.URI,
		MimeType: body.MimeType,
	}
	if body.Items != nil {
		v.Items = make([]string, len(body.Items))
		for i, val := range body.Items {
			v.Items[i] = val
		}
	} else {
		v.Items = []string{}
	}

	return v, nil
}
