// Code generated by goa v3.22.2, DO NOT EDIT.
//
// assistant JSON-RPC client CLI support package
//
// Command:
// $ goa gen example.com/assistant/design

package client

import (
	"encoding/json"
	"fmt"

	assistant "example.com/assistant/gen/assistant"
	goa "goa.design/goa/v3/pkg"
)

// BuildAnalyzeTextPayload builds the payload for the assistant analyze_text
// endpoint from CLI flags.
func BuildAnalyzeTextPayload(assistantAnalyzeTextBody string) (*assistant.AnalyzeTextPayload, error) {
	var err error
	var body AnalyzeTextRequestBody
	{
		err = json.Unmarshal([]byte(assistantAnalyzeTextBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"mode\": \"sentiment\",\n      \"text\": \"Dolore atque qui possimus ipsam esse.\"\n   }'")
		}
		if !(body.Mode == "sentiment" || body.Mode == "keywords" || body.Mode == "summary") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.mode", body.Mode, []any{"sentiment", "keywords", "summary"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.AnalyzeTextPayload{
		Text: body.Text,
		Mode: body.Mode,
	}

	return v, nil
}

// BuildSearchKnowledgePayload builds the payload for the assistant
// search_knowledge endpoint from CLI flags.
func BuildSearchKnowledgePayload(assistantSearchKnowledgeBody string) (*assistant.SearchKnowledgePayload, error) {
	var err error
	var body SearchKnowledgeRequestBody
	{
		err = json.Unmarshal([]byte(assistantSearchKnowledgeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 8368102686863965314,\n      \"query\": \"Nihil eaque aspernatur commodi.\"\n   }'")
		}
	}
	v := &assistant.SearchKnowledgePayload{
		Query: body.Query,
		Limit: body.Limit,
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 10
		}
	}

	return v, nil
}

// BuildExecuteCodePayload builds the payload for the assistant execute_code
// endpoint from CLI flags.
func BuildExecuteCodePayload(assistantExecuteCodeBody string) (*assistant.ExecuteCodePayload, error) {
	var err error
	var body ExecuteCodeRequestBody
	{
		err = json.Unmarshal([]byte(assistantExecuteCodeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"code\": \"Aut exercitationem sequi.\",\n      \"language\": \"Sit debitis vel temporibus quia ea ipsa.\"\n   }'")
		}
	}
	v := &assistant.ExecuteCodePayload{
		Language: body.Language,
		Code:     body.Code,
	}

	return v, nil
}

// BuildGetConversationHistoryPayload builds the payload for the assistant
// get_conversation_history endpoint from CLI flags.
func BuildGetConversationHistoryPayload(assistantGetConversationHistoryBody string) (*assistant.GetConversationHistoryPayload, error) {
	var err error
	var body GetConversationHistoryRequestBody
	{
		err = json.Unmarshal([]byte(assistantGetConversationHistoryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"limit\": 512059023657992185\n   }'")
		}
	}
	v := &assistant.GetConversationHistoryPayload{
		Limit: body.Limit,
	}
	{
		var zero int
		if v.Limit == zero {
			v.Limit = 50
		}
	}

	return v, nil
}

// BuildGeneratePromptsPayload builds the payload for the assistant
// generate_prompts endpoint from CLI flags.
func BuildGeneratePromptsPayload(assistantGeneratePromptsBody string) (*assistant.GeneratePromptsPayload, error) {
	var err error
	var body GeneratePromptsRequestBody
	{
		err = json.Unmarshal([]byte(assistantGeneratePromptsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": \"Dolor sit.\",\n      \"task\": \"Dolores et sit ut et.\"\n   }'")
		}
	}
	v := &assistant.GeneratePromptsPayload{
		Context: body.Context,
		Task:    body.Task,
	}

	return v, nil
}

// BuildSendNotificationPayload builds the payload for the assistant
// send_notification endpoint from CLI flags.
func BuildSendNotificationPayload(assistantSendNotificationBody string) (*assistant.SendNotificationPayload, error) {
	var err error
	var body SendNotificationRequestBody
	{
		err = json.Unmarshal([]byte(assistantSendNotificationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"data\": \"Optio laborum.\",\n      \"message\": \"Omnis voluptate suscipit alias tempora.\",\n      \"type\": \"warning\"\n   }'")
		}
		if !(body.Type == "info" || body.Type == "warning" || body.Type == "error" || body.Type == "success") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"info", "warning", "error", "success"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.SendNotificationPayload{
		Type:    body.Type,
		Message: body.Message,
		Data:    body.Data,
	}

	return v, nil
}

// BuildSubscribeToUpdatesPayload builds the payload for the assistant
// subscribe_to_updates endpoint from CLI flags.
func BuildSubscribeToUpdatesPayload(assistantSubscribeToUpdatesBody string) (*assistant.SubscribeToUpdatesPayload, error) {
	var err error
	var body SubscribeToUpdatesRequestBody
	{
		err = json.Unmarshal([]byte(assistantSubscribeToUpdatesBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filter\": \"Commodi dolor et reprehenderit sunt.\",\n      \"resource\": \"Velit eos quos.\"\n   }'")
		}
	}
	v := &assistant.SubscribeToUpdatesPayload{
		Resource: body.Resource,
		Filter:   body.Filter,
	}

	return v, nil
}

// BuildProcessBatchPayload builds the payload for the assistant process_batch
// endpoint from CLI flags.
func BuildProcessBatchPayload(assistantProcessBatchBody string) (*assistant.ProcessBatchPayload, error) {
	var err error
	var body ProcessBatchRequestBody
	{
		err = json.Unmarshal([]byte(assistantProcessBatchBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"blob\": \"U2VkIHZlbGl0IHZvbHVwdGF0dW0gdWxsYW0gdG90YW0gdm9sdXB0YXRlcyB0b3RhbS4=\",\n      \"format\": \"text\",\n      \"items\": [\n         \"Eius corrupti impedit expedita.\",\n         \"Sint quos fuga.\",\n         \"Quo et velit odio quasi eum totam.\"\n      ],\n      \"mimeType\": \"Provident voluptas saepe impedit quia aut.\",\n      \"uri\": \"Voluptatem quam veniam et.\"\n   }'")
		}
		if body.Items == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
		}
		if body.Format != nil {
			if !(*body.Format == "text" || *body.Format == "blob" || *body.Format == "uri") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"text", "blob", "uri"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &assistant.ProcessBatchPayload{
		Format:   body.Format,
		Blob:     body.Blob,
		URI:      body.URI,
		MimeType: body.MimeType,
	}
	if body.Items != nil {
		v.Items = make([]string, len(body.Items))
		for i, val := range body.Items {
			v.Items[i] = val
		}
	} else {
		v.Items = []string{}
	}

	return v, nil
}
