// Code generated by goa v3.22.2, DO NOT EDIT.
//
// assistant SSE server streaming
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	assistant "example.com/assistant/gen/assistant"
	goahttp "goa.design/goa/v3/http"
	"goa.design/goa/v3/jsonrpc"
)

// assistantSSEStream implements the assistant.Stream interface for SSE
// transport.
type assistantSSEStream struct {
	// once ensures the headers are written once.
	once sync.Once
	// w is the HTTP response writer used to send the SSE events.
	w http.ResponseWriter
	// r is the HTTP request.
	r *http.Request
	// encoder is the response encoder.
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder
	// decoder is the request decoder.
	decoder func(*http.Request) goahttp.Decoder
}

// sseEventWriter wraps http.ResponseWriter to format output as SSE events.
type sseEventWriter struct {
	w         http.ResponseWriter
	eventType string
	started   bool
}

func (s *sseEventWriter) Header() http.Header        { return s.w.Header() }
func (s *sseEventWriter) WriteHeader(statusCode int) { s.w.WriteHeader(statusCode) }
func (s *sseEventWriter) Write(data []byte) (int, error) {
	if !s.started {
		s.started = true
		if s.eventType != "" {
			fmt.Fprintf(s.w, "event: %s\n", s.eventType)
		}
		s.w.Write([]byte("data: "))
	}
	return s.w.Write(data)
}

func (s *sseEventWriter) finish() {
	if s.started {
		s.w.Write([]byte("\n\n"))
		http.NewResponseController(s.w).Flush()
	}
}

// initSSEHeaders initializes the SSE response headers
func (s *assistantSSEStream) initSSEHeaders() {
	s.once.Do(func() {
		header := s.w.Header()
		header.Set("Content-Type", "text/event-stream")
		header.Set("Cache-Control", "no-cache")
		header.Set("Connection", "keep-alive")
		header.Set("X-Accel-Buffering", "no")
		s.w.WriteHeader(http.StatusOK)
	})
}

// sendSSEEvent sends a single SSE event by creating an encoder that writes to the event writer
func (s *assistantSSEStream) sendSSEEvent(eventType string, v any) error {
	s.initSSEHeaders()

	// Create SSE event writer that wraps the response writer
	ew := &sseEventWriter{w: s.w, eventType: eventType}

	// Create encoder with the event writer and encode the value
	err := s.encoder(context.Background(), ew).Encode(v)

	// Finish the SSE event (adds newlines and flushes)
	ew.finish()

	return err
}

// sendError sends a JSON-RPC error response to the SSE stream
func (s *assistantSSEStream) sendError(ctx context.Context, id any, code jsonrpc.Code, message string, data any) error {
	response := jsonrpc.MakeErrorResponse(id, code, message, data)
	return s.sendSSEEvent("error", response)
}

// Send sends an event (notification or response) to the client.
// For notifications, the result should not have an ID field.
// For responses, the result must have an ID field.
func (s *assistantSSEStream) Send(ctx context.Context, event assistant.Event) error {
	switch v := event.(type) {
	case *assistant.BatchResult:
		// Convert to response body type for proper JSON encoding
		body := NewProcessBatchResponseBody(v)

		// Check if this is a notification or response by looking for ID field
		var id string
		var isResponse bool

		var message map[string]any
		var eventType string

		if isResponse {
			// Send as response with ID
			resp := jsonrpc.MakeSuccessResponse(id, body)
			message = map[string]any{
				"jsonrpc": resp.JSONRPC,
				"id":      resp.ID,
				"result":  resp.Result,
			}
			eventType = "response"
		} else {
			// Send as notification (no ID)
			message = map[string]any{
				"jsonrpc": "2.0",
				"method":  "process_batch",
				"params":  body,
			}
			eventType = "notification"
		}

		return s.sendSSEEvent(eventType, message)
	default:
		return fmt.Errorf("unknown event type: %T", event)
	}
}
