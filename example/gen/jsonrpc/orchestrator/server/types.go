// Code generated by goa v3.22.6, DO NOT EDIT.
//
// orchestrator JSON-RPC server types
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"unicode/utf8"

	orchestrator "example.com/assistant/gen/orchestrator"
	goa "goa.design/goa/v3/pkg"
)

// RunRequestBody is the type of the "orchestrator" service "run" endpoint HTTP
// request body.
type RunRequestBody struct {
	// Agent identifier to invoke (optional when bound to a single agent)
	AgentID *string `form:"agent_id,omitempty" json:"agent_id,omitempty" xml:"agent_id,omitempty"`
	// Caller-provided run identifier
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Session identifier used for grouping runs
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty" xml:"session_id,omitempty"`
	// Turn identifier associated with the run
	TurnID *string `form:"turn_id,omitempty" json:"turn_id,omitempty" xml:"turn_id,omitempty"`
	// Complete conversation history supplied to the agent
	Messages []*AgentMessageRequestBody `form:"messages,omitempty" json:"messages,omitempty" xml:"messages,omitempty"`
	// Caller-supplied labels forwarded to the runtime
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// Arbitrary metadata forwarded to the runtime
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// RunResponseBody is the type of the "orchestrator" service "run" endpoint
// HTTP response body.
type RunResponseBody struct {
	// Identifier of the agent that produced the result
	AgentID string `form:"agent_id" json:"agent_id" xml:"agent_id"`
	// Identifier of the completed run
	RunID string `form:"run_id" json:"run_id" xml:"run_id"`
	// Final assistant response returned to the caller
	Final *AgentMessageResponseBody `form:"final" json:"final" xml:"final"`
	// Tool events emitted during the final turn
	ToolEvents []*AgentToolEventResponseBody `form:"tool_events,omitempty" json:"tool_events,omitempty" xml:"tool_events,omitempty"`
	// Planner annotations captured during completion
	Notes []*AgentPlannerAnnotationResponseBody `form:"notes,omitempty" json:"notes,omitempty" xml:"notes,omitempty"`
}

// AgentMessageResponseBody is used to define fields on response body types.
type AgentMessageResponseBody struct {
	// Role that produced the message
	Role string `form:"role" json:"role" xml:"role"`
	// Message content
	Content string `form:"content" json:"content" xml:"content"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// AgentToolEventResponseBody is used to define fields on response body types.
type AgentToolEventResponseBody struct {
	// Tool identifier
	Name string `form:"name" json:"name" xml:"name"`
	// Tool result payload when the call succeeds
	Payload any `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
	// Structured error returned by the tool
	Error *AgentToolErrorResponseBody `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Retry guidance emitted by the tool on failure
	RetryHint *AgentRetryHintResponseBody `form:"retry_hint,omitempty" json:"retry_hint,omitempty" xml:"retry_hint,omitempty"`
	// Telemetry metadata captured during execution
	Telemetry *AgentToolTelemetryResponseBody `form:"telemetry,omitempty" json:"telemetry,omitempty" xml:"telemetry,omitempty"`
}

// AgentToolErrorResponseBody is used to define fields on response body types.
type AgentToolErrorResponseBody struct {
	// Human-readable error summary
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Nested cause describing the underlying failure
	Cause *AgentToolErrorResponseBody `form:"cause,omitempty" json:"cause,omitempty" xml:"cause,omitempty"`
}

// AgentRetryHintResponseBody is used to define fields on response body types.
type AgentRetryHintResponseBody struct {
	// Categorized reason for the retry guidance
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// Qualified tool name associated with the hint
	Tool string `form:"tool" json:"tool" xml:"tool"`
	// Restrict subsequent planner turns to this tool
	RestrictToTool *bool `form:"restrict_to_tool,omitempty" json:"restrict_to_tool,omitempty" xml:"restrict_to_tool,omitempty"`
	// Missing or invalid fields that caused the failure
	MissingFields []string `form:"missing_fields,omitempty" json:"missing_fields,omitempty" xml:"missing_fields,omitempty"`
	// Representative payload that satisfies validation
	ExampleInput map[string]any `form:"example_input,omitempty" json:"example_input,omitempty" xml:"example_input,omitempty"`
	// Payload that triggered the failure
	PriorInput map[string]any `form:"prior_input,omitempty" json:"prior_input,omitempty" xml:"prior_input,omitempty"`
	// Question that callers should answer to proceed
	ClarifyingQuestion *string `form:"clarifying_question,omitempty" json:"clarifying_question,omitempty" xml:"clarifying_question,omitempty"`
	// Human-readable guidance for logs or UI
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// AgentToolTelemetryResponseBody is used to define fields on response body
// types.
type AgentToolTelemetryResponseBody struct {
	// Wall-clock duration in milliseconds
	DurationMs *int64 `form:"duration_ms,omitempty" json:"duration_ms,omitempty" xml:"duration_ms,omitempty"`
	// Total tokens consumed by the tool call
	TokensUsed *int `form:"tokens_used,omitempty" json:"tokens_used,omitempty" xml:"tokens_used,omitempty"`
	// Identifier of the model used by the tool
	Model *string `form:"model,omitempty" json:"model,omitempty" xml:"model,omitempty"`
	// Tool-specific telemetry key/value pairs
	Extra map[string]any `form:"extra,omitempty" json:"extra,omitempty" xml:"extra,omitempty"`
}

// AgentPlannerAnnotationResponseBody is used to define fields on response body
// types.
type AgentPlannerAnnotationResponseBody struct {
	// Annotation emitted by the planner
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
	// Structured metadata associated with the note
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
}

// AgentMessageRequestBody is used to define fields on request body types.
type AgentMessageRequestBody struct {
	// Role that produced the message
	Role *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// Message content
	Content *string `form:"content,omitempty" json:"content,omitempty" xml:"content,omitempty"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// NewRunResponseBody builds the HTTP response body from the result of the
// "run" endpoint of the "orchestrator" service.
func NewRunResponseBody(res *orchestrator.AgentRunResult) *RunResponseBody {
	body := &RunResponseBody{
		AgentID: res.AgentID,
		RunID:   res.RunID,
	}
	if res.Final != nil {
		body.Final = marshalOrchestratorAgentMessageToAgentMessageResponseBody(res.Final)
	}
	if res.ToolEvents != nil {
		body.ToolEvents = make([]*AgentToolEventResponseBody, len(res.ToolEvents))
		for i, val := range res.ToolEvents {
			if val == nil {
				body.ToolEvents[i] = nil
				continue
			}
			body.ToolEvents[i] = marshalOrchestratorAgentToolEventToAgentToolEventResponseBody(val)
		}
	}
	if res.Notes != nil {
		body.Notes = make([]*AgentPlannerAnnotationResponseBody, len(res.Notes))
		for i, val := range res.Notes {
			if val == nil {
				body.Notes[i] = nil
				continue
			}
			body.Notes[i] = marshalOrchestratorAgentPlannerAnnotationToAgentPlannerAnnotationResponseBody(val)
		}
	}
	return body
}

// NewRunAgentRunPayload builds a orchestrator service run endpoint payload.
func NewRunAgentRunPayload(body *RunRequestBody) *orchestrator.AgentRunPayload {
	v := &orchestrator.AgentRunPayload{
		AgentID:   body.AgentID,
		RunID:     body.RunID,
		SessionID: body.SessionID,
		TurnID:    body.TurnID,
	}
	v.Messages = make([]*orchestrator.AgentMessage, len(body.Messages))
	for i, val := range body.Messages {
		if val == nil {
			v.Messages[i] = nil
			continue
		}
		v.Messages[i] = unmarshalAgentMessageRequestBodyToOrchestratorAgentMessage(val)
	}
	if body.Labels != nil {
		v.Labels = make(map[string]string, len(body.Labels))
		for key, val := range body.Labels {
			tk := key
			tv := val
			v.Labels[tk] = tv
		}
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// ValidateRunRequestBody runs the validations defined on RunRequestBody
func ValidateRunRequestBody(body *RunRequestBody) (err error) {
	if body.Messages == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("messages", "body"))
	}
	if body.RunID != nil {
		if utf8.RuneCountInString(*body.RunID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.run_id", *body.RunID, utf8.RuneCountInString(*body.RunID), 1, true))
		}
	}
	if body.SessionID != nil {
		if utf8.RuneCountInString(*body.SessionID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.session_id", *body.SessionID, utf8.RuneCountInString(*body.SessionID), 1, true))
		}
	}
	if len(body.Messages) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.messages", body.Messages, len(body.Messages), 1, true))
	}
	for _, e := range body.Messages {
		if e != nil {
			if err2 := ValidateAgentMessageRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateAgentMessageRequestBody runs the validations defined on
// AgentMessageRequestBody
func ValidateAgentMessageRequestBody(body *AgentMessageRequestBody) (err error) {
	if body.Role == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("role", "body"))
	}
	if body.Content == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("content", "body"))
	}
	if body.Role != nil {
		if !(*body.Role == "user" || *body.Role == "assistant" || *body.Role == "tool" || *body.Role == "system") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"user", "assistant", "tool", "system"}))
		}
	}
	if body.Content != nil {
		if utf8.RuneCountInString(*body.Content) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", *body.Content, utf8.RuneCountInString(*body.Content), 1, true))
		}
	}
	return
}
