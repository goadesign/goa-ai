// Code generated by goa v3.22.6, DO NOT EDIT.
//
// orchestrator JSON-RPC server types
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"unicode/utf8"

	orchestrator "example.com/assistant/gen/orchestrator"
	goa "goa.design/goa/v3/pkg"
)

// RunRequestBody is the type of the "orchestrator" service "run" endpoint HTTP
// request body.
type RunRequestBody struct {
	// Agent identifier to invoke (optional when bound to a single agent)
	AgentID *string `form:"agent_id,omitempty" json:"agent_id,omitempty" xml:"agent_id,omitempty"`
	// Caller-provided run identifier
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Session identifier used for grouping runs
	SessionID *string `form:"session_id,omitempty" json:"session_id,omitempty" xml:"session_id,omitempty"`
	// Turn identifier associated with the run
	TurnID *string `form:"turn_id,omitempty" json:"turn_id,omitempty" xml:"turn_id,omitempty"`
	// Complete conversation history supplied to the agent
	Messages []*AgentMessageRequestBody `form:"messages,omitempty" json:"messages,omitempty" xml:"messages,omitempty"`
	// Caller-supplied labels forwarded to the runtime
	Labels map[string]string `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// Arbitrary metadata forwarded to the runtime
	Metadata map[string]any `form:"metadata,omitempty" json:"metadata,omitempty" xml:"metadata,omitempty"`
}

// RunResponseBody is the type of the "orchestrator" service "run" endpoint
// HTTP response body.
type RunResponseBody struct {
	// Kind of chunk being delivered
	Type string `form:"type" json:"type" xml:"type"`
	// Assistant message fragment.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Tool call scheduling notification.
	ToolCall *AgentToolCallChunkResponseBody `form:"tool_call,omitempty" json:"tool_call,omitempty" xml:"tool_call,omitempty"`
	// Tool result payload notification.
	ToolResult *AgentToolResultChunkResponseBody `form:"tool_result,omitempty" json:"tool_result,omitempty" xml:"tool_result,omitempty"`
	// Run status update.
	Status *AgentRunStatusChunkResponseBody `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// AgentToolCallChunkResponseBody is used to define fields on response body
// types.
type AgentToolCallChunkResponseBody struct {
	// Tool call identifier
	ID string `form:"id" json:"id" xml:"id"`
	// Tool name
	Name string `form:"name" json:"name" xml:"name"`
	// Payload submitted to the tool
	Payload any `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// AgentToolResultChunkResponseBody is used to define fields on response body
// types.
type AgentToolResultChunkResponseBody struct {
	// Tool call identifier
	ID string `form:"id" json:"id" xml:"id"`
	// Decoded tool result payload
	Result any `form:"result,omitempty" json:"result,omitempty" xml:"result,omitempty"`
	// Tool error, when the call failed
	Error *AgentToolErrorResponseBody `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
}

// AgentToolErrorResponseBody is used to define fields on response body types.
type AgentToolErrorResponseBody struct {
	// Human-readable error summary
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Nested cause describing the underlying failure
	Cause *AgentToolErrorResponseBody `form:"cause,omitempty" json:"cause,omitempty" xml:"cause,omitempty"`
}

// AgentRunStatusChunkResponseBody is used to define fields on response body
// types.
type AgentRunStatusChunkResponseBody struct {
	// Current run state
	State string `form:"state" json:"state" xml:"state"`
	// Optional status annotation
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// AgentMessageRequestBody is used to define fields on request body types.
type AgentMessageRequestBody struct {
	// Role that produced the message
	Role *string `form:"role,omitempty" json:"role,omitempty" xml:"role,omitempty"`
	// Message content
	Content *string `form:"content,omitempty" json:"content,omitempty" xml:"content,omitempty"`
	// Optional structured metadata attached to the message
	Meta map[string]any `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// NewRunResponseBody builds the HTTP response body from the result of the
// "run" endpoint of the "orchestrator" service.
func NewRunResponseBody(res *orchestrator.AgentRunChunk) *RunResponseBody {
	body := &RunResponseBody{
		Type:    res.Type,
		Message: res.Message,
	}
	if res.ToolCall != nil {
		body.ToolCall = marshalOrchestratorAgentToolCallChunkToAgentToolCallChunkResponseBody(res.ToolCall)
	}
	if res.ToolResult != nil {
		body.ToolResult = marshalOrchestratorAgentToolResultChunkToAgentToolResultChunkResponseBody(res.ToolResult)
	}
	if res.Status != nil {
		body.Status = marshalOrchestratorAgentRunStatusChunkToAgentRunStatusChunkResponseBody(res.Status)
	}
	return body
}

// NewRunAgentRunPayload builds a orchestrator service run endpoint payload.
func NewRunAgentRunPayload(body *RunRequestBody) *orchestrator.AgentRunPayload {
	v := &orchestrator.AgentRunPayload{
		AgentID:   body.AgentID,
		RunID:     body.RunID,
		SessionID: body.SessionID,
		TurnID:    body.TurnID,
	}
	v.Messages = make([]*orchestrator.AgentMessage, len(body.Messages))
	for i, val := range body.Messages {
		if val == nil {
			v.Messages[i] = nil
			continue
		}
		v.Messages[i] = unmarshalAgentMessageRequestBodyToOrchestratorAgentMessage(val)
	}
	if body.Labels != nil {
		v.Labels = make(map[string]string, len(body.Labels))
		for key, val := range body.Labels {
			tk := key
			tv := val
			v.Labels[tk] = tv
		}
	}
	if body.Metadata != nil {
		v.Metadata = make(map[string]any, len(body.Metadata))
		for key, val := range body.Metadata {
			tk := key
			tv := val
			v.Metadata[tk] = tv
		}
	}

	return v
}

// ValidateRunRequestBody runs the validations defined on RunRequestBody
func ValidateRunRequestBody(body *RunRequestBody) (err error) {
	if body.Messages == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("messages", "body"))
	}
	if body.RunID != nil {
		if utf8.RuneCountInString(*body.RunID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.run_id", *body.RunID, utf8.RuneCountInString(*body.RunID), 1, true))
		}
	}
	if body.SessionID != nil {
		if utf8.RuneCountInString(*body.SessionID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.session_id", *body.SessionID, utf8.RuneCountInString(*body.SessionID), 1, true))
		}
	}
	if len(body.Messages) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.messages", body.Messages, len(body.Messages), 1, true))
	}
	for _, e := range body.Messages {
		if e != nil {
			if err2 := ValidateAgentMessageRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateAgentMessageRequestBody runs the validations defined on
// AgentMessageRequestBody
func ValidateAgentMessageRequestBody(body *AgentMessageRequestBody) (err error) {
	if body.Role == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("role", "body"))
	}
	if body.Content == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("content", "body"))
	}
	if body.Role != nil {
		if !(*body.Role == "user" || *body.Role == "assistant" || *body.Role == "tool" || *body.Role == "system") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.role", *body.Role, []any{"user", "assistant", "tool", "system"}))
		}
	}
	if body.Content != nil {
		if utf8.RuneCountInString(*body.Content) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.content", *body.Content, utf8.RuneCountInString(*body.Content), 1, true))
		}
	}
	return
}
