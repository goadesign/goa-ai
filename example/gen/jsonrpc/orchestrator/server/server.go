// Code generated by goa v3.22.6, DO NOT EDIT.
//
// orchestrator JSON-RPC server
//
// Command:
// $ goa gen example.com/assistant/design

package server

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	orchestrator "example.com/assistant/gen/orchestrator"
	goahttp "goa.design/goa/v3/http"
	"goa.design/goa/v3/jsonrpc"
	goa "goa.design/goa/v3/pkg"
)

// Server handles JSON-RPC requests for the orchestrator service.
type Server struct {
	http.Handler
	// Methods is the list of methods served by this server.
	Methods []string

	// Run is the handler for the run method.
	Run func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error

	decoder    func(*http.Request) goahttp.Decoder
	encoder    func(context.Context, http.ResponseWriter) goahttp.Encoder
	errhandler func(context.Context, http.ResponseWriter, error)
}

// New creates a JSON-RPC server which loads HTTP requests and calls the
// "orchestrator" service methods.
func New(
	endpoints *orchestrator.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) *Server {
	s := &Server{
		Methods: []string{
			"run",
		},
		Run:        NewRunHandler(endpoints.Run, mux, decoder, encoder, errhandler),
		decoder:    decoder,
		encoder:    encoder,
		errhandler: errhandler,
	}
	// Default HTTP handler per transport kind
	// SSE-only services route via handleSSE
	s.Handler = http.HandlerFunc(s.handleSSE)
	return s
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "orchestrator" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.Handler = m(s.Handler)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return orchestrator.MethodNames[:] }

// handleSSE handles JSON-RPC SSE requests by dispatching to the appropriate method.
func (s *Server) handleSSE(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Read the JSON-RPC request
	var req jsonrpc.RawRequest
	if err := s.decoder(r).Decode(&req); err != nil {
		// Emit JSON-RPC parse error as SSE event
		stream := &orchestratorSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, nil, jsonrpc.ParseError, "Parse error", nil)
		return
	}

	// Validate JSON-RPC request
	if req.JSONRPC != "2.0" {
		stream := &orchestratorSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.InvalidRequest, "Invalid request", nil)
		return
	}

	if req.Method == "" {
		stream := &orchestratorSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.InvalidRequest, "Invalid request", nil)
		return
	}

	// Find the appropriate handler based on method name
	var handler func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error
	switch req.Method {
	case "run":
		handler = s.Run
	default:
		stream := &orchestratorSSEStream{w: w, r: r, encoder: s.encoder, decoder: s.decoder}
		_ = stream.sendError(ctx, req.ID, jsonrpc.MethodNotFound, "Method not found", nil)
		return
	}

	// Call the handler for the specific method
	if err := handler(ctx, r, &req, w); err != nil {
		s.errhandler(ctx, w, fmt.Errorf("handler error for %s: %w", req.Method, err))
		return
	}

	// For notifications (requests without ID) that don't stream, return 204 No Content
	switch req.Method {
	}
} // Mount configures the mux to serve the JSON-RPC orchestrator service methods.
func Mount(mux goahttp.Muxer, h *Server) {
	// SSE only: mount SSE handler
	mux.Handle("POST", "/orchestrator", h.handleSSE)
}

// Mount configures the mux to serve the JSON-RPC orchestrator service methods.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// NewRunHandler creates a JSON-RPC handler which calls the "orchestrator"
// service "run" endpoint.
func NewRunHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) func(context.Context, *http.Request, *jsonrpc.RawRequest, http.ResponseWriter) error {
	return func(ctx context.Context, r *http.Request, req *jsonrpc.RawRequest, w http.ResponseWriter) error {
		ctx = context.WithValue(ctx, goa.MethodKey, "run")
		ctx = context.WithValue(ctx, goa.ServiceKey, "orchestrator")
		// Initialize SSE stream early so decode errors can be sent as SSE error events
		strm := &RunServerStream{
			w:         w,
			r:         r,
			encoder:   encoder,
			requestID: req.ID,
		}
		decodeParams := DecodeRunRequest(mux, decoder)
		params, err := decodeParams(r, req)
		if err != nil {
			// Send error via SSE (JSON-RPC error event) to match SSE transport semantics
			if req.ID != nil && req.ID != "" {
				strm.SendError(ctx, jsonrpc.IDToString(req.ID), err)
			}
			return nil
		}
		v := &orchestrator.RunEndpointInput{
			Stream:  strm,
			Payload: params,
		}
		if _, err := endpoint(ctx, v); err != nil {
			// Send error response via SSE with proper JSON-RPC code mapping
			if req.ID != nil && req.ID != "" {
				var en goa.GoaErrorNamer
				if errors.As(err, &en) {
					switch en.GoaErrorName() {
					case "invalid_params":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.InvalidParams, err.Error(), nil)
					case "method_not_found":
						return strm.sendError(ctx, jsonrpc.IDToString(req.ID), jsonrpc.MethodNotFound, err.Error(), nil)
					}
				}
				// Fallback
				code := jsonrpc.InternalError
				if _, ok := err.(*goa.ServiceError); ok {
					code = jsonrpc.InvalidParams
				}
				return strm.sendError(ctx, jsonrpc.IDToString(req.ID), code, err.Error(), nil)
			}
			return nil
		}
		return nil
	}
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func (s *Server) encodeJSONRPCError(ctx context.Context, w http.ResponseWriter, req *jsonrpc.RawRequest, code jsonrpc.Code, message string, data any) {
	encodeJSONRPCError(ctx, w, req, code, message, data, s.encoder, s.errhandler)
}

// encodeJSONRPCError creates and sends a JSON-RPC error response (handles nil
// ID gracefully)
func encodeJSONRPCError(
	ctx context.Context,
	w http.ResponseWriter,
	req *jsonrpc.RawRequest,
	code jsonrpc.Code,
	message string,
	data any,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
) {
	if req.ID != nil {
		response := jsonrpc.MakeErrorResponse(req.ID, code, message, data)
		if err := encoder(ctx, w).Encode(response); err != nil {
			errhandler(ctx, w, fmt.Errorf("failed to encode JSON-RPC response: %w", err))
		}
	}
}
