// Package testutil provides utilities for golden file testing.
//
// It mirrors Goa's code generation golden testing approach with:
// - Global -update/-u flags to refresh goldens
// - Go/JSON aware formatting and normalization
// - Generated header version normalization (so headers don't cause diffs)
// - Simple assertion helpers and a fluent API
package testutil

import (
	"bytes"
	"encoding/json"
	"flag"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

// GoldenFile manages golden file comparisons using a fluent API.
type GoldenFile struct {
	t        testing.TB
	basePath string
	update   bool
	content  []byte
	path     string
}

// DefaultBasePath is the default directory for golden files when using
// NewGoldenFile with an empty base path.
const DefaultBasePath = "testdata/golden"

var (
	// update and u enable updating golden files when running tests.
	update = flag.Bool("update", false, "update golden files")
	u      = flag.Bool("u", false, "update golden files (shorthand)")

	// goHeaderVersionRE matches Goa's generated header that includes the version.
	goHeaderVersionRE = regexp.MustCompile(`(?m)^// Code generated by goa v[^,]+, DO NOT EDIT\.`)

	// protoHeaderVersionRE matches Goa's generated header for .proto files.
	protoHeaderVersionRE = regexp.MustCompile(`(?m)^// Code generated with goa v[^,]+, DO NOT EDIT\.`)
)

// NewGoldenFile creates a new GoldenFile. When basePath is empty, it defaults
// to DefaultBasePath.
func NewGoldenFile(t testing.TB, basePath string) *GoldenFile {
	t.Helper()
	bp := basePath
	if bp == "" {
		bp = DefaultBasePath
	}
	return &GoldenFile{
		t:        t,
		basePath: bp,
	}
}

// CompareOrUpdateGolden is a convenience helper for direct string content.
// It accepts either absolute or relative golden file paths.
func CompareOrUpdateGolden(t *testing.T, actual, golden string) {
	t.Helper()
	gf := NewGoldenFile(t, "")
	abs := golden
	if !filepath.IsAbs(abs) {
		if p, err := filepath.Abs(abs); err == nil {
			abs = p
		}
	}
	gf.StringContent(actual).Path(abs).CompareContent()
}

// Assert compares byte content against a golden file.
func Assert(t testing.TB, goldenPath string, got []byte) {
	t.Helper()
	gf := &GoldenFile{t: t, basePath: ""}
	gf.Content(got).Path(goldenPath).CompareContent()
}

// AssertString compares string content against a golden file.
func AssertString(t testing.TB, goldenPath string, got string) {
	t.Helper()
	gf := &GoldenFile{t: t, basePath: ""}
	gf.StringContent(got).Path(goldenPath).CompareContent()
}

// AssertJSON pretty-prints and compares JSON content.
func AssertJSON(t testing.TB, goldenPath string, got []byte) {
	t.Helper()
	var v any
	if err := json.Unmarshal(got, &v); err == nil {
		if formatted, err := json.MarshalIndent(v, "", "  "); err == nil {
			got = formatted
		}
	}
	gf := &GoldenFile{t: t, basePath: ""}
	gf.Content(got).Path(goldenPath).CompareContent()
}

// AssertGo formats and compares Go source code.
func AssertGo(t testing.TB, goldenPath string, got string) {
	t.Helper()
	formatted := []byte(got)
	if src, err := format.Source([]byte(got)); err == nil {
		formatted = src
	}
	gf := &GoldenFile{t: t, basePath: ""}
	gf.Content(formatted).Path(goldenPath).CompareContent()
}

// Content sets the comparison content.
func (g *GoldenFile) Content(content []byte) *GoldenFile {
	g.content = content
	return g
}

// StringContent sets the comparison content from a string.
func (g *GoldenFile) StringContent(content string) *GoldenFile {
	return g.Content([]byte(content))
}

// Path sets the golden file path (absolute or relative to basePath).
func (g *GoldenFile) Path(path string) *GoldenFile {
	g.path = path
	return g
}

// SetUpdateMode forces update behavior for this instance (independent of flags).
func (g *GoldenFile) SetUpdateMode(update bool) { g.update = update }

// Exists reports whether the golden file exists at the given path.
func (g *GoldenFile) Exists(golden string) bool {
	goldenPath := golden
	if !filepath.IsAbs(golden) {
		goldenPath = filepath.Join(g.basePath, golden)
	}
	_, err := os.Stat(goldenPath)
	return err == nil
}

// CompareContent compares the prepared content against the golden file.
func (g *GoldenFile) CompareContent() {
	g.t.Helper()

	if g.path == "" {
		g.t.Fatal("golden file path not set")
	}
	if g.content == nil {
		g.t.Fatal("content not set")
	}

	goldenPath := g.path
	if !filepath.IsAbs(g.path) && g.basePath != "" {
		goldenPath = filepath.Join(g.basePath, g.path)
	}

	content := g.prepareContent()
	if g.update || isUpdateMode() {
		g.updateFile(content, goldenPath)
		return
	}

	if _, err := os.Stat(goldenPath); os.IsNotExist(err) {
		g.t.Fatalf("golden file %q does not exist (run with -update to create)", goldenPath)
	}

	g.compareContent(content, goldenPath)
}

// Compare provides a legacy API: compare string content with a golden file path.
func (g *GoldenFile) Compare(actual string, golden string) {
	g.t.Helper()
	g.StringContent(actual).Path(golden).CompareContent()
}

// CompareBytes is like Compare but for byte slices.
func (g *GoldenFile) CompareBytes(actual []byte, golden string) {
	g.t.Helper()
	g.Content(actual).Path(golden).CompareContent()
}

// isUpdateMode reports whether golden update mode is enabled.
func isUpdateMode() bool {
	return *update || *u
}

// normalizeGoHeader replaces versioned headers with a stable placeholder.
func normalizeGoHeader(b []byte) []byte {
	return goHeaderVersionRE.ReplaceAll(b, []byte("// Code generated by goa vX, DO NOT EDIT."))
}

// normalizeProtoHeader replaces versioned headers in .proto files.
func normalizeProtoHeader(b []byte) []byte {
	return protoHeaderVersionRE.ReplaceAll(b, []byte("// Code generated with goa vX, DO NOT EDIT."))
}

// prepareContent normalizes and formats content for stable comparisons.
func (g *GoldenFile) prepareContent() []byte {
	content := g.content

	// JSON pretty-printing.
	if strings.HasSuffix(g.path, ".json") || strings.HasSuffix(g.path, ".json.golden") {
		var v any
		if err := json.Unmarshal(content, &v); err == nil {
			if formatted, err := json.MarshalIndent(v, "", "  "); err == nil {
				content = formatted
			}
		}
	}

	// Best-effort Go formatting and header normalization.
	if formatted, err := format.Source(content); err == nil {
		content = formatted
		content = normalizeGoHeader(content)
	}

	// Normalize proto headers too.
	content = normalizeProtoHeader(content)

	// Normalize line endings and trim trailing whitespace.
	content = bytes.ReplaceAll(content, []byte("\r\n"), []byte("\n"))
	lines := strings.Split(string(content), "\n")
	for i, line := range lines {
		lines[i] = strings.TrimRight(line, " \t")
	}
	content = []byte(strings.Join(lines, "\n"))
	if len(content) > 0 && content[len(content)-1] != '\n' {
		content = append(content, '\n')
	}

	return content
}

func (g *GoldenFile) updateFile(content []byte, goldenPath string) {
	g.t.Helper()

	dir := filepath.Dir(goldenPath)
	if err := os.MkdirAll(dir, 0o750); err != nil {
		g.t.Fatalf("failed to create golden file directory %q: %v", dir, err)
	}
	if err := os.WriteFile(goldenPath, content, 0600); err != nil {
		g.t.Fatalf("failed to update golden file %q: %v", goldenPath, err)
	}
	g.t.Logf("Updated golden file: %s", goldenPath)
}

func (g *GoldenFile) compareContent(content []byte, goldenPath string) {
	g.t.Helper()

	golden, err := os.ReadFile(goldenPath) //nolint:gosec // this is a test file
	if err != nil {
		g.t.Fatalf("failed to read golden file %q: %v", goldenPath, err)
	}

	// Apply similar normalization to golden content.
	golden = bytes.ReplaceAll(golden, []byte("\r\n"), []byte("\n"))
	lines := strings.Split(string(golden), "\n")
	for i, line := range lines {
		lines[i] = strings.TrimRight(line, " \t")
	}
	golden = []byte(strings.Join(lines, "\n"))
	if len(golden) > 0 && golden[len(golden)-1] != '\n' {
		golden = append(golden, '\n')
	}

	if formatted, err := format.Source(golden); err == nil {
		golden = formatted
		golden = normalizeGoHeader(golden)
	}
	golden = normalizeProtoHeader(golden)

	if !bytes.Equal(content, golden) {
		require.Equalf(g.t, string(golden), string(content), "golden file mismatch for %q", goldenPath)
		g.t.Logf("Run with -update to update the golden file")
	}
}
