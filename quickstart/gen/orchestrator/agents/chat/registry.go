// Code generated by goa v3.24.1, DO NOT EDIT.
//
// ChatAgent registry
//
// Command:
// $ goa gen example.com/quickstart/design

package chat

import (
	"context"
	"errors"
	"fmt"
	"time"

	specs "example.com/quickstart/gen/orchestrator/agents/chat/specs"
	"goa.design/goa-ai/runtime/agent/engine"
	"goa.design/goa-ai/runtime/agent/planner"
	agentsruntime "goa.design/goa-ai/runtime/agent/runtime"
	hints "goa.design/goa-ai/runtime/agent/runtime/hints"
	"goa.design/goa-ai/runtime/agent/tools"
)

// RegisterChatAgent registers the generated agent components with the runtime.
func RegisterChatAgent(ctx context.Context, rt *agentsruntime.Runtime, cfg ChatAgentConfig) error {
	if rt == nil {
		return errors.New("runtime is required")
	}
	agent, err := NewChatAgent(cfg)
	if err != nil {
		return err
	}
	if err := rt.RegisterAgent(ctx, agentsruntime.AgentRegistration{
		ID:      "orchestrator.chat",
		Planner: agent.Planner,
		Workflow: engine.WorkflowDefinition{
			Name:      "orchestrator.chat.workflow",
			TaskQueue: "orchestrator_chat_workflow",
			Handler:   rt.ExecuteWorkflow,
		},
		PlanActivityName: "orchestrator.chat.plan",
		PlanActivityOptions: engine.ActivityOptions{
			Queue:   "orchestrator_chat_workflow",
			Timeout: time.Duration(120000000000),
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts:        3,
				InitialInterval:    time.Duration(1000000000),
				BackoffCoefficient: 2,
			},
		},
		ResumeActivityName: "orchestrator.chat.resume",
		ResumeActivityOptions: engine.ActivityOptions{
			Queue:   "orchestrator_chat_workflow",
			Timeout: time.Duration(120000000000),
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts:        3,
				InitialInterval:    time.Duration(1000000000),
				BackoffCoefficient: 2,
			},
		},
		ExecuteToolActivity: "orchestrator.chat.executetool",
		ExecuteToolActivityOptions: engine.ActivityOptions{
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts: 1,
			},
		},
		Specs: specs.Specs,
		Policy: agentsruntime.RunPolicy{
			MaxToolCalls:                  2,
			MaxConsecutiveFailedToolCalls: 1,
			TimeBudget:                    time.Duration(15000000000),
		},
	}); err != nil {
		return err
	}

	// Service-backed toolsets (method-backed Used toolsets) are registered by
	// application code using executors. Agent-exported toolsets are wired via
	// provider agenttools helpers and consumer-side agent toolset helpers.
	return nil
}

// RegisterUsedToolsets registers all non-MCP Used toolsets for this agent.
// Provide executors via typed options for each required toolset.
//
// Example:
//
//	err := RegisterUsedToolsets(ctx, rt,
//	    WithHelpersExecutor(exec),
//	)
func RegisterUsedToolsets(ctx context.Context, rt *agentsruntime.Runtime, opts ...func(map[string]agentsruntime.ToolCallExecutor)) error {
	if rt == nil {
		return errors.New("runtime is required")
	}
	execs := make(map[string]agentsruntime.ToolCallExecutor)
	for _, o := range opts {
		if o != nil {
			o(execs)
		}
	}
	// Register non-MCP used toolsets that are not provided by agent-as-tool exports.
	{
		const toolsetID = "orchestrator.helpers"
		exec := execs[toolsetID]
		reg := agentsruntime.ToolsetRegistration{
			Name:  toolsetID,
			Specs: specs.Specs,
			Execute: func(ctx context.Context, call *planner.ToolRequest) (*planner.ToolResult, error) {
				if call == nil {
					return nil, fmt.Errorf("tool request is nil")
				}
				if exec == nil {
					return &planner.ToolResult{
						Error: planner.NewToolError(
							fmt.Sprintf(
								"no executor registered for toolset %q; ensure the appropriate With...Executor is wired in RegisterUsedToolsets",
								toolsetID,
							),
						),
					}, nil
				}
				meta := &agentsruntime.ToolCallMeta{
					RunID:            call.RunID,
					SessionID:        call.SessionID,
					TurnID:           call.TurnID,
					ToolCallID:       call.ToolCallID,
					ParentToolCallID: call.ParentToolCallID,
				}
				result, err := exec.Execute(ctx, meta, call)
				if err != nil {
					return nil, err
				}
				if result == nil {
					return nil, fmt.Errorf("executor returned nil result")
				}
				return result, nil
			},
		}
		// Install DSL-provided hint templates when present.
		{
			// Build maps only when at least one template exists to avoid overhead.
			var callRaw map[tools.Ident]string
			var resultRaw map[tools.Ident]string
			if len(callRaw) > 0 {
				compiled, err := hints.CompileHintTemplates(callRaw, nil)
				if err != nil {
					return err
				}
				reg.CallHints = compiled
			}
			if len(resultRaw) > 0 {
				compiled, err := hints.CompileHintTemplates(resultRaw, nil)
				if err != nil {
					return err
				}
				reg.ResultHints = compiled
			}
		}
		if err := rt.RegisterToolset(reg); err != nil {
			return err
		}
	}
	return nil
}

// WithHelpersExecutor associates an executor for orchestrator.helpers.
func WithHelpersExecutor(exec agentsruntime.ToolCallExecutor) func(map[string]agentsruntime.ToolCallExecutor) {
	return func(m map[string]agentsruntime.ToolCallExecutor) {
		if exec == nil {
			return
		}
		m["orchestrator.helpers"] = exec
	}
}
