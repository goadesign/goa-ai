// Code generated by goa v3.23.4, DO NOT EDIT.
//
// helpers tool specs
//
// Command:
// $ goa gen example.com/quickstart/design

package helpers

import (
	"sort"

	"goa.design/goa-ai/runtime/agent/policy"
	"goa.design/goa-ai/runtime/agent/tools"
)

// Tool IDs for this toolset.
const (
	Answer tools.Ident = "helpers.answer"
)

var Specs = []tools.ToolSpec{
	{
		Name:          Answer,
		Service:       "orchestrator",
		Toolset:       "orchestrator.helpers",
		Description:   "Answer a simple question",
		Tags:          []string{},
		BoundedResult: false,
		Payload: tools.TypeSpec{
			Name:        "AnswerPayload",
			Schema:      []byte("{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"title\":\"AskPayload\",\"type\":\"object\",\"properties\":{\"question\":{\"type\":\"string\",\"description\":\"User question to answer\",\"example\":\"Labore natus exercitationem et omnis.\"}},\"example\":{\"question\":\"What is the capital of Japan?\"},\"required\":[\"question\"]}"),
			ExampleJSON: []byte("{\"question\":\"What is the capital of Japan?\"}"),
			Codec:       answerPayloadCodec,
		},
		Result: tools.TypeSpec{
			Name:   "AnswerResult",
			Schema: []byte("{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"title\":\"Answer\",\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\",\"description\":\"Answer text\",\"example\":\"Dolor ea vel quia vero quo.\"}},\"example\":{\"text\":\"Pariatur cum vel provident natus dolores.\"},\"required\":[\"text\"]}"),
			Codec:  answerResultCodec,
		},
		Sidecar: nil,
	},
}

var (
	specIndex = make(map[tools.Ident]*tools.ToolSpec, len(Specs))
	metadata  = []policy.ToolMetadata{
		{
			ID:          Answer,
			Title:       "Answer",
			Description: "Answer a simple question",
			Tags:        []string{},
		},
	}
)

func init() {
	for i := range Specs {
		spec := &Specs[i]
		specIndex[spec.Name] = spec
	}
}

// Names returns the identifiers of all generated tools.
func Names() []tools.Ident {
	names := make([]tools.Ident, 0, len(specIndex))
	for name := range specIndex {
		names = append(names, name)
	}
	sort.Slice(names, func(i, j int) bool { return string(names[i]) < string(names[j]) })
	return names
}

// Spec returns the specification for the named tool if present.
func Spec(name tools.Ident) (*tools.ToolSpec, bool) {
	spec, ok := specIndex[name]
	return spec, ok
}

// PayloadSchema returns the JSON schema for the named tool payload.
func PayloadSchema(name tools.Ident) ([]byte, bool) {
	spec, ok := specIndex[name]
	if !ok {
		return nil, false
	}
	return spec.Payload.Schema, true
}

// ResultSchema returns the JSON schema for the named tool result.
func ResultSchema(name tools.Ident) ([]byte, bool) {
	spec, ok := specIndex[name]
	if !ok {
		return nil, false
	}
	return spec.Result.Schema, true
}

// Metadata exposes policy metadata for the generated tools.
func Metadata() []policy.ToolMetadata {
	out := make([]policy.ToolMetadata, len(metadata))
	copy(out, metadata)
	return out
}
