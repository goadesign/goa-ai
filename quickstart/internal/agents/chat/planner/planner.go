// Code generated by goa v3.24.0, DO NOT EDIT.
//
// Planner stub for ChatAgent
//
// Command:
// $ goa example example.com/quickstart/design

package planner

import (
	"context"

	model "goa.design/goa-ai/runtime/agent/model"
	"goa.design/goa-ai/runtime/agent/planner"
)

// New returns a minimal planner implementation for Chat used by example bootstrap.
// Replace with your production planner integrating your LLM of choice.
func New() planner.Planner { return &examplePlanner{} }

// examplePlanner is a minimal, stateless implementation of planner.Planner used by
// the example bootstrap. The planner acts as the agent's "brain": it reasons over
// conversation messages, decides whether to request tool executions, and produces
// final assistant responses. Production planners typically invoke LLMs via
// registered model clients (in.Agent.ModelClient(...)), emit intermediate
// messages/notes for streaming, and integrate tool results in PlanResume.
type examplePlanner struct{}

func (p *examplePlanner) Decide(ctx context.Context, tool string) string {
	return "reason"
}

func (p *examplePlanner) PlanStart(ctx context.Context, in *planner.PlanInput) (*planner.PlanResult, error) {
	// Check for deterministic routing (Passthrough)
	if in.RunContext.Tool != "" {
		route := p.Decide(ctx, string(in.RunContext.Tool))
		if route == "passthrough" {
			// Deterministic passthrough: forward args directly to the target tool.
			// For this example stub, we don't have the target mapping (it's in the DSL but not fully exposed here yet).
			// Real implementation would use the Passthrough metadata to construct the ToolRequest.
			// This stub just falls through to the default response.
		}
	}

	return &planner.PlanResult{
		FinalResponse: &planner.FinalResponse{
			Message: &model.Message{
				Role:  model.ConversationRoleAssistant,
				Parts: []model.Part{model.TextPart{Text: "Hello from example planner."}},
			},
		},
	}, nil
}

func (p *examplePlanner) PlanResume(ctx context.Context, in *planner.PlanResumeInput) (*planner.PlanResult, error) {
	return &planner.PlanResult{
		FinalResponse: &planner.FinalResponse{
			Message: &model.Message{
				Role:  model.ConversationRoleAssistant,
				Parts: []model.Part{model.TextPart{Text: "Done."}},
			},
		},
	}, nil
}
