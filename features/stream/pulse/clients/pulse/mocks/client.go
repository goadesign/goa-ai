// Code generated by Clue Mock Generator v1.2.3, DO NOT EDIT.
//
// Command:
// $ cmg gen goa.design/goa-ai/features/stream/pulse/clients/pulse

package mockpulse

import (
	"context"
	"testing"

	"goa.design/clue/mock"
	"goa.design/pulse/streaming"
	"goa.design/pulse/streaming/options"

	"goa.design/goa-ai/features/stream/pulse/clients/pulse"
)

type (
	Client struct {
		m *mock.Mock
		t *testing.T
	}

	ClientStreamFunc func(name string) (pulse.Stream, error)
	ClientCloseFunc  func(ctx context.Context) error

	Stream struct {
		m *mock.Mock
		t *testing.T
	}

	StreamAddFunc     func(ctx context.Context, event string, payload []byte) (string, error)
	StreamNewSinkFunc func(ctx context.Context, name string, opts ...options.Sink) (pulse.Sink, error)
	StreamDestroyFunc func(ctx context.Context) error

	Sink struct {
		m *mock.Mock
		t *testing.T
	}

	SinkSubscribeFunc func() <-chan *streaming.Event
	SinkAckFunc       func(p0 context.Context, p1 *streaming.Event) error
	SinkCloseFunc     func(p0 context.Context)
)

func NewClient(t *testing.T) *Client {
	var (
		m              = &Client{mock.New(), t}
		_ pulse.Client = m
	)
	return m
}

func (m *Client) AddStream(f ClientStreamFunc) {
	m.m.Add("Stream", f)
}

func (m *Client) SetStream(f ClientStreamFunc) {
	m.m.Set("Stream", f)
}

func (m *Client) Stream(name string) (pulse.Stream, error) {
	if f := m.m.Next("Stream"); f != nil {
		return f.(ClientStreamFunc)(name)
	}
	m.t.Helper()
	m.t.Error("unexpected Stream call")
	return nil, nil
}

func (m *Client) AddClose(f ClientCloseFunc) {
	m.m.Add("Close", f)
}

func (m *Client) SetClose(f ClientCloseFunc) {
	m.m.Set("Close", f)
}

func (m *Client) Close(ctx context.Context) error {
	if f := m.m.Next("Close"); f != nil {
		return f.(ClientCloseFunc)(ctx)
	}
	m.t.Helper()
	m.t.Error("unexpected Close call")
	return nil
}

func (m *Client) HasMore() bool {
	return m.m.HasMore()
}

func NewStream(t *testing.T) *Stream {
	var (
		m              = &Stream{mock.New(), t}
		_ pulse.Stream = m
	)
	return m
}

func (m *Stream) AddAdd(f StreamAddFunc) {
	m.m.Add("Add", f)
}

func (m *Stream) SetAdd(f StreamAddFunc) {
	m.m.Set("Add", f)
}

func (m *Stream) Add(ctx context.Context, event string, payload []byte) (string, error) {
	if f := m.m.Next("Add"); f != nil {
		return f.(StreamAddFunc)(ctx, event, payload)
	}
	m.t.Helper()
	m.t.Error("unexpected Add call")
	return "", nil
}

func (m *Stream) AddNewSink(f StreamNewSinkFunc) {
	m.m.Add("NewSink", f)
}

func (m *Stream) SetNewSink(f StreamNewSinkFunc) {
	m.m.Set("NewSink", f)
}

func (m *Stream) NewSink(ctx context.Context, name string, opts ...options.Sink) (pulse.Sink, error) {
	if f := m.m.Next("NewSink"); f != nil {
		return f.(StreamNewSinkFunc)(ctx, name, opts...)
	}
	m.t.Helper()
	m.t.Error("unexpected NewSink call")
	return nil, nil
}

func (m *Stream) AddDestroy(f StreamDestroyFunc) {
	m.m.Add("Destroy", f)
}

func (m *Stream) SetDestroy(f StreamDestroyFunc) {
	m.m.Set("Destroy", f)
}

func (m *Stream) Destroy(ctx context.Context) error {
	if f := m.m.Next("Destroy"); f != nil {
		return f.(StreamDestroyFunc)(ctx)
	}
	m.t.Helper()
	m.t.Error("unexpected Destroy call")
	return nil
}

func (m *Stream) HasMore() bool {
	return m.m.HasMore()
}

func NewSink(t *testing.T) *Sink {
	var (
		m            = &Sink{mock.New(), t}
		_ pulse.Sink = m
	)
	return m
}

func (m *Sink) AddSubscribe(f SinkSubscribeFunc) {
	m.m.Add("Subscribe", f)
}

func (m *Sink) SetSubscribe(f SinkSubscribeFunc) {
	m.m.Set("Subscribe", f)
}

func (m *Sink) Subscribe() <-chan *streaming.Event {
	if f := m.m.Next("Subscribe"); f != nil {
		return f.(SinkSubscribeFunc)()
	}
	m.t.Helper()
	m.t.Error("unexpected Subscribe call")
	return nil
}

func (m *Sink) AddAck(f SinkAckFunc) {
	m.m.Add("Ack", f)
}

func (m *Sink) SetAck(f SinkAckFunc) {
	m.m.Set("Ack", f)
}

func (m *Sink) Ack(p0 context.Context, p1 *streaming.Event) error {
	if f := m.m.Next("Ack"); f != nil {
		return f.(SinkAckFunc)(p0, p1)
	}
	m.t.Helper()
	m.t.Error("unexpected Ack call")
	return nil
}

func (m *Sink) AddClose(f SinkCloseFunc) {
	m.m.Add("Close", f)
}

func (m *Sink) SetClose(f SinkCloseFunc) {
	m.m.Set("Close", f)
}

func (m *Sink) Close(p0 context.Context) {
	if f := m.m.Next("Close"); f != nil {
		f.(SinkCloseFunc)(p0)
		return
	}
	m.t.Helper()
	m.t.Error("unexpected Close call")
}

func (m *Sink) HasMore() bool {
	return m.m.HasMore()
}
