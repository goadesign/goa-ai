# Model Gateway (goa-ai) — Action Items & Checklist

Purpose: Introduce an elegant, composable “inference gateway” pattern in goa-ai so apps can centralize provider behavior behind a Goa service while planners continue using the provider-agnostic `model.Client` API.

This document tracks the work across goa-ai (core) and AURA (consumer). Keep it up-to-date by ticking checkboxes and adding notes as work completes.

---

## 1) API Types (goa-ai) — Provider-Agnostic Model Types

Add design-time types so transports can expose a model gateway without bespoke app DTOs.

- [ ] Create `apitypes/design/model.go` with:
  - [ ] `LLMMessage` (role, content)
  - [ ] `ToolDefinition` (name, description, input_schema)
  - [ ] `LLMRequest` (model, messages, tools, temperature, max_tokens[, thinking])
  - [ ] `LLMChunk` (type: text/tool_call/usage/stop; message/tool_name/tool_payload/input_tokens/output_tokens/stop_reason)
- [ ] Generated conversions:
  - [ ] `CreateFrom(model.Request)` / `ConvertTo(model.Request)` (and for message, tools)
  - [ ] `CreateFrom(model.Chunk)` / `ConvertTo(model.Chunk)`
- [ ] `CreateFrom(model.Response)` (optional; join text into a single `LLMMessage` for unary)
- [ ] Docs & examples embedded in DSL (`Description`, `Example`, validations)
- [ ] Unit tests for conversions (round-trip sanity)

Notes:
- These types are transport DTOs only; planners continue to use runtime `model.*` directly.

---

## 2) Gateway Server (goa-ai) — Minimal Adapter + Middleware

Provide a small, composable server wrapper that converts DTOs ↔ `model.*`, runs middleware, and calls a provider client.

Deliverables (package: `features/model/gateway`):

- [ ] Middleware interfaces (server-side)
  - [ ] `type UnaryHandler func(ctx context.Context, req model.Request) (model.Response, error)`
  - [ ] `type UnaryMiddleware func(next UnaryHandler) UnaryHandler`
  - [ ] `type StreamHandler func(ctx context.Context, req model.Request, send func(model.Chunk) error) error`
  - [ ] `type StreamMiddleware func(next StreamHandler) StreamHandler`
- [ ] Options & constructor
  - [ ] `func NewServer(opts ...Option) (*Server, error)`
  - [ ] `WithProvider(p model.Client)` (required)
  - [ ] `WithUnary(mw ...UnaryMiddleware)`
  - [ ] `WithStream(mw ...StreamMiddleware)`
  - [ ] `WithCodec(c Codec)` (override DTO↔model conversion)
  - [ ] `WithErrorMapper(f func(error) error)`
- [ ] Core handlers (no policy baked in)
- [ ] Unary: convert `LLMRequest` → `model.Request`, run unary chain, convert `model.Response` → `LLMMessage`
- [ ] Stream: convert `LLMRequest` → `model.Request`, run stream chain, adapt `model.Chunk` → `LLMChunk` via `send` callback
- [ ] Reference middlewares (optional, opt-in)
  - [ ] Logging, Metrics, Retry/Backoff, RateLimit, Safety/Redaction, Policy (tool allowlists/clarify-only), Thinking negotiation
- [ ] Tests (unit + table-driven)

Notes:
- Transport glue is generated by Goa. The adapter is pure business logic called by the service impl.

---

## 3) Remote Client (goa-ai) — `model.Client` Over Gateway

Let planners use a remote gateway transparently via the same `model.Client` API.

- [ ] Implement `RemoteClient` (package: `features/model/gateway`)
  - [ ] `Complete(ctx, req model.Request) (model.Response, error)`
  - [ ] `Stream(ctx, req model.Request) (model.Streamer, error)`
  - [ ] Convert runtime `model.*` ↔ DTOs using generated conversions
  - [ ] Handle `ErrStreamingUnsupported` gracefully (optionally degrade to unary)
- [ ] Client middlewares (optional): retry, breaker, auth
- [ ] Tests (mocks for generated client)

---

## 4) Docs & Examples (goa-ai)

- [ ] New doc: `docs/model_gateway.md`
  - [ ] Pattern overview: local provider vs remote gateway
  - [ ] How to register provider: `rt.RegisterModel("default", bedrockClient)`
  - [ ] How to register remote: `rt.RegisterModel("default", modelgateway.NewRemoteClient(...))`
  - [ ] Server wiring: `NewServer(WithProvider(...), WithUnary(...), WithStream(...))`
  - [ ] Custom middleware examples (RateLimit, Policy, Safety)
- [ ] Example module: tiny service exposing gateway + tiny client that streams
- [ ] Cross-link from `docs/runtime.md`, `docs/dsl.md`

---

## 5) Integration Tests (goa-ai)

- [ ] E2E: gateway server using Bedrock/OpenAI fake provider → client streams → verify chunks & tool calls
- [ ] Middleware behavior: enforce allowlist, simulate `ErrStreamingUnsupported` fallback

---

## 6) AURA Adoption (consumer repo)

- [ ] Remove bespoke inference RPC DTOs (BR* types) in favor of gateway DTOs (if transport retained) or pure runtime model.Client
- [ ] If keeping a gateway service in AURA:
  - [ ] Replace service design payloads/results with `apitypes/design/model.*`
  - [ ] Service impl: wrap a provider using goa-ai gateway `NewServer`
  - [ ] Consumer clients: use `modelgateway.NewRemoteClient` and `rt.RegisterModel("default", ...)`
- [ ] If removing transport boundary:
  - [ ] Register provider directly with runtime (`RegisterModel`)
  - [ ] Planners switch to `agent.ModelClient("default")` (if not already)
- [ ] Orchestrator remains on `AgentRunPayload/AgentRunChunk` (no change)
- [ ] Front consumes `AgentRunChunk` (no change)

---

## 7) Rollout Plan

- [ ] Land goa-ai API types + conversions
- [ ] Land gateway server + remote client + docs
- [ ] Add example + integration tests
- [ ] Migrate AURA incrementally: inference service → gateway, planners register remote client

---

## 8) Open Questions / Decisions

- [ ] Thinking options in `LLMRequest`? (gate via middleware vs DTO field)
- [ ] Include a minimal safety/guardrail middleware in-tree or leave as example?
- [ ] Provide default error mapping policy (HTTP/GRPC) or require user mapper?

---

## 9) Status Log (append brief notes)

- YYYY-MM-DD: Created document; agreed on server/client split and middleware shape.
