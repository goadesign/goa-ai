// Code generated by goa vX, DO NOT EDIT.
//
// A2A server adapter for adapter-agent agent
//
// Command:

package a2aadapter_agent

import (
	"context"
	"encoding/json"
	a2aadapter_agent "example.com/a2a_adapter/a2a_adapter_agent"
	"fmt"
	agentruntime "goa.design/goa-ai/runtime/agent"
	"sync"
	"time"
)

// Adapter implements the A2A service interface by routing requests to the agent runtime.
type Adapter struct {
	runtime agentruntime.Client
	agentID string
	baseURL string
	tasks   sync.Map
}

// taskState tracks the state of an active task.
type taskState struct {
	status string
	cancel context.CancelFunc
}

// NewAdapter creates a new A2A adapter for the AdapterAgent agent.
func NewAdapter(runtime agentruntime.Client, agentID, baseURL string) *Adapter {
	return &Adapter{
		runtime: runtime,
		agentID: agentID,
		baseURL: baseURL,
	}
}

// TasksSend implements the tasks/send A2A method.
func (a *Adapter) TasksSend(ctx context.Context, p *a2aadapter_agent.SendTaskPayload) (*a2aadapter_agent.TaskResponse, error) {
	messages, err := convertMessage(p.Message)
	if err != nil {
		return errorResponse(p.ID, err), nil
	}

	taskCtx, cancel := context.WithCancel(ctx)
	a.tasks.Store(p.ID, &taskState{status: "working", cancel: cancel})
	defer a.tasks.Delete(p.ID)

	out, err := a.runtime.Run(taskCtx, messages)
	if err != nil {
		return errorResponse(p.ID, err), nil
	}
	return successResponse(p.ID, out), nil
}

// TasksSendSubscribe implements the tasks/sendSubscribe A2A method.
func (a *Adapter) TasksSendSubscribe(ctx context.Context, p *a2aadapter_agent.SendTaskPayload, stream a2aadapter_agent.TasksSendSubscribeServerStream) error {
	messages, err := convertMessage(p.Message)
	if err != nil {
		return stream.Send(errorEvent(p.ID, err))
	}

	taskCtx, cancel := context.WithCancel(ctx)
	a.tasks.Store(p.ID, &taskState{status: "working", cancel: cancel})
	defer a.tasks.Delete(p.ID)

	if err := stream.Send(statusEvent(p.ID, "working")); err != nil {
		return err
	}

	out, err := a.runtime.Run(taskCtx, messages)
	if err != nil {
		return stream.Send(errorEvent(p.ID, err))
	}

	if err := stream.Send(artifactEvent(p.ID, out)); err != nil {
		return err
	}
	return stream.Send(statusEvent(p.ID, "completed"))
}

// TasksGet implements the tasks/get A2A method.
func (a *Adapter) TasksGet(ctx context.Context, p *a2aadapter_agent.GetTaskPayload) (*a2aadapter_agent.TaskResponse, error) {
	v, ok := a.tasks.Load(p.ID)
	if !ok {
		return errorResponse(p.ID, fmt.Errorf("task not found")), nil
	}
	state := v.(*taskState)
	return &a2aadapter_agent.TaskResponse{
		ID:     p.ID,
		Status: &a2aadapter_agent.TaskStatus{State: state.status, Timestamp: time.Now().UTC().Format(time.RFC3339)},
	}, nil
}

// TasksCancel implements the tasks/cancel A2A method.
func (a *Adapter) TasksCancel(ctx context.Context, p *a2aadapter_agent.CancelTaskPayload) (*a2aadapter_agent.TaskResponse, error) {
	v, ok := a.tasks.Load(p.ID)
	if !ok {
		return errorResponse(p.ID, fmt.Errorf("task not found")), nil
	}
	state := v.(*taskState)
	if state.cancel != nil {
		state.cancel()
	}
	state.status = "canceled"
	return &a2aadapter_agent.TaskResponse{
		ID:     p.ID,
		Status: &a2aadapter_agent.TaskStatus{State: "canceled", Timestamp: time.Now().UTC().Format(time.RFC3339)},
	}, nil
}

// Helper functions for building responses and events.

func convertMessage(msg *a2aadapter_agent.TaskMessage) ([]any, error) {
	if msg == nil {
		return nil, fmt.Errorf("message is required")
	}
	var messages []any
	for _, part := range msg.Parts {
		switch part.Type {
		case "text":
			messages = append(messages, map[string]any{"role": msg.Role, "content": part.Text})
		case "data":
			data, err := json.Marshal(part.Data)
			if err != nil {
				return nil, fmt.Errorf("encoding data part: %w", err)
			}
			messages = append(messages, map[string]any{"role": msg.Role, "content": string(data)})
		}
	}
	return messages, nil
}

func errorResponse(taskID string, err error) *a2aadapter_agent.TaskResponse {
	return &a2aadapter_agent.TaskResponse{
		ID: taskID,
		Status: &a2aadapter_agent.TaskStatus{
			State:     "failed",
			Message:   &a2aadapter_agent.TaskMessage{Role: "system", Parts: []*a2aadapter_agent.MessagePart{{Type: "text", Text: err.Error()}}},
			Timestamp: time.Now().UTC().Format(time.RFC3339),
		},
	}
}

func successResponse(taskID string, out any) *a2aadapter_agent.TaskResponse {
	return &a2aadapter_agent.TaskResponse{
		ID:        taskID,
		Status:    &a2aadapter_agent.TaskStatus{State: "completed", Timestamp: time.Now().UTC().Format(time.RFC3339)},
		Artifacts: []*a2aadapter_agent.Artifact{convertArtifact(out)},
	}
}

func convertArtifact(out any) *a2aadapter_agent.Artifact {
	var parts []*a2aadapter_agent.MessagePart
	switch v := out.(type) {
	case string:
		parts = append(parts, &a2aadapter_agent.MessagePart{Type: "text", Text: v})
	default:
		data, _ := json.Marshal(v)
		parts = append(parts, &a2aadapter_agent.MessagePart{Type: "data", Data: json.RawMessage(data)})
	}
	return &a2aadapter_agent.Artifact{Name: "result", Parts: parts, LastChunk: true}
}

func statusEvent(taskID, state string) *a2aadapter_agent.TaskEvent {
	return &a2aadapter_agent.TaskEvent{
		Type:   "status",
		TaskID: taskID,
		Status: &a2aadapter_agent.TaskStatus{State: state, Timestamp: time.Now().UTC().Format(time.RFC3339)},
		Final:  state == "completed" || state == "failed" || state == "canceled",
	}
}

func errorEvent(taskID string, err error) *a2aadapter_agent.TaskEvent {
	return &a2aadapter_agent.TaskEvent{
		Type:   "error",
		TaskID: taskID,
		Status: &a2aadapter_agent.TaskStatus{
			State:   "failed",
			Message: &a2aadapter_agent.TaskMessage{Role: "system", Parts: []*a2aadapter_agent.MessagePart{{Type: "text", Text: err.Error()}}},
		},
		Final: true,
	}
}

func artifactEvent(taskID string, out any) *a2aadapter_agent.TaskEvent {
	return &a2aadapter_agent.TaskEvent{
		Type:     "artifact",
		TaskID:   taskID,
		Artifact: convertArtifact(out),
	}
}

// AgentCard implements the agent/card A2A method.
func (a *Adapter) AgentCard(ctx context.Context) (*a2aadapter_agent.AgentCardResponse, error) {
	return &a2aadapter_agent.AgentCardResponse{
		ProtocolVersion:    "1.0",
		Name:               "adapter-agent",
		Description:        "Agent for adapter testing",
		URL:                a.BaseURL(),
		Version:            "1.0.0",
		Capabilities:       map[string]any{"streaming": true},
		DefaultInputModes:  []string{"application/json"},
		DefaultOutputModes: []string{"application/json"},
		Skills: []*a2aadapter_agent.A2ASkill{
			{
				ID:          "action_tools.process",
				Name:        "Process",
				Description: "Process data",
				InputModes:  []string{"application/json"},
				OutputModes: []string{"application/json"},
			},
		},
	}, nil
}
