// Code generated by goa vX, DO NOT EDIT.
//
// ScribeAgent tool codecs
//
// Command:

package profiles

import (
	"encoding/json"
	"errors"
	"fmt"
	"goa.design/goa-ai/runtime/agent/tools"
	goa "goa.design/goa/v3/pkg"
	"strings"
)

var (
	// UpsertPayloadCodec serializes values of type UpsertPayload to canonical JSON.
	UpsertPayloadCodec = tools.JSONCodec[UpsertPayload]{
		ToJSON:   MarshalUpsertPayload,
		FromJSON: UnmarshalUpsertPayload,
	}
	// UpsertResultCodec serializes values of type UpsertResult to canonical JSON.
	UpsertResultCodec = tools.JSONCodec[UpsertResult]{
		ToJSON:   MarshalUpsertResult,
		FromJSON: UnmarshalUpsertResult,
	}
	// upsertPayloadCodec provides an untyped codec for UpsertPayload.
	upsertPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(UpsertPayload)
			if !ok {
				return nil, fmt.Errorf("expected UpsertPayload, got %T", v)
			}
			return MarshalUpsertPayload(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalUpsertPayload(data)
		},
	}
	// upsertResultCodec provides an untyped codec for UpsertResult.
	upsertResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			typed, ok := v.(UpsertResult)
			if !ok {
				return nil, fmt.Errorf("expected UpsertResult, got %T", v)
			}
			return MarshalUpsertResult(typed)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalUpsertResult(data)
		},
	}
)
var UpsertPayloadFieldDescs = map[string]string{
	"address":        "Address",
	"address.city":   "City",
	"address.street": "Street",
	"id":             "Identifier",
	"name":           "Name",
}

// ValidationError wraps a validation failure and exposes issues that callers
// can use to build retry hints. It implements error and an Issues() accessor.
type ValidationError struct {
	msg          string
	issues       []*tools.FieldIssue
	descriptions map[string]string
}

func (e ValidationError) Error() string {
	return e.msg
}
func (e ValidationError) Issues() []*tools.FieldIssue {
	if len(e.issues) == 0 {
		return nil
	}
	out := make([]*tools.FieldIssue, len(e.issues))
	copy(out, e.issues)
	return out
}
func (e ValidationError) Descriptions() map[string]string {
	if len(e.descriptions) == 0 {
		return nil
	}
	out := make(map[string]string, len(e.descriptions))
	for k, v := range e.descriptions {
		out[k] = v
	}
	return out
}

// newValidationError converts a goa.ServiceError (possibly merged) into a
// ValidationError with structured FieldIssue entries. It trims any leading
// "body." from field names for conciseness.
func newValidationError(err error) error {
	if err == nil {
		return nil
	}
	var se *goa.ServiceError
	if !errors.As(err, &se) {
		return err
	}
	hist := se.History()
	issues := make([]*tools.FieldIssue, 0, len(hist))
	for _, h := range hist {
		var field string
		if h.Field != nil {
			field = *h.Field
		}
		if strings.HasPrefix(field, "body.") {
			field = strings.TrimPrefix(field, "body.")
		}
		issues = append(issues, &tools.FieldIssue{Field: field, Constraint: h.Name})
	}
	if len(issues) == 0 {
		return err
	}
	return &ValidationError{
		msg:    err.Error(),
		issues: issues,
	}
}
func enrichUpsertPayloadValidationError(err error) error {
	ve, ok := err.(*ValidationError)
	if !ok || ve == nil {
		return err
	}
	if len(ve.issues) == 0 {
		return err
	}
	m := make(map[string]string)
	for _, is := range ve.issues {
		if d, ok := UpsertPayloadFieldDescs[is.Field]; ok && d != "" {
			m[is.Field] = d
		}
	}
	ve.descriptions = m
	return ve
}
func enrichUpsertPayloadJSON2ValidationError(err error) error {
	ve, ok := err.(*ValidationError)
	if !ok || ve == nil {
		return err
	}
	if len(ve.issues) == 0 {
		return err
	}
	m := make(map[string]string)
	ve.descriptions = m
	return ve
}
func enrichUpsertPayloadJSONAddressJSON2ValidationError(err error) error {
	ve, ok := err.(*ValidationError)
	if !ok || ve == nil {
		return err
	}
	if len(ve.issues) == 0 {
		return err
	}
	m := make(map[string]string)
	ve.descriptions = m
	return ve
}

// PayloadCodec returns the generic codec for the named tool payload.
func PayloadCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "alpha.profiles.upsert":
		return &upsertPayloadCodec, true
	default:
		return nil, false
	}
}

// ResultCodec returns the generic codec for the named tool result.
func ResultCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "alpha.profiles.upsert":
		return &upsertResultCodec, true
	default:
		return nil, false
	}
}

// MarshalUpsertPayload serializes UpsertPayload into JSON.
func MarshalUpsertPayload(v UpsertPayload) ([]byte, error) {
	return json.Marshal(v)
}

// UnmarshalUpsertPayload deserializes JSON into UpsertPayload.
func UnmarshalUpsertPayload(data []byte) (UpsertPayload, error) {
	var zero UpsertPayload
	if len(data) == 0 {
		return zero, fmt.Errorf("upsertPayload JSON is empty")
	}
	// Decode into JSON body (server body style) then validate & transform
	var raw UpsertPayloadJSON2
	if err := json.Unmarshal(data, &raw); err != nil {
		return zero, fmt.Errorf("decode upsertPayload: %w", err)
	}
	var err error
	if raw.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "raw"))
	}
	if raw.Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("address", "raw"))
	}
	if raw.Address != nil {
		if err2 := ValidateUpsertPayloadJSONAddressJSON2(raw.Address); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if err != nil {
		err = newValidationError(err)
		err = enrichUpsertPayloadValidationError(err)
		return zero, fmt.Errorf("validate upsertPayload: %w", err)
	}
	// Transform into final type
	v := &Profile{
		ID:   *raw.ID,
		Name: raw.Name,
	}
	v.Address = payloadUpsertPayloadJSONAddressJSON2ToAddress(raw.Address)
	return *v, nil
}

// MarshalUpsertResult serializes UpsertResult into JSON.
func MarshalUpsertResult(v UpsertResult) ([]byte, error) {
	return json.Marshal(v)
}

// UnmarshalUpsertResult deserializes JSON into UpsertResult.
func UnmarshalUpsertResult(data []byte) (UpsertResult, error) {
	var zero UpsertResult
	if len(data) == 0 {
		return zero, fmt.Errorf("upsertResult JSON is empty")
	}
	// Non-payload types: simple decode
	var v UpsertResult
	if err := json.Unmarshal(data, &v); err != nil {
		return zero, fmt.Errorf("decode upsertResult: %w", err)
	}
	return v, nil
}

// Transform helpers
func payloadUpsertPayloadJSONAddressJSON2ToAddress(v *UpsertPayloadJSONAddressJSON2) (out *Address) {
	res := &Address{
		Street: *v.Street,
		City:   *v.City,
	}

	out = res
	return
}

// ValidateAddress validates values of type *Address.
func ValidateAddress(body *Address) (err error) {

	return
}

// ValidateProfile validates values of type *Profile.
func ValidateProfile(body *Profile) (err error) {
	if body.Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("address", "body"))
	}
	return
}

// ValidateUpsertPayloadJSON2 validates values of type *UpsertPayloadJSON2.
func ValidateUpsertPayloadJSON2(body *UpsertPayloadJSON2) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Address == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("address", "body"))
	}
	if body.Address != nil {
		if err2 := ValidateUpsertPayloadJSONAddressJSON2(body.Address); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateUpsertPayloadJSONAddressJSON2 validates values of type *UpsertPayloadJSONAddressJSON2.
func ValidateUpsertPayloadJSONAddressJSON2(body *UpsertPayloadJSONAddressJSON2) (err error) {
	if body.Street == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("street", "body"))
	}
	if body.City == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("city", "body"))
	}
	return
}
