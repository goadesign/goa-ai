// Code generated by goa v3.22.6, DO NOT EDIT.
//
// ScribeAgent tool codecs
//
// Command:


package profiles

import (
	"encoding/json"
	"errors"
	"fmt"
	"goa.design/goa-ai/runtime/agent/tools"
	goa "goa.design/goa/v3/pkg"
	"strings"
)

var (
    // UpsertPayloadCodec serializes values of type *UpsertPayload to canonical JSON.
    UpsertPayloadCodec = tools.JSONCodec[*UpsertPayload]{
        ToJSON:   MarshalUpsertPayload,
        FromJSON: UnmarshalUpsertPayload,
    }
    // UpsertResultCodec serializes values of type UpsertResult to canonical JSON.
    UpsertResultCodec = tools.JSONCodec[UpsertResult]{
        ToJSON:   MarshalUpsertResult,
        FromJSON: UnmarshalUpsertResult,
    }
    // upsertPayloadCodec provides an untyped codec for *UpsertPayload.
    upsertPayloadCodec = tools.JSONCodec[any]{
        ToJSON: func(v any) ([]byte, error) {
            // Prefer typed marshal when the value matches the expected type.
            if typed, ok := v.(*UpsertPayload); ok {
                return MarshalUpsertPayload(typed)
            }
            // Fallback: marshal structurally compatible values directly.
            return json.Marshal(v)
        },
        FromJSON: func(data []byte) (any, error) {
            return UnmarshalUpsertPayload(data)
        },
    }
    // upsertResultCodec provides an untyped codec for UpsertResult.
    upsertResultCodec = tools.JSONCodec[any]{
        ToJSON: func(v any) ([]byte, error) {
            // Prefer typed marshal when the value matches the expected type.
            if typed, ok := v.(UpsertResult); ok {
                return MarshalUpsertResult(typed)
            }
            // Fallback: marshal structurally compatible values directly.
            return json.Marshal(v)
        },
        FromJSON: func(data []byte) (any, error) {
            return UnmarshalUpsertResult(data)
        },
    }
)
var UpsertPayloadFieldDescs = map[string]string{
    "profile": "Profile",
    "profile.address": "Address",
    "profile.address.city": "City",
    "profile.address.street": "Street",
    "profile.id": "Identifier",
    "profile.name": "Name",
}

// ValidationError wraps a validation failure and exposes issues that callers
// can use to build retry hints. It implements error and an Issues() accessor.
type ValidationError struct {
    msg          string
    issues       []*tools.FieldIssue
    descriptions map[string]string
}

func (e ValidationError) Error() string {
    return e.msg
}
func (e ValidationError) Issues() []*tools.FieldIssue {
    if len(e.issues) == 0 {
        return nil
    }
    out := make([]*tools.FieldIssue, len(e.issues))
    copy(out, e.issues)
    return out
}
func (e ValidationError) Descriptions() map[string]string {
    if len(e.descriptions) == 0 {
        return nil
    }
    out := make(map[string]string, len(e.descriptions))
    for k, v := range e.descriptions {
        out[k] = v
    }
    return out
}
// newValidationError converts a goa.ServiceError (possibly merged) into a
// ValidationError with structured FieldIssue entries. It trims any leading
// "body." from field names for conciseness.
func newValidationError(err error) error {
    if err == nil {
        return nil
    }
    var se *goa.ServiceError
    if !errors.As(err, &se) {
        return err
    }
    hist := se.History()
    issues := make([]*tools.FieldIssue, 0, len(hist))
    for _, h := range hist {
        var field string
        if h.Field != nil {
            field = *h.Field
        }
        if strings.HasPrefix(field, "body.") {
            field = strings.TrimPrefix(field, "body.")
        }
        issues = append(issues, &tools.FieldIssue{Field: field, Constraint: h.Name})
    }
    if len(issues) == 0 {
        return err
    }
    return &ValidationError{
        msg:    err.Error(),
        issues: issues,
    }
}
func enrichUpsertPayloadValidationError(err error) error {
    ve, ok := err.(*ValidationError)
    if !ok || ve == nil {
        return err
    }
    if len(ve.issues) == 0 {
        return err
    }
    m := make(map[string]string)
    for _, is := range ve.issues {
        if d, ok := UpsertPayloadFieldDescs[is.Field]; ok && d != "" {
            m[is.Field] = d
        }
    }
    ve.descriptions = m
    return ve
}
func enrichUpsertPayloadJSON2ValidationError(err error) error {
    ve, ok := err.(*ValidationError)
    if !ok || ve == nil {
        return err
    }
    if len(ve.issues) == 0 {
        return err
    }
    m := make(map[string]string)
    ve.descriptions = m
    return ve
}
func enrichUpsertPayloadJSONProfileJSON2ValidationError(err error) error {
    ve, ok := err.(*ValidationError)
    if !ok || ve == nil {
        return err
    }
    if len(ve.issues) == 0 {
        return err
    }
    m := make(map[string]string)
    ve.descriptions = m
    return ve
}
func enrichUpsertPayloadJSONProfileJSONAddressJSON2ValidationError(err error) error {
    ve, ok := err.(*ValidationError)
    if !ok || ve == nil {
        return err
    }
    if len(ve.issues) == 0 {
        return err
    }
    m := make(map[string]string)
    ve.descriptions = m
    return ve
}

// PayloadCodec returns the generic codec for the named tool payload.
func PayloadCodec(name string) (*tools.JSONCodec[any], bool) {
    switch name {
    case "upsert":
        return &upsertPayloadCodec, true
    default:
        return nil, false
    }
}

// ResultCodec returns the generic codec for the named tool result.
func ResultCodec(name string) (*tools.JSONCodec[any], bool) {
    switch name {
    case "upsert":
        return &upsertResultCodec, true
    default:
        return nil, false
    }
}
// MarshalUpsertPayload serializes *UpsertPayload into JSON.
func MarshalUpsertPayload(v *UpsertPayload) ([]byte, error) {
    if v == nil {
        return nil, fmt.Errorf("upsertPayload is nil")
    }
    return json.Marshal(v)
}

// UnmarshalUpsertPayload deserializes JSON into *UpsertPayload.
func UnmarshalUpsertPayload(data []byte) (*UpsertPayload, error) {
    if len(data) == 0 {
        return nil, fmt.Errorf("upsertPayload JSON is empty")
    }
    // Decode into JSON body (server body style) then transform.
    // Note: Agent used-tools perform lenient decode (no required-field validation here).
    var raw UpsertPayloadJSON2
    if err := json.Unmarshal(data, &raw); err != nil {
        return nil, fmt.Errorf("decode upsertPayload: %w", err)
    }
    var err error
    if raw.Profile == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("profile", "raw"))
    }
    if raw.Profile != nil {
    	if err2 := ValidateUpsertPayloadJSONProfileJSON2(raw.Profile); err2 != nil {
            err = goa.MergeErrors(err, err2)
    }
    }
    if err != nil {
        err = newValidationError(err)
        return nil, err
    }
    // Transform into final type
    v := &UpsertArgs{}
v.Profile = payloadUpsertPayloadJSONProfileJSON2ToProfile(raw.Profile)
    return v, nil
}
// MarshalUpsertResult serializes UpsertResult into JSON.
func MarshalUpsertResult(v UpsertResult) ([]byte, error) {
    return json.Marshal(v)
}

// UnmarshalUpsertResult deserializes JSON into UpsertResult.
func UnmarshalUpsertResult(data []byte) (UpsertResult, error) {
    var zero UpsertResult
    if len(data) == 0 {
        return zero, fmt.Errorf("upsertResult JSON is empty")
    }
    // Non-payload types: simple decode
    var v UpsertResult
    if err := json.Unmarshal(data, &v); err != nil {
        return zero, fmt.Errorf("decode upsertResult: %w", err)
    }
    return v, nil
}

// Transform helpers
func payloadUpsertPayloadJSONProfileJSON2ToProfile(v *UpsertPayloadJSONProfileJSON2) (out *Profile) {
res := &Profile{
ID: *v.ID,
Name: v.Name,
}
res.Address = payloadUpsertPayloadJSONProfileJSONAddressJSON2ToAddress(v.Address)

    out = res
    return
}
func payloadUpsertPayloadJSONProfileJSONAddressJSON2ToAddress(v *UpsertPayloadJSONProfileJSONAddressJSON2) (out *Address) {
res := &Address{
Street: *v.Street,
City: *v.City,
}

    out = res
    return
}

// ValidateAddress validates values of type *Address.
func ValidateAddress(body *Address) (err error) {
    
    return
}

// ValidateProfile validates values of type *Profile.
func ValidateProfile(body *Profile) (err error) {
    if body.Address == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("address", "body"))
    }
    return
}

// ValidateUpsertArgs validates values of type *UpsertArgs.
func ValidateUpsertArgs(body *UpsertArgs) (err error) {
    if body.Profile == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("profile", "body"))
    }
    if body.Profile != nil {
    	if err2 := ValidateProfile(body.Profile); err2 != nil {
            err = goa.MergeErrors(err, err2)
    }
    }
    return
}

// ValidateUpsertPayloadJSON2 validates values of type *UpsertPayloadJSON2.
func ValidateUpsertPayloadJSON2(body *UpsertPayloadJSON2) (err error) {
    if body.Profile == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("profile", "body"))
    }
    if body.Profile != nil {
    	if err2 := ValidateUpsertPayloadJSONProfileJSON2(body.Profile); err2 != nil {
            err = goa.MergeErrors(err, err2)
    }
    }
    return
}

// ValidateUpsertPayloadJSONProfileJSON2 validates values of type *UpsertPayloadJSONProfileJSON2.
func ValidateUpsertPayloadJSONProfileJSON2(body *UpsertPayloadJSONProfileJSON2) (err error) {
    if body.ID == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
    }
    if body.Address == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("address", "body"))
    }
    if body.Address != nil {
    	if err2 := ValidateUpsertPayloadJSONProfileJSONAddressJSON2(body.Address); err2 != nil {
            err = goa.MergeErrors(err, err2)
    }
    }
    return
}

// ValidateUpsertPayloadJSONProfileJSONAddressJSON2 validates values of type *UpsertPayloadJSONProfileJSONAddressJSON2.
func ValidateUpsertPayloadJSONProfileJSONAddressJSON2(body *UpsertPayloadJSONProfileJSONAddressJSON2) (err error) {
    if body.Street == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("street", "body"))
    }
    if body.City == nil {
            err = goa.MergeErrors(err, goa.MissingFieldError("city", "body"))
    }
    return
}
