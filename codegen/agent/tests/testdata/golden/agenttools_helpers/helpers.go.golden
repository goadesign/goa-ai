// Code generated by goa vX, DO NOT EDIT.
//
// search agent tools
//
// Command:

package search

import (
	searchspecs "goa.design/goa-ai/alpha/tools/search"
	agent "goa.design/goa-ai/runtime/agent"
	"goa.design/goa-ai/runtime/agent/planner"
	runtime "goa.design/goa-ai/runtime/agent/runtime"
	hints "goa.design/goa-ai/runtime/agent/runtime/hints"
	"goa.design/goa-ai/runtime/agent/tools"
)

// Name is the DSL-declared name for the exported toolset "search".
const Name = "search"

// Service identifies the service that defined the toolset.
const Service = "alpha"

// AgentID is the fully-qualified identifier of the agent exporting this toolset.
const AgentID agent.Ident = "alpha.scribe"

// Tool IDs for this exported toolset (globally unique). Use these typed
// constants as keys for per-tool configuration maps (e.g., SystemPrompts).
const (
	// Find is the canonical tool identifier for search.find.
	// Tool IDs are always fully-qualified "<toolset>.<tool>" strings.
	Find tools.Ident = "search.find"
)

// Type aliases and codec re-exports for convenience. These aliases preserve exact
// type identity while allowing callers to avoid importing the specs package.
type FindPayload = searchspecs.FindPayload
type FindResult = searchspecs.FindResult

var FindPayloadCodec = searchspecs.FindPayloadCodec
var FindResultCodec = searchspecs.FindResultCodec

// NewScribeToolsetRegistration creates a toolset registration for the scribe agent.
// The returned registration can be used with runtime.RegisterToolset to make the agent
// available as a tool to other agents. When invoked, the agent runs its full planning loop
// and returns the final response as the tool result. DSL-authored CallHintTemplate and
// ResultHintTemplate declarations are compiled into hint templates so sinks can render
// concise labels and previews without heuristics.
//
// Example usage:
//
//	rt := runtime.New(...)
//	reg := NewScribeToolsetRegistration(rt)
//	if err := rt.RegisterToolset(reg); err != nil {
//		// handle error
//	}
func NewScribeToolsetRegistration(rt *runtime.Runtime) runtime.ToolsetRegistration {
	cfg := runtime.AgentToolConfig{
		AgentID:   AgentID,
		Name:      "search",
		TaskQueue: "alpha_scribe_search_tasks",
		Route: runtime.AgentRoute{
			ID:               AgentID,
			WorkflowName:     "alpha.scribe.workflow",
			DefaultTaskQueue: "alpha_scribe_workflow",
		},
		PlanActivityName:    "alpha.scribe.plan",
		ResumeActivityName:  "alpha.scribe.resume",
		ExecuteToolActivity: "alpha.scribe.executetool",
	}
	reg := runtime.NewAgentToolsetRegistration(rt, cfg)
	// Install DSL-provided hint templates when present.
	{
		// Build maps only when at least one template exists to avoid overhead.
		var callRaw map[tools.Ident]string
		var resultRaw map[tools.Ident]string
		if len(callRaw) > 0 {
			compiled, err := hints.CompileHintTemplates(callRaw, nil)
			if err != nil {
				panic(err)
			}
			reg.CallHints = compiled
		}
		if len(resultRaw) > 0 {
			compiled, err := hints.CompileHintTemplates(resultRaw, nil)
			if err != nil {
				panic(err)
			}
			reg.ResultHints = compiled
		}
	}
	return reg
}

// ToolIDs lists all tools in this toolset for validation.
var ToolIDs = []tools.Ident{
	Find,
}

// NewRegistration creates a toolset registration with an optional agent-wide
// system prompt and per-tool content configured via runtime options. Callers
// can mix text and templates; each tool must be configured in exactly one way.
func NewRegistration(
	rt *runtime.Runtime,
	systemPrompt string,
	opts ...runtime.AgentToolOption,
) (runtime.ToolsetRegistration, error) {
	cfg := runtime.AgentToolConfig{
		AgentID:      AgentID,
		Name:         "search",
		TaskQueue:    "alpha_scribe_search_tasks",
		SystemPrompt: systemPrompt,
		// Strong-contract routing for cross-process inline composition
		Route: runtime.AgentRoute{
			ID:               AgentID,
			WorkflowName:     "alpha.scribe.workflow",
			DefaultTaskQueue: "alpha_scribe_workflow",
		},
		PlanActivityName:    "alpha.scribe.plan",
		ResumeActivityName:  "alpha.scribe.resume",
		ExecuteToolActivity: "alpha.scribe.executetool",
	}
	for _, o := range opts {
		o(&cfg)
	}
	// Validate only for the templates explicitly provided (optional)
	if len(cfg.Templates) > 0 {
		ids := make([]tools.Ident, 0, len(cfg.Templates))
		for id := range cfg.Templates {
			ids = append(ids, id)
		}
		if err := runtime.ValidateAgentToolTemplates(cfg.Templates, ids, nil); err != nil {
			return runtime.ToolsetRegistration{}, err
		}
	}
	reg := runtime.NewAgentToolsetRegistration(rt, cfg)
	// Install DSL-provided hint templates when present.
	{
		// Build maps only when at least one template exists to avoid overhead.
		var callRaw map[tools.Ident]string
		var resultRaw map[tools.Ident]string
		if len(callRaw) > 0 {
			compiled, err := hints.CompileHintTemplates(callRaw, nil)
			if err != nil {
				panic(err)
			}
			reg.CallHints = compiled
		}
		if len(resultRaw) > 0 {
			compiled, err := hints.CompileHintTemplates(resultRaw, nil)
			if err != nil {
				panic(err)
			}
			reg.ResultHints = compiled
		}
	}
	return reg, nil
}

// CallOption customizes planner.ToolRequest values built by the typed helpers
// below (e.g., setting parent/tool-call IDs for correlation with model calls).
type CallOption func(*planner.ToolRequest)

// WithParentToolCallID sets the ParentToolCallID on the constructed request.
func WithParentToolCallID(id string) CallOption {
	return func(r *planner.ToolRequest) { r.ParentToolCallID = id }
}

// WithToolCallID sets a model/tool-call identifier on the request. The runtime
// preserves this ID and echoes it in ToolResult.ToolCallID for correlation.
func WithToolCallID(id string) CallOption {
	return func(r *planner.ToolRequest) { r.ToolCallID = id }
}

// Typed tool-call helpers for each tool in this exported toolset. These helpers
// enforce use of the generated tool identifier and accept a typed payload that
// matches the tool schema.
// NewFindCall builds a planner.ToolRequest for the search.find tool.
func NewFindCall(args *FindPayload, opts ...CallOption) planner.ToolRequest {
	var payload []byte
	if args != nil {
		// Encode typed payloads into canonical JSON using the generated codec.
		b, err := FindPayloadCodec.ToJSON(args)
		if err != nil {
			panic(err)
		}
		payload = b
	}
	req := planner.ToolRequest{
		Name:    Find,
		Payload: payload,
	}
	for _, o := range opts {
		if o != nil {
			o(&req)
		}
	}
	return req
}
