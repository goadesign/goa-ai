// Code generated by goa vX, DO NOT EDIT.
//
// ScribeAgent aggregated tool specs
//
// Command:

package specs

import (
	helpers "goa.design/goa-ai/alpha/agents/scribe/specs/helpers"
	"goa.design/goa-ai/runtime/agent/policy"
	"goa.design/goa-ai/runtime/agent/tools"
	"sort"
)

var (
	// Specs aggregates tool specs from all toolset packages.
	Specs = make([]tools.ToolSpec, 0)
	// metadata aggregates tool metadata from all toolset packages.
	metadata = make([]policy.ToolMetadata, 0)
)

func init() {
	// helpers toolset
	Specs = append(Specs, helpers.Specs...)
	metadata = append(metadata, helpers.Metadata()...)
	sort.Slice(Specs, func(i, j int) bool {
		return string(Specs[i].Name) < string(Specs[j].Name)
	})
}

// Names returns sorted tool identifiers for all aggregated toolsets.
func Names() []tools.Ident {
	names := make([]tools.Ident, 0, len(Specs))
	for _, s := range Specs {
		names = append(names, s.Name)
	}
	sort.Slice(names, func(i, j int) bool { return string(names[i]) < string(names[j]) })
	return names
}

// Spec returns the specification for the named tool if present.
func Spec(name tools.Ident) (*tools.ToolSpec, bool) {
	for i := range Specs {
		if Specs[i].Name == name {
			return &Specs[i], true
		}
	}
	return nil, false
}

// PayloadSchema returns the JSON schema for the named tool payload.
func PayloadSchema(name tools.Ident) ([]byte, bool) {
	if s, ok := Spec(name); ok {
		return s.Payload.Schema, true
	}
	return nil, false
}

// ResultSchema returns the JSON schema for the named tool result.
func ResultSchema(name tools.Ident) ([]byte, bool) {
	if s, ok := Spec(name); ok {
		return s.Result.Schema, true
	}
	return nil, false
}

// Metadata exposes policy metadata for the aggregated tools.
func Metadata() []policy.ToolMetadata {
	out := make([]policy.ToolMetadata, len(metadata))
	copy(out, metadata)
	return out
}
