// Code generated by goa vX, DO NOT EDIT.
//
// ScribeAgent registry
//
// Command:

package scribe

import (
	"context"
	"errors"
	"fmt"
	core "goa.design/goa-ai/alpha/agents/scribe/core"
	core2 "goa.design/goa-ai/calc/toolsets/core"
	"goa.design/goa-ai/runtime/agent/engine"
	"goa.design/goa-ai/runtime/agent/planner"
	agentsruntime "goa.design/goa-ai/runtime/agent/runtime"
	"time"
)

// RegisterScribeAgent registers the generated agent components with the runtime.
func RegisterScribeAgent(ctx context.Context, rt *agentsruntime.Runtime, cfg ScribeAgentConfig) error {
	if rt == nil {
		return errors.New("runtime is required")
	}
	agent, err := NewScribeAgent(cfg)
	if err != nil {
		return err
	}
	if err := rt.RegisterAgent(ctx, agentsruntime.AgentRegistration{
		ID:      "alpha.scribe",
		Planner: agent.Planner,
		Workflow: engine.WorkflowDefinition{
			Name:      "alpha.scribe.workflow",
			TaskQueue: "alpha_scribe_workflow",
			Handler:   rt.ExecuteWorkflow,
		},
		PlanActivityName: "alpha.scribe.plan",
		PlanActivityOptions: engine.ActivityOptions{
			Queue:   "alpha_scribe_workflow",
			Timeout: time.Duration(120000000000),
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts:        3,
				InitialInterval:    time.Duration(1000000000),
				BackoffCoefficient: 2,
			},
		},
		ResumeActivityName: "alpha.scribe.resume",
		ResumeActivityOptions: engine.ActivityOptions{
			Queue:   "alpha_scribe_workflow",
			Timeout: time.Duration(120000000000),
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts:        3,
				InitialInterval:    time.Duration(1000000000),
				BackoffCoefficient: 2,
			},
		},
		ExecuteToolActivity: "alpha.scribe.executetool",
		ExecuteToolActivityOptions: engine.ActivityOptions{
			RetryPolicy: engine.RetryPolicy{
				MaxAttempts: 1,
			},
		},
		Specs:  nil,
		Policy: agentsruntime.RunPolicy{},
	}); err != nil {
		return err
	}
	// Register MCP-backed toolsets using local executors and callers from config.
	if cfg.MCPCallers == nil {
		return fmt.Errorf("mcp callers are required for agent %s", "alpha.scribe")
	}
	{
		caller := cfg.MCPCallers[ScribeCalcCoreToolsetID]
		if caller == nil {
			return fmt.Errorf("mcp caller for %s is required", ScribeCalcCoreToolsetID)
		}
		exec := core.NewScribeCoreMCPExecutor(caller)
		// Build a runtime ToolsetRegistration inline to avoid exposing method/service adapters.
		reg := agentsruntime.ToolsetRegistration{
			Name: "core",
			// Use the used-toolset specs package for strong-contract payload/result codecs.
			Specs: core2.Specs,
			Execute: func(ctx context.Context, call *planner.ToolRequest) (*planner.ToolResult, error) {
				if call == nil {
					return nil, fmt.Errorf("tool request is nil")
				}
				meta := &agentsruntime.ToolCallMeta{
					RunID:            call.RunID,
					SessionID:        call.SessionID,
					TurnID:           call.TurnID,
					ToolCallID:       call.ToolCallID,
					ParentToolCallID: call.ParentToolCallID,
				}
				result, err := exec.Execute(ctx, meta, call)
				if err != nil {
					return nil, err
				}
				if result == nil {
					return nil, fmt.Errorf("executor returned nil result")
				}
				return result, nil
			},
		}
		if err := rt.RegisterToolset(reg); err != nil {
			return err
		}
	}

	// Service-backed toolsets (method-backed Used toolsets) are registered by
	// application code using executors. Agent-exported toolsets are wired via
	// provider agenttools helpers and consumer-side agent toolset helpers.
	return nil
}
