// Code generated by goa vX, DO NOT EDIT.
//
// ScribeAgent tool codecs
//
// Command:

package ops

import (
	"encoding/json"
	"errors"
	"fmt"
	"goa.design/goa-ai/runtime/agent/tools"
	"strings"
)

var (
	// EchoPayloadCodec serializes values of type *EchoPayload to canonical JSON.
	EchoPayloadCodec = tools.JSONCodec[*EchoPayload]{
		ToJSON:   MarshalEchoPayload,
		FromJSON: UnmarshalEchoPayload,
	}
	// EchoResultCodec serializes values of type EchoResult to canonical JSON.
	EchoResultCodec = tools.JSONCodec[EchoResult]{
		ToJSON:   MarshalEchoResult,
		FromJSON: UnmarshalEchoResult,
	}
	// echoPayloadCodec provides an untyped codec for *EchoPayload.
	echoPayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			// Prefer typed marshal when the value matches the expected type.
			if typed, ok := v.(*EchoPayload); ok {
				return MarshalEchoPayload(typed)
			}
			// Fallback: marshal structurally compatible values directly.
			return json.Marshal(v)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalEchoPayload(data)
		},
	}
	// echoResultCodec provides an untyped codec for EchoResult.
	echoResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			// Prefer typed marshal when the value matches the expected type.
			if typed, ok := v.(EchoResult); ok {
				return MarshalEchoResult(typed)
			}
			// Fallback: marshal structurally compatible values directly.
			return json.Marshal(v)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalEchoResult(data)
		},
	}
)

// ValidationError wraps a validation failure and exposes issues that callers
// can use to build retry hints. It implements error and an Issues() accessor.
type ValidationError struct {
	msg          string
	issues       []*tools.FieldIssue
	descriptions map[string]string
}

func (e ValidationError) Error() string {
	return e.msg
}
func (e ValidationError) Issues() []*tools.FieldIssue {
	if len(e.issues) == 0 {
		return nil
	}
	out := make([]*tools.FieldIssue, len(e.issues))
	copy(out, e.issues)
	return out
}
func (e ValidationError) Descriptions() map[string]string {
	if len(e.descriptions) == 0 {
		return nil
	}
	out := make(map[string]string, len(e.descriptions))
	for k, v := range e.descriptions {
		out[k] = v
	}
	return out
}

// PayloadCodec returns the generic codec for the named tool payload.
func PayloadCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "ops.echo":
		return &echoPayloadCodec, true
	default:
		return nil, false
	}
}

// ResultCodec returns the generic codec for the named tool result.
func ResultCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "ops.echo":
		return &echoResultCodec, true
	default:
		return nil, false
	}
}

// ArtifactCodec returns the generic codec for the named tool artifact when declared.
func ArtifactCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	default:
		return nil, false
	}
}

// MarshalEchoPayload serializes *EchoPayload into JSON.
func MarshalEchoPayload(v *EchoPayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("echoPayload is nil")
	}
	return json.Marshal(v)
}

// UnmarshalEchoPayload deserializes JSON into *EchoPayload.
func UnmarshalEchoPayload(data []byte) (*EchoPayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("echoPayload JSON is empty")
	}
	// Decode into JSON body (server body style) then transform.
	// Note: Agent used-tools perform lenient decode (no required-field validation here).
	var raw EchoPayloadJSON2
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, fmt.Errorf("decode echoPayload: %w", err)
	}
	// Transform into final type
	res := EchoPayload(raw)
	v := &res
	return v, nil
}

// MarshalEchoResult serializes EchoResult into JSON.
func MarshalEchoResult(v EchoResult) ([]byte, error) {
	return json.Marshal(v)
}

// UnmarshalEchoResult deserializes JSON into EchoResult.
func UnmarshalEchoResult(data []byte) (EchoResult, error) {
	var zero EchoResult
	if len(data) == 0 {
		return zero, fmt.Errorf("echoResult JSON is empty")
	}
	// Decode into JSON body (server body style) then transform.
	// Note: Agent used-tools perform lenient decode (no required-field validation here).
	var raw EchoResultJSON2
	if err := json.Unmarshal(data, &raw); err != nil {
		return zero, fmt.Errorf("decode echoResult: %w", err)
	}
	// Transform into final type
	res := EchoResult(raw)
	v := &res
	return *v, nil
}

// Transform helpers

// ValidateEchoPayloadJSON2 validates values of type EchoPayloadJSON2.
func ValidateEchoPayloadJSON2(body EchoPayloadJSON2) (err error) {

	return
}

// ValidateEchoResultJSON2 validates values of type EchoResultJSON2.
func ValidateEchoResultJSON2(body EchoResultJSON2) (err error) {

	return
}
