// Code generated by goa vX, DO NOT EDIT.
//
// deep tool codecs
//
// Command:

package deep

import (
	"encoding/json"
	"errors"
	"fmt"
	toolhttp "goa.design/goa-ai/alpha/toolsets/deep/http"
	"goa.design/goa-ai/runtime/agent/tools"
	goa "goa.design/goa/v3/pkg"
	"strings"
)

var (
	// ValidatePayloadCodec serializes values of type *ValidatePayload to canonical JSON.
	ValidatePayloadCodec = tools.JSONCodec[*ValidatePayload]{
		ToJSON:   MarshalValidatePayload,
		FromJSON: UnmarshalValidatePayload,
	}
	// ValidateResultCodec serializes values of type *ValidateResult to canonical JSON.
	ValidateResultCodec = tools.JSONCodec[*ValidateResult]{
		ToJSON:   MarshalValidateResult,
		FromJSON: UnmarshalValidateResult,
	}
	// validatePayloadCodec provides an untyped codec for *ValidatePayload.
	validatePayloadCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			// Prefer typed marshal when the value matches the expected type.
			if typed, ok := v.(*ValidatePayload); ok {
				return MarshalValidatePayload(typed)
			}
			return nil, fmt.Errorf("invalid value type for *ValidatePayload: %T", v)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalValidatePayload(data)
		},
	}
	// validateResultCodec provides an untyped codec for *ValidateResult.
	validateResultCodec = tools.JSONCodec[any]{
		ToJSON: func(v any) ([]byte, error) {
			// Prefer typed marshal when the value matches the expected type.
			if typed, ok := v.(*ValidateResult); ok {
				return MarshalValidateResult(typed)
			}
			return nil, fmt.Errorf("invalid value type for *ValidateResult: %T", v)
		},
		FromJSON: func(data []byte) (any, error) {
			return UnmarshalValidateResult(data)
		},
	}
)
var ValidatePayloadFieldDescs = map[string]string{
	"child":            "Child L2",
	"child.child":      "Child L3",
	"child.child.leaf": "Leaf value",
	"child.mid":        "Middle value",
	"root":             "Root value",
}
var ValidateResultFieldDescs = map[string]string{
	"child":            "Child L2",
	"child.child":      "Child L3",
	"child.child.leaf": "Leaf value",
	"child.mid":        "Middle value",
	"root":             "Root value",
}

// ValidationError wraps a validation failure and exposes issues that callers
// can use to build retry hints. It implements error and an Issues() accessor.
type ValidationError struct {
	msg          string
	issues       []*tools.FieldIssue
	descriptions map[string]string
}

func (e ValidationError) Error() string {
	return e.msg
}
func (e ValidationError) Issues() []*tools.FieldIssue {
	if len(e.issues) == 0 {
		return nil
	}
	out := make([]*tools.FieldIssue, len(e.issues))
	copy(out, e.issues)
	return out
}
func (e ValidationError) Descriptions() map[string]string {
	if len(e.descriptions) == 0 {
		return nil
	}
	out := make(map[string]string, len(e.descriptions))
	for k, v := range e.descriptions {
		out[k] = v
	}
	return out
}

// newValidationError converts a goa.ServiceError (possibly merged) into a
// ValidationError with structured FieldIssue entries. It trims any leading
// "body." from field names for conciseness.
func newValidationError(err error) error {
	if err == nil {
		return nil
	}
	var se *goa.ServiceError
	if !errors.As(err, &se) {
		return err
	}
	hist := se.History()
	issues := make([]*tools.FieldIssue, 0, len(hist))
	for _, h := range hist {
		var field string
		if h.Field != nil {
			field = *h.Field
		}
		if strings.HasPrefix(field, "body.") {
			field = strings.TrimPrefix(field, "body.")
		}
		issues = append(issues, &tools.FieldIssue{Field: field, Constraint: h.Name})
	}
	if len(issues) == 0 {
		return err
	}
	return &ValidationError{
		msg:    err.Error(),
		issues: issues,
	}
}
func enrichValidatePayloadValidationError(err error) error {
	ve, ok := err.(*ValidationError)
	if !ok || ve == nil {
		return err
	}
	if len(ve.issues) == 0 {
		return err
	}
	m := make(map[string]string)
	for _, is := range ve.issues {
		if d, ok := ValidatePayloadFieldDescs[is.Field]; ok && d != "" {
			m[is.Field] = d
		}
	}
	ve.descriptions = m
	return ve
}
func enrichValidateResultValidationError(err error) error {
	ve, ok := err.(*ValidationError)
	if !ok || ve == nil {
		return err
	}
	if len(ve.issues) == 0 {
		return err
	}
	m := make(map[string]string)
	for _, is := range ve.issues {
		if d, ok := ValidateResultFieldDescs[is.Field]; ok && d != "" {
			m[is.Field] = d
		}
	}
	ve.descriptions = m
	return ve
}

// PayloadCodec returns the generic codec for the named tool payload.
func PayloadCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "deep.validate":
		return &validatePayloadCodec, true
	default:
		return nil, false
	}
}

// ResultCodec returns the generic codec for the named tool result.
func ResultCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	case "deep.validate":
		return &validateResultCodec, true
	default:
		return nil, false
	}
}

// ServerDataCodec returns the generic codec for the named tool optional
// server-data payload when declared.
func ServerDataCodec(name string) (*tools.JSONCodec[any], bool) {
	switch name {
	default:
		return nil, false
	}
}

// MarshalValidatePayload serializes *ValidatePayload into JSON.
func MarshalValidatePayload(v *ValidatePayload) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("validatePayload is nil")
	}
	in := v
	_ = in
	var out *toolhttp.ValidatePayloadTransport
	out = &toolhttp.ValidatePayloadTransport{
		Root: &in.Root,
	}
	out.Child = encodeLevel2ToToolhttpLevel2Transport(in.Child)
	return json.Marshal(out)
}

// UnmarshalValidatePayload deserializes JSON into *ValidatePayload.
func UnmarshalValidatePayload(data []byte) (*ValidatePayload, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("validatePayload JSON is empty")
	}
	var tv toolhttp.ValidatePayloadTransport
	if err := json.Unmarshal(data, &tv); err != nil {
		return nil, fmt.Errorf("decode validatePayload: %w", err)
	}
	if err := toolhttp.ValidateValidatePayloadTransport(&tv); err != nil {
		err = newValidationError(err)
		err = enrichValidatePayloadValidationError(err)
		return nil, err
	}
	in := &tv
	_ = in
	var out *ValidatePayload
	out = &ValidatePayload{
		Root: *in.Root,
	}
	out.Child = decodeToolhttpLevel2TransportToLevel2(in.Child)
	return out, nil
}

// MarshalValidateResult serializes *ValidateResult into JSON.
func MarshalValidateResult(v *ValidateResult) ([]byte, error) {
	if v == nil {
		return nil, fmt.Errorf("validateResult is nil")
	}
	in := v
	_ = in
	var out *toolhttp.ValidateResultTransport
	out = &toolhttp.ValidateResultTransport{
		Root: &in.Root,
	}
	out.Child = encodeLevel2ToToolhttpLevel2Transport(in.Child)
	return json.Marshal(out)
}

// UnmarshalValidateResult deserializes JSON into *ValidateResult.
func UnmarshalValidateResult(data []byte) (*ValidateResult, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("validateResult JSON is empty")
	}
	var tv toolhttp.ValidateResultTransport
	if err := json.Unmarshal(data, &tv); err != nil {
		return nil, fmt.Errorf("decode validateResult: %w", err)
	}
	if err := toolhttp.ValidateValidateResultTransport(&tv); err != nil {
		err = newValidationError(err)
		err = enrichValidateResultValidationError(err)
		return nil, err
	}
	in := &tv
	_ = in
	var out *ValidateResult
	out = &ValidateResult{
		Root: *in.Root,
	}
	out.Child = decodeToolhttpLevel2TransportToLevel2(in.Child)
	return out, nil
}

// Helper transform functions
func decodeToolhttpLevel2TransportToLevel2(v *toolhttp.Level2Transport) *Level2 {
	res := &Level2{
		Mid: *v.Mid,
	}
	res.Child = decodeToolhttpLevel3TransportToLevel3(v.Child)

	return res
}
func decodeToolhttpLevel3TransportToLevel3(v *toolhttp.Level3Transport) *Level3 {
	res := &Level3{
		Leaf: *v.Leaf,
	}

	return res
}
func encodeLevel2ToToolhttpLevel2Transport(v *Level2) *toolhttp.Level2Transport {
	res := &toolhttp.Level2Transport{
		Mid: &v.Mid,
	}
	res.Child = encodeLevel3ToToolhttpLevel3Transport(v.Child)

	return res
}
func encodeLevel3ToToolhttpLevel3Transport(v *Level3) *toolhttp.Level3Transport {
	res := &toolhttp.Level3Transport{
		Leaf: &v.Leaf,
	}

	return res
}
