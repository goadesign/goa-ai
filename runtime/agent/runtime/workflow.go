package runtime

// workflow.go implements the durable plan/tool loop executed inside a workflow engine.
//
// Contract:
// - The workflow loop is deterministic and replay-safe: timeouts use workflow time.
// - The loop publishes lifecycle and tool events via hooks for streaming and persistence.
// - Helper methods in sibling workflow_*.go files are invoked by this loop; callers should
//   not call them directly outside of workflow execution.

import (
	"context"
	"errors"
	"fmt"
	"time"

	"goa.design/goa-ai/runtime/agent/engine"
	"goa.design/goa-ai/runtime/agent/hooks"
	"goa.design/goa-ai/runtime/agent/interrupt"
	"goa.design/goa-ai/runtime/agent/model"
	"goa.design/goa-ai/runtime/agent/planner"
	"goa.design/goa-ai/runtime/agent/policy"
	"goa.design/goa-ai/runtime/agent/run"
	"goa.design/goa-ai/runtime/agent/telemetry"
)

const (
	// Minimal viable timeout for scheduling an activity. If remaining time is
	// less than or equal to this value, the runtime should not schedule new work.
	minActivityTimeout = 3 * time.Second

	// Minimal viable grace period for finalization. If remaining time is
	// less than or equal to this value, the runtime should finalize with a user-facing message.
	defaultFinalizerGrace = 10 * time.Second
)

// ExecuteWorkflow is the main entry point for the generated workflow handler.
//
// Advanced & generated integration
//   - Intended to be invoked by code generated by goa-ai during agent
//     registration, or by advanced users writing custom engine adapters.
//   - Normal applications should prefer the highâ€‘level AgentClient API
//     (Runtime.Client(...).Run/Start) rather than calling this directly.
//
// It executes the agent's plan/tool loop using the configured planner, policy,
// and runtime hooks. Returns the final agent output or an error if the workflow
// fails. Generated code calls this from the workflow handler registered with
// the engine.
func (r *Runtime) ExecuteWorkflow(wfCtx engine.WorkflowContext, input *RunInput) (*RunOutput, error) {
	if r.logger != nil {
		r.logger.Info(wfCtx.Context(), "ExecuteWorkflow called", "agent_id", input.AgentID, "run_id", input.RunID)
	}
	if input.AgentID == "" {
		return nil, errors.New("agent id is required")
	}
	defer func() {
		r.storeWorkflowHandle(input.RunID, nil)
		if r.reminders != nil {
			r.reminders.ClearRun(input.RunID)
		}
	}()
	reg, ok := r.agentByID(input.AgentID)
	if !ok {
		return nil, fmt.Errorf("agent %q is not registered", input.AgentID)
	}
	r.logger.Info(wfCtx.Context(), "Agent found, executing plan activity", "agent_id", input.AgentID)
	ctrl := interrupt.NewController(wfCtx)
	runCtx := run.Context{
		RunID:            input.RunID,
		SessionID:        input.SessionID,
		TurnID:           input.TurnID,
		ParentToolCallID: input.ParentToolCallID,
		ParentRunID:      input.ParentRunID,
		ParentAgentID:    input.ParentAgentID,
		Tool:             input.Tool,
		ToolArgs:         input.ToolArgs,
		Attempt:          1,
		Labels:           input.Labels,
	}
	// Get turn ID for event stamping
	turnID := input.TurnID
	if err := r.publishHook(
		wfCtx.Context(),
		hooks.NewRunStartedEvent(input.RunID, input.AgentID, runCtx, *input),
		turnID,
	); err != nil {
		return nil, err
	}
	// Initial phase: input has been received and planning is about to begin.
	if err := r.publishHook(
		wfCtx.Context(),
		hooks.NewRunPhaseChangedEvent(input.RunID, input.AgentID, input.SessionID, run.PhasePrompted),
		turnID,
	); err != nil {
		return nil, err
	}
	finalStatus := runStatusSuccess
	var finalErr error
	defer func() {
		// Compute the terminal phase for the completion event.
		var phase run.Phase
		switch finalStatus {
		case runStatusSuccess:
			phase = run.PhaseCompleted
		case runStatusFailed:
			phase = run.PhaseFailed
		case runStatusCanceled:
			phase = run.PhaseCanceled
		default:
			phase = run.PhaseCompleted
		}
		// Use a fresh context with timeout for terminal events. The workflow
		// engine supplies a replay-aware context so subscribers can avoid
		// re-applying side effects during history replay while still allowing
		// session stores and UIs to observe a single terminal phase.
		//
		// Emit only RunCompletedEvent (which carries both status and phase).
		// Emitting a separate RunPhaseChangedEvent before RunCompleted causes
		// two terminal workflow events to reach subscribers, which can trigger
		// race conditions in frontends that close streams on the first
		// terminal event.
		detached := wfCtx.Detached()
		termCtx, cancel := context.WithTimeout(detached.Context(), 10*time.Second)
		defer cancel()
		if err := r.publishHookErr(
			termCtx,
			hooks.NewRunCompletedEvent(input.RunID, input.AgentID, input.SessionID, finalStatus, phase, finalErr),
			turnID,
		); err != nil {
			r.logWarn(termCtx, "run completed hook failed", err, "run_id", input.RunID, "agent_id", input.AgentID)
		}
	}()

	planInput := &planner.PlanInput{
		Messages:   input.Messages,
		RunContext: runCtx,
	}
	// Compute deadlines before the initial Plan so it cannot outlive the run window.
	var (
		timeBudget     time.Duration
		budgetDeadline time.Time
		hardDeadline   time.Time
		grace          time.Duration
	)
	{
		timeBudget = time.Duration(0)
		if input.Policy != nil && input.Policy.TimeBudget > 0 {
			timeBudget = input.Policy.TimeBudget
		} else if reg.Policy.TimeBudget > 0 {
			timeBudget = reg.Policy.TimeBudget
		}
		switch {
		case input.Policy != nil && input.Policy.FinalizerGrace > 0:
			grace = input.Policy.FinalizerGrace
		case reg.Policy.FinalizerGrace > 0:
			grace = reg.Policy.FinalizerGrace
		default:
			grace = defaultFinalizerGrace
		}
		// Finalization requires at least one planner resume activity. Ensure the
		// grace period can accommodate that activity's timeout; otherwise we can
		// deterministically hit the engine run timeout while finalizing.
		resumeTimeout := reg.ResumeActivityOptions.Timeout
		if input.Policy != nil && input.Policy.PlanTimeout > 0 {
			resumeTimeout = input.Policy.PlanTimeout
		}
		if resumeTimeout == 0 {
			// Keep this aligned with the Temporal engine default activity timeout.
			resumeTimeout = time.Minute
		}
		if grace < resumeTimeout {
			grace = resumeTimeout
		}
		if timeBudget > 0 {
			budgetDeadline = wfCtx.Now().Add(timeBudget)
			hardDeadline = budgetDeadline.Add(grace)
		}
	}
	startReq := PlanActivityInput{
		AgentID:    input.AgentID,
		RunID:      input.RunID,
		Messages:   input.Messages,
		RunContext: runCtx,
	}
	if err := enforcePlanActivityInputBudget(startReq); err != nil {
		finalErr = err
		finalStatus = runStatusFailed
		return nil, err
	}
	// Apply run-level Plan timeout override when provided.
	planOpts := reg.PlanActivityOptions
	if input.Policy != nil && input.Policy.PlanTimeout > 0 {
		planOpts.Timeout = input.Policy.PlanTimeout
	}
	// Emit timing resolution for observability.
	if r.logger != nil {
		var planTimeout time.Duration
		if planOpts.Timeout > 0 {
			planTimeout = planOpts.Timeout
		}
		toolTimeout := reg.ExecuteToolActivityOptions.Timeout
		if toolTimeout == 0 {
			toolTimeout = 2 * time.Minute
		}
		if input.Policy != nil && input.Policy.ToolTimeout > 0 {
			toolTimeout = input.Policy.ToolTimeout
		}
		r.logger.Info(wfCtx.Context(), "timing_resolved",
			"time_budget", timeBudget,
			"finalizer_grace", grace,
			"hard_deadline", hardDeadline,
			"plan_timeout", planTimeout,
			"tool_timeout", toolTimeout,
		)
	}
	// Transition into planning before invoking the planner activity.
	if err := r.publishHook(
		wfCtx.Context(),
		hooks.NewRunPhaseChangedEvent(input.RunID, input.AgentID, input.SessionID, run.PhasePlanning),
		turnID,
	); err != nil {
		finalErr = err
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
			finalStatus = runStatusCanceled
		} else {
			finalStatus = runStatusFailed
		}
		return nil, err
	}
	firstOutput, err := r.runPlanActivity(wfCtx, reg.PlanActivityName, planOpts, startReq, hardDeadline)
	if err != nil {
		r.logger.Error(wfCtx.Context(), "Plan activity failed", "error", err)
		finalErr = err
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
			finalStatus = runStatusCanceled
		} else {
			finalStatus = runStatusFailed
		}
		return nil, err
	}
	if firstOutput == nil || firstOutput.Result == nil {
		r.logger.Error(wfCtx.Context(), "Plan activity returned nil result")
		finalErr = fmt.Errorf("CRITICAL: Plan activity returned nil PlanResult")
		finalStatus = runStatusFailed
		return nil, finalErr
	}
	result := firstOutput.Result
	r.logger.Info(wfCtx.Context(), "Plan activity completed", "tool_calls", len(result.ToolCalls), "final_response", result.FinalResponse != nil)
	// CRITICAL: Validate PlanResult structure - if planner returned ToolCalls, they should be present
	if len(result.ToolCalls) == 0 && result.FinalResponse == nil && result.Await == nil {
		finalErr = fmt.Errorf("CRITICAL: PlanResult has no ToolCalls, FinalResponse, or Await - this should never happen")
		finalStatus = runStatusFailed
		return nil, finalErr
	}
	// CRITICAL: If ToolCalls is empty but planner returned them, serialization may have failed
	if len(result.ToolCalls) == 0 && result.FinalResponse != nil {
		r.logger.Info(wfCtx.Context(), "PlanResult has FinalResponse but no ToolCalls - workflow will return early")
	}
	caps := initialCaps(reg.Policy)
	// Apply per-run cap overrides (run-level)
	if input.Policy != nil {
		if input.Policy.MaxToolCalls > 0 {
			caps.MaxToolCalls = input.Policy.MaxToolCalls
			caps.RemainingToolCalls = input.Policy.MaxToolCalls
		}
		if input.Policy.MaxConsecutiveFailedToolCalls > 0 {
			caps.MaxConsecutiveFailedToolCalls = input.Policy.MaxConsecutiveFailedToolCalls
			caps.RemainingConsecutiveFailedToolCalls = input.Policy.MaxConsecutiveFailedToolCalls
		}
	}
	// Deadlines (budgetDeadline, hardDeadline, grace) already computed above.
	nextAttempt := planInput.RunContext.Attempt + 1
	r.logger.Info(wfCtx.Context(), "Starting runLoop", "tool_calls", len(result.ToolCalls))
	// Create parentTracker if this is a nested agent run (has ParentToolCallID)
	var parentTracker *childTracker
	if planInput.RunContext.ParentToolCallID != "" {
		parentTracker = newChildTracker(planInput.RunContext.ParentToolCallID)
	}
	// Enter tool execution phase for the main run loop.
	if err := r.publishHook(
		wfCtx.Context(),
		hooks.NewRunPhaseChangedEvent(input.RunID, input.AgentID, input.SessionID, run.PhaseExecutingTools),
		turnID,
	); err != nil {
		finalErr = err
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
			finalStatus = runStatusCanceled
		} else {
			finalStatus = runStatusFailed
		}
		return nil, err
	}
	out, err := r.runLoop(
		wfCtx,
		reg,
		input,
		planInput,
		firstOutput.Result,
		firstOutput.Transcript,
		firstOutput.Usage,
		caps,
		budgetDeadline,
		hardDeadline,
		nextAttempt,
		turnID,
		parentTracker,
		ctrl,
		grace,
	)
	if err != nil {
		finalErr = err
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
			finalStatus = runStatusCanceled
		} else {
			finalStatus = runStatusFailed
		}
		return nil, err
	}
	// Successful completion.
	finalStatus = runStatusSuccess
	finalErr = nil
	return out, nil
}

// runLoop executes the plan/tool/resume cycle until the planner returns a final response
// or a cap/deadline is exceeded. The turnID parameter enables turn-based event stamping.
func (r *Runtime) runLoop(
	wfCtx engine.WorkflowContext,
	reg AgentRegistration,
	input *RunInput,
	base *planner.PlanInput,
	initialResult *planner.PlanResult,
	initialTranscript []*model.Message,
	initialUsage model.TokenUsage,
	caps policy.CapsState,
	budgetDeadline time.Time,
	hardDeadline time.Time,
	nextAttempt int,
	turnID string,
	parentTracker *childTracker,
	ctrl *interrupt.Controller,
	finalizerGrace time.Duration,
) (*RunOutput, error) {
	if base == nil {
		return nil, errors.New("base plan input is required")
	}
	ctx := wfCtx.Context()
	if r.logger == nil {
		r.logger = telemetry.NoopLogger{}
	}
	if initialResult == nil {
		return nil, fmt.Errorf("CRITICAL: runLoop initial PlanResult is nil")
	}
	if len(initialResult.ToolCalls) == 0 && initialResult.FinalResponse == nil && initialResult.Await == nil {
		return nil, fmt.Errorf("CRITICAL: runLoop initial PlanResult has no ToolCalls, FinalResponse, or Await")
	}
	r.logger.Info(ctx, "runLoop starting iteration", "tool_calls", len(initialResult.ToolCalls), "final_response", initialResult.FinalResponse != nil, "await", initialResult.Await != nil)
	st := newRunLoopState(initialResult, initialTranscript, initialUsage, caps, nextAttempt)
	// Expose provider-ready messages via a workflow query for external rehydration.
	if err := wfCtx.SetQueryHandler("ledger_messages", func() ([]*model.Message, error) {
		return st.Ledger.BuildMessages(), nil
	}); err != nil {
		return nil, err
	}
	// Derive per-run overrides for Resume and Tools.
	resumeOpts := reg.ResumeActivityOptions
	if input.Policy != nil && input.Policy.PlanTimeout > 0 {
		resumeOpts.Timeout = input.Policy.PlanTimeout
	}
	toolOpts := reg.ExecuteToolActivityOptions
	if input.Policy != nil && input.Policy.ToolTimeout > 0 {
		toolOpts.Timeout = input.Policy.ToolTimeout
	}
	if toolOpts.Timeout == 0 {
		toolOpts.Timeout = 2 * time.Minute
	}

	loop := newWorkflowLoop(
		r,
		wfCtx,
		reg,
		input,
		base,
		st,
		turnID,
		ctrl,
		parentTracker,
		runDeadlines{
			Budget:         budgetDeadline,
			Hard:           hardDeadline,
			FinalizerGrace: finalizerGrace,
		},
		resumeOpts,
		toolOpts,
	)
	return loop.run()
}

// timeoutUntil returns the remaining duration until deadline, relative to now.
// The ok result is false when deadline is non-zero and has already elapsed.
func timeoutUntil(deadline, now time.Time) (time.Duration, bool) {
	if deadline.IsZero() {
		return 0, true
	}
	rem := deadline.Sub(now)
	if rem <= 0 {
		return 0, false
	}
	return rem, true
}
