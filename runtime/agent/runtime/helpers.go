package runtime

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"hash/fnv"
	"strconv"
	"strings"
	"unicode"

	"goa.design/goa-ai/runtime/agent/engine"
	"goa.design/goa-ai/runtime/agent/hooks"
	"goa.design/goa-ai/runtime/agent/model"
	"goa.design/goa-ai/runtime/agent/planner"
	"goa.design/goa-ai/runtime/agent/policy"
	"goa.design/goa-ai/runtime/agent/telemetry"
	"goa.design/goa-ai/runtime/agent/tools"
)

const (
	unknownID = "unknown"
	// maxHookPayloadBytes is a safety bound on the serialized hook payload passed
	// across the workflow/activity boundary. Exceeding Temporal's payload limit
	// terminates the workflow task; failing early keeps failures explicit and
	// debuggable.
	maxHookPayloadBytes = 1_000_000
)

// hasNonNullJSON reports whether raw contains a non-empty JSON value other than
// the literal `null`.
//
// json.RawMessage marshals nil slices as the bytes `null`. When crossing the
// workflow/activity boundary, an absent tool result payload may therefore
// round-trip as the literal bytes `null` even when the tool produced no result.
// Callers should treat `null` as "no payload" and skip decoding.
func hasNonNullJSON(raw json.RawMessage) bool {
	trimmed := bytes.TrimSpace(raw)
	return len(trimmed) > 0 && !bytes.Equal(trimmed, []byte("null"))
}

// NestedRunID generates a hierarchical run ID for nested agent execution.
// Format: "{parentRunID}/agent/{toolName}". If parentRunID is empty, returns
// "unknown/agent/{toolName}". This ensures nested agent runs are traceable back
// to their parent invocation.
//
// Generated code for agent-tools uses this to construct nested run contexts
// from the parent run metadata passed explicitly in ToolRequest.
func NestedRunID(parentRunID string, toolName tools.Ident) string {
	if parentRunID == "" {
		parentRunID = unknownID
	}
	return fmt.Sprintf("%s/agent/%s", parentRunID, toolName)
}

// NestedRunIDForToolCall generates a child workflow ID for agent-as-tool runs that
// is stable for a given tool invocation and unique across multiple invocations of
// the same tool within a single parent run.
//
// The base prefix matches NestedRunID: "{parentRunID}/agent/{toolName}".
// When toolCallID is set, a deterministic suffix is appended:
// "{parentRunID}/agent/{toolName}/{suffix}".
//
// This prevents Temporal child workflow ID collisions when planners invoke the
// same agent tool multiple times in one parent workflow.
func NestedRunIDForToolCall(parentRunID string, toolName tools.Ident, toolCallID string) string {
	base := NestedRunID(parentRunID, toolName)
	if toolCallID == "" {
		return base
	}
	return fmt.Sprintf("%s/%s", base, nestedRunIDSuffix(toolCallID))
}

// nestedRunIDSuffix returns a deterministic suffix for a nested run ID derived
// from the tool call id. It preserves compact provider IDs when possible, and
// otherwise uses a bounded hash suitable for workflow identifiers.
func nestedRunIDSuffix(toolCallID string) string {
	// Preserve readable provider IDs when they are already compact and unique.
	// Tool call IDs generated by providers are typically short (e.g., "tooluse_...").
	if strings.HasPrefix(toolCallID, "tooluse_") {
		return strings.ReplaceAll(toolCallID, "/", "-")
	}
	// Otherwise, hash to keep workflow IDs bounded and safe for Temporal.
	h := fnv.New64a()
	if _, err := h.Write([]byte(toolCallID)); err != nil {
		panic(fmt.Errorf("hash tool call id: %w", err))
	}
	return fmt.Sprintf("call-%016x", h.Sum64())
}

// generateDeterministicToolCallID creates a replay-safe tool-call ID using the
// run ID, optional turn ID, attempt counter, sanitized tool name, and the
// deterministic index of the tool within the current batch.
//
// Attempt is required to avoid ID collisions when the same run executes multiple
// tool batches within a single logical turn (for example when callers set TurnID
// to a constant run identifier). The runtime increments Attempt on each planner
// iteration so generated IDs remain unique within the run.
func generateDeterministicToolCallID(runID, turnID string, attempt int, toolName tools.Ident, index int) string {
	if runID == "" {
		runID = unknownID
	}
	if toolName == "" {
		toolName = "tool"
	}
	safeTool := strings.ReplaceAll(string(toolName), ".", "-")
	// Format: <runID>/<turnID|no-turn>/attempt-<attempt>/<tool>/<index>
	tid := turnID
	if tid == "" {
		tid = "no-turn"
	}
	return strings.Join([]string{runID, tid, fmt.Sprintf("attempt-%d", attempt), safeTool, strconv.Itoa(index)}, "/")
}

// generateDeterministicAwaitID creates a replay-safe await identifier using the runID,
// optional turnID, the tool name, and the originating tool call ID when available.
// The format mirrors other runtime IDs for ease of correlation:
// <runID>/<turnID|no-turn>/<tool>/await/<toolCallID|no-call>
func generateDeterministicAwaitID(runID, turnID string, tool tools.Ident, toolCallID string) string {
	if runID == "" {
		runID = unknownID
	}
	safeTool := strings.ReplaceAll(string(tool), ".", "-")
	if safeTool == "" {
		safeTool = "tool"
	}
	tid := turnID
	if tid == "" {
		tid = "no-turn"
	}
	if toolCallID == "" {
		toolCallID = "no-call"
	}
	return strings.Join([]string{runID, tid, safeTool, "await", toolCallID}, "/")
}

// agentMessageText concatenates text parts from a model.Message.
func agentMessageText(msg *model.Message) string {
	if msg == nil || len(msg.Parts) == 0 {
		return ""
	}
	var b strings.Builder
	for _, p := range msg.Parts {
		// Skip ThinkingPart to avoid leaking non-user-facing reasoning.
		if _, isThinking := p.(model.ThinkingPart); isThinking {
			continue
		}
		if tp, ok := p.(model.TextPart); ok && tp.Text != "" {
			b.WriteString(tp.Text)
		}
	}
	return b.String()
}

// transcriptText concatenates assistant-visible text across a transcript.
// It ignores thinking/tool parts and returns an empty string when there is
// no user-facing text.
func transcriptText(msgs []*model.Message) string {
	if len(msgs) == 0 {
		return ""
	}
	var b strings.Builder
	for _, msg := range msgs {
		if msg == nil {
			continue
		}
		if text := agentMessageText(msg); text != "" {
			b.WriteString(text)
		}
	}
	return b.String()
}

// newTextAgentMessage builds a model.Message with a single TextPart.
// Returns nil when text is empty to allow callers to skip no-op messages.
func newTextAgentMessage(role model.ConversationRole, text string) *model.Message {
	if text == "" {
		return nil
	}
	return &model.Message{
		Role:  role,
		Parts: []model.Part{model.TextPart{Text: text}},
	}
}

// isZeroRetryPolicy checks if a retry policy is effectively zero (no retries configured).
func isZeroRetryPolicy(policy engine.RetryPolicy) bool {
	return policy.MaxAttempts == 0 && policy.InitialInterval == 0 && policy.BackoffCoefficient == 0
}

// cloneLabels creates a defensive copy of a string map. Returns nil if the source
// map is empty to avoid unnecessary allocations.
func cloneLabels(src map[string]string) map[string]string {
	if len(src) == 0 {
		return nil
	}
	dst := make(map[string]string, len(src))
	for k, v := range src {
		dst[k] = v
	}
	return dst
}

// cloneMetadata creates a defensive copy of an arbitrary metadata map.
// It returns nil if the source map is empty to avoid unnecessary allocations.
func cloneMetadata(src map[string]any) map[string]any {
	if len(src) == 0 {
		return nil
	}
	dst := make(map[string]any, len(src))
	for k, v := range src {
		dst[k] = v
	}
	return dst
}

// cloneStrings creates a defensive copy of a string slice.
// It returns nil if the source slice is empty to avoid unnecessary allocations.
func cloneStrings(src []string) []string {
	if len(src) == 0 {
		return nil
	}
	dst := make([]string, len(src))
	copy(dst, src)
	return dst
}

// cloneToolResults creates a shallow copy of a tool result slice by copying the
// ToolResult struct values. It does not deep-copy nested fields.
func cloneToolResults(src []*planner.ToolResult) []*planner.ToolResult {
	if len(src) == 0 {
		return nil
	}
	out := make([]*planner.ToolResult, 0, len(src))
	for _, tr := range src {
		if tr == nil {
			out = append(out, nil)
			continue
		}
		cp := *tr
		out = append(out, &cp)
	}
	return out
}

func addTokenUsage(current, delta model.TokenUsage) model.TokenUsage {
	return model.TokenUsage{
		InputTokens:      current.InputTokens + delta.InputTokens,
		OutputTokens:     current.OutputTokens + delta.OutputTokens,
		TotalTokens:      current.TotalTokens + delta.TotalTokens,
		CacheReadTokens:  current.CacheReadTokens + delta.CacheReadTokens,
		CacheWriteTokens: current.CacheWriteTokens + delta.CacheWriteTokens,
	}
}

// mergeLabels merges src labels into dst. When dst is nil, it allocates a new
// map sized to src. When src is empty, it returns dst unchanged.
func mergeLabels(dst map[string]string, src map[string]string) map[string]string {
	if len(src) == 0 {
		return dst
	}
	if dst == nil {
		dst = make(map[string]string, len(src))
	}
	for k, v := range src {
		dst[k] = v
	}
	return dst
}

// handlesToIDs removed: policy uses []tools.Ident directly.

func toPolicyRetryHint(hint *planner.RetryHint) *policy.RetryHint {
	if hint == nil {
		return nil
	}
	return &policy.RetryHint{
		Reason:             policy.RetryReason(hint.Reason),
		Tool:               hint.Tool,
		RestrictToTool:     hint.RestrictToTool,
		MissingFields:      cloneStrings(hint.MissingFields),
		ExampleInput:       cloneMetadata(hint.ExampleInput),
		PriorInput:         cloneMetadata(hint.PriorInput),
		ClarifyingQuestion: hint.ClarifyingQuestion,
		Message:            hint.Message,
	}
}

// applyHistoryPolicy applies the agent's history policy to the given messages.
// When no policy is configured or the policy returns an error, messages are
// returned unchanged. An empty slice from the policy is treated as a no-op to
// avoid accidentally wiping history.
func (r *Runtime) applyHistoryPolicy(ctx context.Context, reg *AgentRegistration, msgs []*model.Message) []*model.Message {
	if reg.Policy.History == nil || len(msgs) == 0 {
		return msgs
	}
	out, err := reg.Policy.History(ctx, msgs)
	if err != nil {
		r.logWarn(ctx, "history policy failed", err, "agent_id", reg.ID)
		return msgs
	}
	if len(out) == 0 {
		return msgs
	}
	return out
}

// logWarn emits a warning log and records the error in the current span if tracing
// is enabled. If the logger is nil, this is a no-op.
func (r *Runtime) logWarn(ctx context.Context, msg string, err error, kv ...any) {
	fields := append([]any{}, kv...)
	if err != nil {
		fields = append(fields, "err", err)
	}
	r.logger.Warn(ctx, msg, fields...)
	if err != nil {
		span := r.tracer.Span(ctx)
		if span != nil {
			span.RecordError(err)
		}
	}
}

// publishHookErr emits a runtime hook event and returns an error on failure.
//
// When called from workflow code (ctx carries engine.WorkflowContext), publishHookErr
// schedules the runtime hook activity. Outside workflows, it calls the hook
// activity directly. In both cases, the hook activity is responsible for
// appending the event to the canonical run log before publishing to the bus.
//
// This function exists because runtime hook emission is semantically split:
//   - Run event log append is canonical and must succeed (hard correctness invariant).
//   - Hook bus publish is best-effort and must not fail the workflow (used for live UX).
//
// Callers in non-workflow/server code should prefer publishHookErr and propagate
// the error. Workflow loop code may choose to treat failures as fatal via
// publishHook (panic) to avoid silent divergence.
func (r *Runtime) publishHookErr(ctx context.Context, evt hooks.Event, turnID string) error {
	in, err := hooks.EncodeToHookInput(evt, turnID)
	if err != nil {
		return err
	}
	if len(in.Payload) > maxHookPayloadBytes {
		return fmt.Errorf("hook payload too large for %s: %d bytes (limit %d)", string(evt.Type()), len(in.Payload), maxHookPayloadBytes)
	}
	if wfCtx := engine.WorkflowContextFromContext(ctx); wfCtx != nil && !engine.IsActivityContext(ctx) {
		return wfCtx.PublishHook(ctx, engine.HookActivityCall{
			Name:  hookActivityName,
			Input: in,
		})
	}
	return r.hookActivity(ctx, in)
}

// publishHook emits a runtime hook event and returns an error on failure.
//
// Note that bus publish failures do not cause publishHookErr to return an error;
// only failures to encode, dispatch the hook activity, or append to the canonical
// run log are considered fatal.
func (r *Runtime) publishHook(ctx context.Context, evt hooks.Event, turnID string) error {
	return r.publishHookErr(ctx, evt, turnID)
}

// initialCaps constructs the initial caps state from the agent's run policy.
// If caps are configured (> 0), the remaining counts are set to match the maximums.
func initialCaps(cfg RunPolicy) policy.CapsState {
	caps := policy.CapsState{
		MaxToolCalls:                  cfg.MaxToolCalls,
		MaxConsecutiveFailedToolCalls: cfg.MaxConsecutiveFailedToolCalls,
	}
	if cfg.MaxToolCalls > 0 {
		caps.RemainingToolCalls = cfg.MaxToolCalls
	}
	if cfg.MaxConsecutiveFailedToolCalls > 0 {
		caps.RemainingConsecutiveFailedToolCalls = cfg.MaxConsecutiveFailedToolCalls
	}
	return caps
}

// decrementCap decrements a cap value by delta. If current is 0 (unlimited), returns 0.
// If the result would be negative, returns 0.
func decrementCap(current int, delta int) int {
	if current == 0 || delta == 0 {
		return current
	}
	result := current - delta
	if result < 0 {
		return 0
	}
	return result
}

// capFailures counts tool failures that should decrement the consecutive-failure cap.
//
// Contract:
//   - "missing_fields" and "invalid_arguments" failures are considered recoverable
//     contract errors when surfaced with a RetryHint; they should not immediately
//     trip the run-level failure cap before the planner gets a chance to retry with
//     corrected inputs (typically guided by the retry-hint system reminder).
func capFailures(results []*planner.ToolResult) int {
	count := 0
	for _, res := range results {
		if res == nil || res.Error == nil {
			continue
		}
		if h := res.RetryHint; h != nil {
			switch h.Reason {
			case planner.RetryReasonMissingFields, planner.RetryReasonInvalidArguments, planner.RetryReasonToolUnavailable:
				continue
			case planner.RetryReasonMalformedResponse,
				planner.RetryReasonTimeout,
				planner.RetryReasonRateLimited:
				// Count towards the consecutive-failure cap.
			default:
				panic(fmt.Sprintf("runtime: unknown retry reason %q", h.Reason))
			}
		}
		count++
	}
	return count
}

// mergeCaps merges policy decision caps into the current caps state. Decision caps
// override current caps if they are > 0 or if ExpiresAt is set.
func mergeCaps(current policy.CapsState, decision policy.CapsState) policy.CapsState {
	if decision.MaxToolCalls > 0 {
		current.MaxToolCalls = decision.MaxToolCalls
	}
	if decision.RemainingToolCalls > 0 {
		current.RemainingToolCalls = decision.RemainingToolCalls
	}
	if decision.MaxConsecutiveFailedToolCalls > 0 {
		current.MaxConsecutiveFailedToolCalls = decision.MaxConsecutiveFailedToolCalls
	}
	if decision.RemainingConsecutiveFailedToolCalls > 0 {
		current.RemainingConsecutiveFailedToolCalls = decision.RemainingConsecutiveFailedToolCalls
	}
	if !decision.ExpiresAt.IsZero() {
		current.ExpiresAt = decision.ExpiresAt
	}
	return current
}

// toolHandles converts tool call requests into policy tool handles for policy evaluation.
func toolHandles(calls []planner.ToolRequest) []tools.Ident {
	handles := make([]tools.Ident, len(calls))
	for i, call := range calls {
		handles[i] = call.Name
	}
	return handles
}

// hasIntersection reports whether two string slices share at least one common value.
func hasIntersection(a []string, b []string) bool {
	if len(a) == 0 || len(b) == 0 {
		return false
	}
	set := make(map[string]struct{}, len(a))
	for _, v := range a {
		set[v] = struct{}{}
	}
	for _, v := range b {
		if _, ok := set[v]; ok {
			return true
		}
	}
	return false
}

// toolMetadata retrieves policy metadata for each tool call by looking up the
// toolset registration. If the toolset is not found, constructs minimal metadata
// with the tool name.
func (r *Runtime) toolMetadata(calls []planner.ToolRequest) []policy.ToolMetadata {
	metas := make([]policy.ToolMetadata, 0, len(calls))
	for _, call := range calls {
		if spec, ok := r.toolSpec(call.Name); ok {
			metas = append(metas, policy.ToolMetadata{
				ID:          spec.Name,
				Title:       defaultToolTitle(spec.Name),
				Description: spec.Description,
				Tags:        append([]string(nil), spec.Tags...),
			})
			continue
		}
		metas = append(metas, policy.ToolMetadata{
			ID:    call.Name,
			Title: defaultToolTitle(call.Name),
		})
	}
	return metas
}

// defaultToolTitle derives a human-friendly title from a fully-qualified tool id.
// It uses the last segment after '.' and converts snake_case/kebab-case to Title Case.
func defaultToolTitle(id tools.Ident) string {
	s := string(id)
	// take last segment after '.'
	if last := lastSegment(s, '.'); last != "" {
		s = last
	}
	// Normalize separators to spaces
	s = strings.ReplaceAll(s, "_", " ")
	s = strings.ReplaceAll(s, "-", " ")
	// Collapse multiple spaces
	s = strings.Join(strings.Fields(s), " ")
	// Title-case words
	var b strings.Builder
	for i, w := range strings.Fields(s) {
		if i > 0 {
			b.WriteByte(' ')
		}
		if len(w) == 0 {
			continue
		}
		r := []rune(w)
		r[0] = unicode.ToUpper(r[0])
		for j := 1; j < len(r); j++ {
			r[j] = unicode.ToLower(r[j])
		}
		b.WriteString(string(r))
	}
	return b.String()
}

// lastSegment returns the last segment of a string after the last separator.
func lastSegment(s string, sep rune) string {
	for i := len(s) - 1; i >= 0; i-- {
		if rune(s[i]) == sep {
			if i+1 < len(s) {
				return s[i+1:]
			}
			return ""
		}
	}
	return s
}

// filterToolCalls filters tool calls to only those present in the allowed list.
// If the allowed list is empty, returns all calls unchanged.
func filterToolCalls(calls []planner.ToolRequest, allowed []tools.Ident) []planner.ToolRequest {
	if len(allowed) == 0 {
		return calls
	}
	allow := make(map[tools.Ident]struct{}, len(allowed))
	for _, id := range allowed {
		allow[id] = struct{}{}
	}
	filtered := make([]planner.ToolRequest, 0, len(calls))
	for _, call := range calls {
		if _, ok := allow[call.Name]; ok {
			filtered = append(filtered, call)
		}
	}
	return filtered
}

// serverDataDisabled reports whether the server-data mode explicitly disables
// optional server-data emission for a tool call.
func serverDataDisabled(mode tools.ServerDataMode) bool {
	return mode == tools.ServerDataModeOff
}

// normalizeServerDataMode canonicalizes the user-provided server-data toggle.
// Valid values are "auto", "on", and "off". Unknown values return "".
func normalizeServerDataMode(raw string) tools.ServerDataMode {
	return tools.ParseServerDataMode(raw)
}

// extractServerDataMode extracts the reserved "server_data" field from a tool call
// payload (if present), returns its normalized value, and returns a copy of the
// payload with the field removed.
//
// The function only attempts extraction for JSON objects; non-object payloads
// are returned unchanged.
func extractServerDataMode(raw json.RawMessage) (tools.ServerDataMode, json.RawMessage, error) {
	trimmed := bytes.TrimSpace(raw)
	if len(trimmed) == 0 || trimmed[0] != '{' {
		return "", raw, nil
	}
	var obj map[string]json.RawMessage
	if err := json.Unmarshal(trimmed, &obj); err != nil {
		return "", raw, fmt.Errorf("decode tool payload JSON: %w", err)
	}
	field, ok := obj["server_data"]
	if !ok {
		return "", raw, nil
	}
	var modeVal string
	if err := json.Unmarshal(field, &modeVal); err != nil {
		return "", raw, fmt.Errorf("decode server_data mode: %w", err)
	}
	delete(obj, "server_data")
	stripped, err := json.Marshal(obj)
	if err != nil {
		return "", raw, fmt.Errorf("strip server_data mode: %w", err)
	}
	return normalizeServerDataMode(modeVal), stripped, nil
}

// ConvertRunOutputToToolResult converts a nested agent RunOutput into a
// planner.ToolResult suitable for returning from an agent-as-tool executor.
//
// The final assistant message content is extracted as the tool result payload (string).
// Telemetry from all nested tool executions is aggregated into a single ToolTelemetry
// summary, enabling proper cost/token tracking across agent-as-tool boundaries.
//
// Artifacts are intentionally NOT propagated to the parent tool result. Artifacts must
// remain attached to the tool events that produced them so that:
//   - only tools that declare a sidecar schema/codec can emit artifacts, and
//   - UIs can render artifacts at the correct tool result node in nested tool trees.
//
// Error propagation: If the nested agent executed tools and ALL of them failed, the
// ToolResult.Error field is set with a summary. This allows the parent planner to
// react appropriately (retry, skip, or abort) rather than treating a failed nested
// agent as a successful tool execution.
//
// Planner notes are currently discarded. Future enhancement: include notes as structured
// metadata or append them to the payload content for visibility to the parent planner.
func ConvertRunOutputToToolResult(toolName tools.Ident, output *RunOutput) planner.ToolResult {
	var resultContent string
	if output.Final != nil {
		resultContent = agentMessageText(output.Final)
	}
	result := planner.ToolResult{
		Name:   toolName,
		Result: resultContent,
	}
	// Record child count for agent-as-tool detection in the runtime.
	result.ChildrenCount = len(output.ToolEvents)

	// Aggregate telemetry and track failures from all nested tool executions
	if len(output.ToolEvents) > 0 {
		var totalTokens int
		var totalDurationMs int64
		var models []string
		var failedCount int
		var lastError error
		modelSeen := make(map[string]bool)

		for _, event := range output.ToolEvents {
			if event.Telemetry != nil {
				totalTokens += event.Telemetry.TokensUsed
				totalDurationMs += event.Telemetry.DurationMs
				if event.Telemetry.Model != "" && !modelSeen[event.Telemetry.Model] {
					models = append(models, event.Telemetry.Model)
					modelSeen[event.Telemetry.Model] = true
				}
			}
			// Track tool failures
			if event.Error != nil {
				failedCount++
				lastError = event.Error
			}
		}

		// If ALL tools failed, propagate error to parent planner
		if failedCount > 0 && failedCount == len(output.ToolEvents) {
			if failedCount == 1 {
				result.Error = planner.NewToolErrorWithCause(fmt.Sprintf("agent-tool %q: nested tool failed", toolName), lastError)
			} else {
				result.Error = planner.NewToolErrorWithCause(fmt.Sprintf("agent-tool %q: all %d nested tools failed", toolName, failedCount), lastError)
			}
		}

		// Create aggregated telemetry if we collected any data
		if totalTokens > 0 || totalDurationMs > 0 || len(models) > 0 {
			result.Telemetry = &telemetry.ToolTelemetry{
				TokensUsed: totalTokens,
				DurationMs: totalDurationMs,
			}
			// If multiple models were used, record first one
			if len(models) > 0 {
				result.Telemetry.Model = models[0]
			}
		}
	}

	return result
}
