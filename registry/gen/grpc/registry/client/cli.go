// Code generated by goa v3.23.1, DO NOT EDIT.
//
// registry gRPC client CLI support package
//
// Command:
// $ goa gen goa.design/goa-ai/registry/design -o registry

package client

import (
	"encoding/json"
	"fmt"

	registrypb "goa.design/goa-ai/registry/gen/grpc/registry/pb"
	registry "goa.design/goa-ai/registry/gen/registry"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// BuildRegisterPayload builds the payload for the registry Register endpoint
// from CLI flags.
func BuildRegisterPayload(registryRegisterMessage string) (*registry.RegisterPayload, error) {
	var err error
	var message registrypb.RegisterRequest
	{
		if registryRegisterMessage != "" {
			err = json.Unmarshal([]byte(registryRegisterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Tools for data processing and analysis\",\n      \"name\": \"data-tools\",\n      \"tags\": [\n         \"data\",\n         \"etl\",\n         \"analytics\"\n      ],\n      \"tools\": [\n         {\n            \"description\": \"Analyze data and return insights\",\n            \"input_schema\": \"TnVsbGEgbm9iaXMu\",\n            \"name\": \"analyze\",\n            \"output_schema\": \"UmVydW0gYWNjdXNhbnRpdW0gYXNwZXJpb3JlcyBldCByYXRpb25lLg==\"\n         },\n         {\n            \"description\": \"Analyze data and return insights\",\n            \"input_schema\": \"TnVsbGEgbm9iaXMu\",\n            \"name\": \"analyze\",\n            \"output_schema\": \"UmVydW0gYWNjdXNhbnRpdW0gYXNwZXJpb3JlcyBldCByYXRpb25lLg==\"\n         },\n         {\n            \"description\": \"Analyze data and return insights\",\n            \"input_schema\": \"TnVsbGEgbm9iaXMu\",\n            \"name\": \"analyze\",\n            \"output_schema\": \"UmVydW0gYWNjdXNhbnRpdW0gYXNwZXJpb3JlcyBldCByYXRpb25lLg==\"\n         }\n      ],\n      \"version\": \"1.0.0\"\n   }'")
			}
		}
	}
	v := &registry.RegisterPayload{
		Name:        message.Name,
		Description: message.Description,
		Version:     message.Version,
	}
	if message.Tags != nil {
		v.Tags = make([]string, len(message.Tags))
		for i, val := range message.Tags {
			v.Tags[i] = val
		}
	}
	if message.Tools != nil {
		v.Tools = make([]*registry.ToolSchema, len(message.Tools))
		for i, val := range message.Tools {
			v.Tools[i] = &registry.ToolSchema{
				Name:         val.Name,
				Description:  val.Description,
				InputSchema:  val.InputSchema,
				OutputSchema: val.OutputSchema,
			}
		}
	}

	return v, nil
}

// BuildUnregisterPayload builds the payload for the registry Unregister
// endpoint from CLI flags.
func BuildUnregisterPayload(registryUnregisterMessage string) (*registry.UnregisterPayload, error) {
	var err error
	var message registrypb.UnregisterRequest
	{
		if registryUnregisterMessage != "" {
			err = json.Unmarshal([]byte(registryUnregisterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.UnregisterPayload{
		Name: message.Name,
	}

	return v, nil
}

// BuildEmitToolResultPayload builds the payload for the registry
// EmitToolResult endpoint from CLI flags.
func BuildEmitToolResultPayload(registryEmitToolResultMessage string) (*registry.EmitToolResultPayload, error) {
	var err error
	var message registrypb.EmitToolResultRequest
	{
		if registryEmitToolResultMessage != "" {
			err = json.Unmarshal([]byte(registryEmitToolResultMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"error\": {\n         \"code\": \"execution_failed\",\n         \"message\": \"Failed to connect to database\"\n      },\n      \"result\": \"Ab assumenda.\",\n      \"tool_use_id\": \"call-abc123\"\n   }'")
			}
		}
	}
	v := &registry.EmitToolResultPayload{
		ToolUseID: message.ToolUseId,
		Result: func() any {
			if message.Result != nil {
				var value structpb.Value
				if err := message.Result.UnmarshalTo(&value); err == nil {
					if str := value.GetStringValue(); str != "" {
						var result any
						if err := json.Unmarshal([]byte(str), &result); err == nil {
							return result
						}
					}
				}
			}
			return nil
		}(),
	}
	if message.Error != nil {
		v.Error = protobufRegistrypbToolErrorToRegistryToolError(message.Error)
	}

	return v, nil
}

// BuildPongPayload builds the payload for the registry Pong endpoint from CLI
// flags.
func BuildPongPayload(registryPongMessage string) (*registry.PongPayload, error) {
	var err error
	var message registrypb.PongRequest
	{
		if registryPongMessage != "" {
			err = json.Unmarshal([]byte(registryPongMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ping_id\": \"ping-xyz789\",\n      \"toolset\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.PongPayload{
		PingID:  message.PingId,
		Toolset: message.Toolset,
	}

	return v, nil
}

// BuildListToolsetsPayload builds the payload for the registry ListToolsets
// endpoint from CLI flags.
func BuildListToolsetsPayload(registryListToolsetsMessage string) (*registry.ListToolsetsPayload, error) {
	var err error
	var message registrypb.ListToolsetsRequest
	{
		if registryListToolsetsMessage != "" {
			err = json.Unmarshal([]byte(registryListToolsetsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tags\": [\n         \"data\",\n         \"etl\"\n      ]\n   }'")
			}
		}
	}
	v := &registry.ListToolsetsPayload{}
	if message.Tags != nil {
		v.Tags = make([]string, len(message.Tags))
		for i, val := range message.Tags {
			v.Tags[i] = val
		}
	}

	return v, nil
}

// BuildGetToolsetPayload builds the payload for the registry GetToolset
// endpoint from CLI flags.
func BuildGetToolsetPayload(registryGetToolsetMessage string) (*registry.GetToolsetPayload, error) {
	var err error
	var message registrypb.GetToolsetRequest
	{
		if registryGetToolsetMessage != "" {
			err = json.Unmarshal([]byte(registryGetToolsetMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.GetToolsetPayload{
		Name: message.Name,
	}

	return v, nil
}

// BuildSearchPayload builds the payload for the registry Search endpoint from
// CLI flags.
func BuildSearchPayload(registrySearchMessage string) (*registry.SearchPayload, error) {
	var err error
	var message registrypb.SearchRequest
	{
		if registrySearchMessage != "" {
			err = json.Unmarshal([]byte(registrySearchMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"query\": \"data processing\"\n   }'")
			}
		}
	}
	v := &registry.SearchPayload{
		Query: message.Query,
	}

	return v, nil
}

// BuildCallToolPayload builds the payload for the registry CallTool endpoint
// from CLI flags.
func BuildCallToolPayload(registryCallToolMessage string) (*registry.CallToolPayload, error) {
	var err error
	var message registrypb.CallToolRequest
	{
		if registryCallToolMessage != "" {
			err = json.Unmarshal([]byte(registryCallToolMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"payload\": \"Occaecati deleniti error repudiandae ab occaecati minima.\",\n      \"tool\": \"analyze\",\n      \"toolset\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.CallToolPayload{
		Toolset: message.Toolset,
		Tool:    message.Tool,
		Payload: func() any {
			if message.Payload != nil {
				var value structpb.Value
				if err := message.Payload.UnmarshalTo(&value); err == nil {
					if str := value.GetStringValue(); str != "" {
						var result any
						if err := json.Unmarshal([]byte(str), &result); err == nil {
							return result
						}
					}
				}
			}
			return nil
		}(),
	}

	return v, nil
}
