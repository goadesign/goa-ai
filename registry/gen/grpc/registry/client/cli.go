// Code generated by goa v3.23.4, DO NOT EDIT.
//
// registry gRPC client CLI support package
//
// Command:
// $ goa gen goa.design/goa-ai/registry/design -o registry

package client

import (
	"encoding/json"
	"fmt"

	registrypb "goa.design/goa-ai/registry/gen/grpc/registry/pb"
	registry "goa.design/goa-ai/registry/gen/registry"
)

// BuildRegisterPayload builds the payload for the registry Register endpoint
// from CLI flags.
func BuildRegisterPayload(registryRegisterMessage string) (*registry.RegisterPayload, error) {
	var err error
	var message registrypb.RegisterRequest
	{
		if registryRegisterMessage != "" {
			err = json.Unmarshal([]byte(registryRegisterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Tools for data processing and analysis\",\n      \"name\": \"data-tools\",\n      \"tags\": [\n         \"data\",\n         \"etl\",\n         \"analytics\"\n      ],\n      \"tools\": [\n         {\n            \"description\": \"Fetch a time series for a point over a time window.\",\n            \"name\": \"atlas.read.get_time_series\",\n            \"payload_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJxdWVyeSI6eyJ0eXBlIjoic3RyaW5nIn19LCJyZXF1aXJlZCI6WyJxdWVyeSJdfQ==\",\n            \"result_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJvayI6eyJ0eXBlIjoiYm9vbGVhbiJ9fSwicmVxdWlyZWQiOlsib2siXX0=\",\n            \"sidecar_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJhcnRpZmFjdF9raW5kIjp7InR5cGUiOiJzdHJpbmcifX19\",\n            \"tags\": [\n               \"atlas\",\n               \"data\",\n               \"read\"\n            ]\n         },\n         {\n            \"description\": \"Fetch a time series for a point over a time window.\",\n            \"name\": \"atlas.read.get_time_series\",\n            \"payload_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJxdWVyeSI6eyJ0eXBlIjoic3RyaW5nIn19LCJyZXF1aXJlZCI6WyJxdWVyeSJdfQ==\",\n            \"result_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJvayI6eyJ0eXBlIjoiYm9vbGVhbiJ9fSwicmVxdWlyZWQiOlsib2siXX0=\",\n            \"sidecar_schema\": \"eyJ0eXBlIjoib2JqZWN0IiwicHJvcGVydGllcyI6eyJhcnRpZmFjdF9raW5kIjp7InR5cGUiOiJzdHJpbmcifX19\",\n            \"tags\": [\n               \"atlas\",\n               \"data\",\n               \"read\"\n            ]\n         }\n      ],\n      \"version\": \"1.0.0\"\n   }'")
			}
		}
	}
	v := &registry.RegisterPayload{
		Name:        message.Name,
		Description: message.Description,
	}
	if message.Version != nil {
		version := registry.SemVer(*message.Version)
		v.Version = &version
	}
	if message.Tags != nil {
		v.Tags = make([]string, len(message.Tags))
		for i, val := range message.Tags {
			v.Tags[i] = val
		}
	}
	if message.Tools != nil {
		v.Tools = make([]*registry.ToolSchema, len(message.Tools))
		for i, val := range message.Tools {
			v.Tools[i] = &registry.ToolSchema{
				Name:          val.Name,
				Description:   val.Description,
				PayloadSchema: val.PayloadSchema,
				ResultSchema:  val.ResultSchema,
				SidecarSchema: val.SidecarSchema,
			}
			if val.Tags != nil {
				v.Tools[i].Tags = make([]string, len(val.Tags))
				for j, val := range val.Tags {
					v.Tools[i].Tags[j] = val
				}
			}
		}
	}

	return v, nil
}

// BuildUnregisterPayload builds the payload for the registry Unregister
// endpoint from CLI flags.
func BuildUnregisterPayload(registryUnregisterMessage string) (*registry.UnregisterPayload, error) {
	var err error
	var message registrypb.UnregisterRequest
	{
		if registryUnregisterMessage != "" {
			err = json.Unmarshal([]byte(registryUnregisterMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.UnregisterPayload{
		Name: message.Name,
	}

	return v, nil
}

// BuildPongPayload builds the payload for the registry Pong endpoint from CLI
// flags.
func BuildPongPayload(registryPongMessage string) (*registry.PongPayload, error) {
	var err error
	var message registrypb.PongRequest
	{
		if registryPongMessage != "" {
			err = json.Unmarshal([]byte(registryPongMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"ping_id\": \"ping-xyz789\",\n      \"toolset\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.PongPayload{
		PingID:  message.PingId,
		Toolset: message.Toolset,
	}

	return v, nil
}

// BuildListToolsetsPayload builds the payload for the registry ListToolsets
// endpoint from CLI flags.
func BuildListToolsetsPayload(registryListToolsetsMessage string) (*registry.ListToolsetsPayload, error) {
	var err error
	var message registrypb.ListToolsetsRequest
	{
		if registryListToolsetsMessage != "" {
			err = json.Unmarshal([]byte(registryListToolsetsMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tags\": [\n         \"data\",\n         \"etl\"\n      ]\n   }'")
			}
		}
	}
	v := &registry.ListToolsetsPayload{}
	if message.Tags != nil {
		v.Tags = make([]string, len(message.Tags))
		for i, val := range message.Tags {
			v.Tags[i] = val
		}
	}

	return v, nil
}

// BuildGetToolsetPayload builds the payload for the registry GetToolset
// endpoint from CLI flags.
func BuildGetToolsetPayload(registryGetToolsetMessage string) (*registry.GetToolsetPayload, error) {
	var err error
	var message registrypb.GetToolsetRequest
	{
		if registryGetToolsetMessage != "" {
			err = json.Unmarshal([]byte(registryGetToolsetMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"data-tools\"\n   }'")
			}
		}
	}
	v := &registry.GetToolsetPayload{
		Name: message.Name,
	}

	return v, nil
}

// BuildSearchPayload builds the payload for the registry Search endpoint from
// CLI flags.
func BuildSearchPayload(registrySearchMessage string) (*registry.SearchPayload, error) {
	var err error
	var message registrypb.SearchRequest
	{
		if registrySearchMessage != "" {
			err = json.Unmarshal([]byte(registrySearchMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"query\": \"data processing\"\n   }'")
			}
		}
	}
	v := &registry.SearchPayload{
		Query: message.Query,
	}

	return v, nil
}

// BuildCallToolPayload builds the payload for the registry CallTool endpoint
// from CLI flags.
func BuildCallToolPayload(registryCallToolMessage string) (*registry.CallToolPayload, error) {
	var err error
	var message registrypb.CallToolRequest
	{
		if registryCallToolMessage != "" {
			err = json.Unmarshal([]byte(registryCallToolMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"meta\": {\n         \"parent_tool_call_id\": \"call_01J3K9Q9T6E2G7N0G2ZQH2KX19Z\",\n         \"run_id\": \"run_01J3K9Q9T6E2G7N0G2ZQH2KX1A\",\n         \"session_id\": \"sess_01J3K9Q9T6E2G7N0G2ZQH2KX1A\",\n         \"tool_call_id\": \"call_01J3K9Q9T6E2G7N0G2ZQH2KX1A\",\n         \"turn_id\": \"turn_0001\"\n      },\n      \"payload_json\": \"eyJxdWVyeSI6ImNvbXByZXNzb3JfMSBrZXkgZXZlbnRzIn0=\",\n      \"tool\": \"atlas.read.get_time_series\",\n      \"toolset\": \"atlas_data.atlas.read\"\n   }'")
			}
		}
	}
	v := &registry.CallToolPayload{
		Toolset:     message.Toolset,
		Tool:        message.Tool,
		PayloadJSON: message.PayloadJson,
	}
	if message.Meta != nil {
		v.Meta = protobufRegistrypbToolCallMetaToRegistryToolCallMeta(message.Meta)
	}

	return v, nil
}
