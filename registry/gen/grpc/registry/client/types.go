// Code generated by goa v3.23.1, DO NOT EDIT.
//
// registry gRPC client types
//
// Command:
// $ goa gen goa.design/goa-ai/registry/design -o registry

package client

import (
	"encoding/json"
	"unicode/utf8"

	registrypb "goa.design/goa-ai/registry/gen/grpc/registry/pb"
	registry "goa.design/goa-ai/registry/gen/registry"
	goa "goa.design/goa/v3/pkg"
	anypb "google.golang.org/protobuf/types/known/anypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// NewProtoRegisterRequest builds the gRPC request type from the payload of the
// "Register" endpoint of the "registry" service.
func NewProtoRegisterRequest(payload *registry.RegisterPayload) *registrypb.RegisterRequest {
	message := &registrypb.RegisterRequest{
		Name:        payload.Name,
		Description: payload.Description,
		Version:     payload.Version,
	}
	if payload.Tags != nil {
		message.Tags = make([]string, len(payload.Tags))
		for i, val := range payload.Tags {
			message.Tags[i] = val
		}
	}
	if payload.Tools != nil {
		message.Tools = make([]*registrypb.ToolSchema, len(payload.Tools))
		for i, val := range payload.Tools {
			message.Tools[i] = &registrypb.ToolSchema{
				Name:         val.Name,
				Description:  val.Description,
				InputSchema:  val.InputSchema,
				OutputSchema: val.OutputSchema,
			}
		}
	}
	return message
}

// NewRegisterResult builds the result type of the "Register" endpoint of the
// "registry" service from the gRPC response type.
func NewRegisterResult(message *registrypb.RegisterResponse) *registry.RegisterResult {
	result := &registry.RegisterResult{
		StreamID:     message.StreamId,
		RegisteredAt: message.RegisteredAt,
	}
	return result
}

// NewProtoUnregisterRequest builds the gRPC request type from the payload of
// the "Unregister" endpoint of the "registry" service.
func NewProtoUnregisterRequest(payload *registry.UnregisterPayload) *registrypb.UnregisterRequest {
	message := &registrypb.UnregisterRequest{
		Name: payload.Name,
	}
	return message
}

// NewProtoEmitToolResultRequest builds the gRPC request type from the payload
// of the "EmitToolResult" endpoint of the "registry" service.
func NewProtoEmitToolResultRequest(payload *registry.EmitToolResultPayload) *registrypb.EmitToolResultRequest {
	message := &registrypb.EmitToolResultRequest{
		ToolUseId: payload.ToolUseID,
		Result: func() *anypb.Any {
			if payload.Result == nil {
				return nil
			}
			// Convert Go any to protobuf Any using JSON marshaling
			if jsonData, err := json.Marshal(payload.Result); err == nil {
				if data, err := anypb.New(&structpb.Value{
					Kind: &structpb.Value_StringValue{StringValue: string(jsonData)},
				}); err == nil {
					return data
				}
			}
			return nil
		}(),
	}
	if payload.Error != nil {
		message.Error = svcRegistryToolErrorToRegistrypbToolError(payload.Error)
	}
	return message
}

// NewProtoPongRequest builds the gRPC request type from the payload of the
// "Pong" endpoint of the "registry" service.
func NewProtoPongRequest(payload *registry.PongPayload) *registrypb.PongRequest {
	message := &registrypb.PongRequest{
		PingId:  payload.PingID,
		Toolset: payload.Toolset,
	}
	return message
}

// NewProtoListToolsetsRequest builds the gRPC request type from the payload of
// the "ListToolsets" endpoint of the "registry" service.
func NewProtoListToolsetsRequest(payload *registry.ListToolsetsPayload) *registrypb.ListToolsetsRequest {
	message := &registrypb.ListToolsetsRequest{}
	if payload.Tags != nil {
		message.Tags = make([]string, len(payload.Tags))
		for i, val := range payload.Tags {
			message.Tags[i] = val
		}
	}
	return message
}

// NewListToolsetsResult builds the result type of the "ListToolsets" endpoint
// of the "registry" service from the gRPC response type.
func NewListToolsetsResult(message *registrypb.ListToolsetsResponse) *registry.ListToolsetsResult {
	result := &registry.ListToolsetsResult{}
	if message.Toolsets != nil {
		result.Toolsets = make([]*registry.ToolsetInfo, len(message.Toolsets))
		for i, val := range message.Toolsets {
			result.Toolsets[i] = &registry.ToolsetInfo{
				Name:         val.Name,
				Description:  val.Description,
				Version:      val.Version,
				ToolCount:    int(val.ToolCount),
				RegisteredAt: val.RegisteredAt,
			}
			if val.Tags != nil {
				result.Toolsets[i].Tags = make([]string, len(val.Tags))
				for j, val := range val.Tags {
					result.Toolsets[i].Tags[j] = val
				}
			}
		}
	}
	return result
}

// NewProtoGetToolsetRequest builds the gRPC request type from the payload of
// the "GetToolset" endpoint of the "registry" service.
func NewProtoGetToolsetRequest(payload *registry.GetToolsetPayload) *registrypb.GetToolsetRequest {
	message := &registrypb.GetToolsetRequest{
		Name: payload.Name,
	}
	return message
}

// NewGetToolsetResult builds the result type of the "GetToolset" endpoint of
// the "registry" service from the gRPC response type.
func NewGetToolsetResult(message *registrypb.GetToolsetResponse) *registry.Toolset {
	result := &registry.Toolset{
		Name:         message.Name,
		Description:  message.Description,
		Version:      message.Version,
		StreamID:     message.StreamId,
		RegisteredAt: message.RegisteredAt,
	}
	if message.Tags != nil {
		result.Tags = make([]string, len(message.Tags))
		for i, val := range message.Tags {
			result.Tags[i] = val
		}
	}
	if message.Tools != nil {
		result.Tools = make([]*registry.Tool, len(message.Tools))
		for i, val := range message.Tools {
			result.Tools[i] = &registry.Tool{
				Name:         val.Name,
				Description:  val.Description,
				InputSchema:  val.InputSchema,
				OutputSchema: val.OutputSchema,
			}
		}
	}
	return result
}

// NewProtoSearchRequest builds the gRPC request type from the payload of the
// "Search" endpoint of the "registry" service.
func NewProtoSearchRequest(payload *registry.SearchPayload) *registrypb.SearchRequest {
	message := &registrypb.SearchRequest{
		Query: payload.Query,
	}
	return message
}

// NewSearchResult builds the result type of the "Search" endpoint of the
// "registry" service from the gRPC response type.
func NewSearchResult(message *registrypb.SearchResponse) *registry.SearchResult {
	result := &registry.SearchResult{}
	if message.Toolsets != nil {
		result.Toolsets = make([]*registry.ToolsetInfo, len(message.Toolsets))
		for i, val := range message.Toolsets {
			result.Toolsets[i] = &registry.ToolsetInfo{
				Name:         val.Name,
				Description:  val.Description,
				Version:      val.Version,
				ToolCount:    int(val.ToolCount),
				RegisteredAt: val.RegisteredAt,
			}
			if val.Tags != nil {
				result.Toolsets[i].Tags = make([]string, len(val.Tags))
				for j, val := range val.Tags {
					result.Toolsets[i].Tags[j] = val
				}
			}
		}
	}
	return result
}

// NewProtoCallToolRequest builds the gRPC request type from the payload of the
// "CallTool" endpoint of the "registry" service.
func NewProtoCallToolRequest(payload *registry.CallToolPayload) *registrypb.CallToolRequest {
	message := &registrypb.CallToolRequest{
		Toolset: payload.Toolset,
		Tool:    payload.Tool,
		Payload: func() *anypb.Any {
			if payload.Payload == nil {
				return nil
			}
			// Convert Go any to protobuf Any using JSON marshaling
			if jsonData, err := json.Marshal(payload.Payload); err == nil {
				if data, err := anypb.New(&structpb.Value{
					Kind: &structpb.Value_StringValue{StringValue: string(jsonData)},
				}); err == nil {
					return data
				}
			}
			return nil
		}(),
	}
	return message
}

// NewCallToolResult builds the result type of the "CallTool" endpoint of the
// "registry" service from the gRPC response type.
func NewCallToolResult(message *registrypb.CallToolResponse) *registry.CallToolResult {
	result := &registry.CallToolResult{
		ToolUseID: message.ToolUseId,
		Result: func() any {
			if message.Result != nil {
				var value structpb.Value
				if err := message.Result.UnmarshalTo(&value); err == nil {
					if str := value.GetStringValue(); str != "" {
						var result any
						if err := json.Unmarshal([]byte(str), &result); err == nil {
							return result
						}
					}
				}
			}
			return nil
		}(),
	}
	if message.Error != nil {
		result.Error = protobufRegistrypbToolErrorToRegistryToolError(message.Error)
	}
	return result
}

// ValidateRegisterResponse runs the validations defined on RegisterResponse.
func ValidateRegisterResponse(message *registrypb.RegisterResponse) (err error) {
	err = goa.MergeErrors(err, goa.ValidateFormat("message.registered_at", message.RegisteredAt, goa.FormatDateTime))
	return
}

// ValidateListToolsetsResponse runs the validations defined on
// ListToolsetsResponse.
func ValidateListToolsetsResponse(message *registrypb.ListToolsetsResponse) (err error) {
	if message.Toolsets == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("toolsets", "message"))
	}
	for _, e := range message.Toolsets {
		if e != nil {
			if err2 := ValidateToolsetInfo(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateToolsetInfo runs the validations defined on ToolsetInfo.
func ValidateToolsetInfo(elem *registrypb.ToolsetInfo) (err error) {
	if elem.ToolCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError("elem.tool_count", elem.ToolCount, 0, true))
	}
	err = goa.MergeErrors(err, goa.ValidateFormat("elem.registered_at", elem.RegisteredAt, goa.FormatDateTime))
	return
}

// ValidateGetToolsetResponse runs the validations defined on
// GetToolsetResponse.
func ValidateGetToolsetResponse(message *registrypb.GetToolsetResponse) (err error) {
	if message.Tools == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("tools", "message"))
	}
	for _, e := range message.Tools {
		if e != nil {
			if err2 := ValidateTool(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	err = goa.MergeErrors(err, goa.ValidateFormat("message.registered_at", message.RegisteredAt, goa.FormatDateTime))
	return
}

// ValidateTool runs the validations defined on Tool.
func ValidateTool(elem *registrypb.Tool) (err error) {
	if utf8.RuneCountInString(elem.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("elem.name", elem.Name, utf8.RuneCountInString(elem.Name), 1, true))
	}
	return
}

// ValidateSearchResponse runs the validations defined on SearchResponse.
func ValidateSearchResponse(message *registrypb.SearchResponse) (err error) {
	if message.Toolsets == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("toolsets", "message"))
	}
	for _, e := range message.Toolsets {
		if e != nil {
			if err2 := ValidateToolsetInfo(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// protobufRegistrypbToolErrorToRegistryToolError builds a value of type
// *registry.ToolError from a value of type *registrypb.ToolError.
func protobufRegistrypbToolErrorToRegistryToolError(v *registrypb.ToolError) *registry.ToolError {
	if v == nil {
		return nil
	}
	res := &registry.ToolError{
		Code:    v.Code,
		Message: v.Message_,
	}

	return res
}

// svcRegistryToolErrorToRegistrypbToolError builds a value of type
// *registrypb.ToolError from a value of type *registry.ToolError.
func svcRegistryToolErrorToRegistrypbToolError(v *registry.ToolError) *registrypb.ToolError {
	if v == nil {
		return nil
	}
	res := &registrypb.ToolError{
		Code:     v.Code,
		Message_: v.Message,
	}

	return res
}
