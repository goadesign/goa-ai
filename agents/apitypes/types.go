// Package apitypes provides Goa-friendly bridge types that mirror runtime and
// planner types but use primitives, pointers, and maps compatible with Goa's
// code generation. These types exist solely to cross the API boundary between
// Goa-generated services and the agents runtime.
//
// # Why These Types Exist
//
// Goa's ConvertTo/CreateFrom generation requires pointer-friendly types with
// specific characteristics that runtime/planner types cannot provide:
//   - Error fields must be concrete pointer types (*ToolError), not interface{} error
//   - Enum fields must be primitive strings, not custom types (RetryReason)
//   - Recursive types need explicit pointers (ToolError.Cause *ToolError)
//   - All fields must be exported with explicit primitive or pointer types
//
// # Usage Pattern
//
// These types are used ONLY at API boundaries in service implementations:
//
//	func (s *svc) Run(ctx context.Context, payload *gen.AgentRunPayload) (*gen.AgentRunResult, error) {
//	    // 1. Goa type → apitypes (generated by Goa)
//	    apiInput := payload.ConvertToRunInput()
//
//	    // 2. apitypes → runtime types (this package)
//	    runtimeInput := apitypes.ToRuntimeRunInput(apiInput)
//
//	    // 3. Execute with runtime types
//	    out, err := runtime.Run(ctx, runtimeInput)
//
//	    // 4. runtime types → apitypes (this package)
//	    apiOutput := apitypes.FromRuntimeRunOutput(out)
//
//	    // 5. apitypes → Goa type (generated by Goa)
//	    result := new(gen.AgentRunResult)
//	    result.CreateFromRunOutput(apiOutput)
//	    return result, nil
//	}
//
// Do NOT use apitypes in business logic, tests, or runtime internals. Use
// runtime.RunInput/Output and planner.* types directly there.
package apitypes

import (
	"fmt"
	"time"

	"goa.design/goa-ai/agents/runtime/engine"
	"goa.design/goa-ai/agents/runtime/planner"
	runtimeruntime "goa.design/goa-ai/agents/runtime/runtime"
	"goa.design/goa-ai/agents/runtime/telemetry"
	toolerrors "goa.design/goa-ai/agents/runtime/toolerrors"
)

type (
	// AgentMessage mirrors chat content exchanged between user and assistant.
	// Fields are primitive/map types so Goa can generate pointer-friendly structures.
	AgentMessage struct {
		Role    string
		Content string
		Meta    map[string]any
	}

	// PlannerAnnotation represents optional notes or reasoning steps emitted by
	// planners.
	PlannerAnnotation struct {
		Text   string
		Labels map[string]string
	}

	// ToolTelemetry mirrors telemetry.ToolTelemetry to keep generated code
	// pointer-friendly.
	ToolTelemetry struct {
		DurationMs int64
		TokensUsed int
		Model      string
		Extra      map[string]any
	}

	// ToolError mirrors toolerrors.ToolError but uses pointers so Goa conversions
	// compile.
	ToolError struct {
		Message string
		Cause   *ToolError
	}

	// RetryHint communicates planner guidance after failures so the runtime can
	// adjust behaviour.
	RetryHint struct {
		Reason             string
		Tool               string
		RestrictToTool     bool
		MissingFields      []string
		ExampleInput       map[string]any
		PriorInput         map[string]any
		ClarifyingQuestion string
		Message            string
	}

	// ToolResult summarises the outcome of a tool call provided back to the planner.
	ToolResult struct {
		Name      string
		Payload   any
		Error     *ToolError
		RetryHint *RetryHint
		Telemetry *ToolTelemetry
	}

	// RetryPolicy carries workflow retry settings provided alongside run inputs.
	// InitialInterval uses Go duration string syntax (e.g. "5s").
	RetryPolicy struct {
		MaxAttempts        int
		InitialInterval    string
		BackoffCoefficient float64
	}

	// WorkflowOptions mirrors the subset of engine start options we expose through
	// the runtime.
	WorkflowOptions struct {
		Memo             map[string]any
		SearchAttributes map[string]any
		TaskQueue        string
		RetryPolicy      *RetryPolicy
	}

	// RunInput captures everything a generated workflow needs to start or resume a run.
	RunInput struct {
		AgentID         string
		RunID           string
		SessionID       string
		TurnID          string
		Messages        []*AgentMessage
		Labels          map[string]string
		Metadata        map[string]any
		WorkflowOptions *WorkflowOptions
	}

	// RunOutput represents the final outcome returned by a run workflow.
	RunOutput struct {
		AgentID    string
		RunID      string
		Final      *AgentMessage
		ToolEvents []*ToolResult
		Notes      []*PlannerAnnotation
	}
)

// ToRuntimeRunInput converts API RunInput into the runtime representation.
// Messages are converted from pointer slices to value slices, and WorkflowOptions
// are expanded into engine-specific types. Returns an error if InitialInterval
// parsing fails.
func ToRuntimeRunInput(in *RunInput) (runtimeruntime.RunInput, error) {
	out := runtimeruntime.RunInput{
		AgentID:   in.AgentID,
		RunID:     in.RunID,
		SessionID: in.SessionID,
		TurnID:    in.TurnID,
		Labels:    cloneStringMap(in.Labels),
		Metadata:  cloneAnyMap(in.Metadata),
	}
	if len(in.Messages) > 0 {
		out.Messages = make([]planner.AgentMessage, len(in.Messages))
		for i, msg := range in.Messages {
			out.Messages[i] = toPlannerAgentMessage(msg)
		}
	}
	if in.WorkflowOptions != nil {
		opts := &runtimeruntime.WorkflowOptions{
			Memo:             cloneAnyMap(in.WorkflowOptions.Memo),
			SearchAttributes: cloneAnyMap(in.WorkflowOptions.SearchAttributes),
			TaskQueue:        in.WorkflowOptions.TaskQueue,
		}
		if in.WorkflowOptions.RetryPolicy != nil {
			policy, err := toEngineRetryPolicy(in.WorkflowOptions.RetryPolicy)
			if err != nil {
				return runtimeruntime.RunInput{}, fmt.Errorf("convert retry policy: %w", err)
			}
			opts.RetryPolicy = policy
		}
		out.WorkflowOptions = opts
	}
	return out, nil
}

// FromRuntimeRunInput converts runtime RunInput into the API representation.
// Value slices are converted to pointer slices for Goa compatibility.
func FromRuntimeRunInput(in runtimeruntime.RunInput) *RunInput {
	out := &RunInput{
		AgentID:   in.AgentID,
		RunID:     in.RunID,
		SessionID: in.SessionID,
		TurnID:    in.TurnID,
		Labels:    cloneStringMap(in.Labels),
		Metadata:  cloneAnyMap(in.Metadata),
	}
	if len(in.Messages) > 0 {
		out.Messages = make([]*AgentMessage, len(in.Messages))
		for i, msg := range in.Messages {
			out.Messages[i] = FromPlannerAgentMessage(msg)
		}
	}
	if in.WorkflowOptions != nil {
		out.WorkflowOptions = &WorkflowOptions{
			Memo:             cloneAnyMap(in.WorkflowOptions.Memo),
			SearchAttributes: cloneAnyMap(in.WorkflowOptions.SearchAttributes),
			TaskQueue:        in.WorkflowOptions.TaskQueue,
			RetryPolicy:      fromEngineRetryPolicy(in.WorkflowOptions.RetryPolicy),
		}
	}
	return out
}

// ToRuntimeRunOutput converts API RunOutput into the runtime representation.
func ToRuntimeRunOutput(in *RunOutput) runtimeruntime.RunOutput {
    if in == nil {
        return runtimeruntime.RunOutput{}
    }
    out := runtimeruntime.RunOutput{
        AgentID: in.AgentID,
        RunID:   in.RunID,
    }
	if in.Final != nil {
		out.Final = toPlannerAgentMessage(in.Final)
	}
	if len(in.ToolEvents) > 0 {
		out.ToolEvents = make([]planner.ToolResult, len(in.ToolEvents))
		for i, ev := range in.ToolEvents {
			out.ToolEvents[i] = toPlannerToolResult(ev)
		}
	}
	if len(in.Notes) > 0 {
		out.Notes = make([]planner.PlannerAnnotation, len(in.Notes))
		for i, note := range in.Notes {
			out.Notes[i] = planner.PlannerAnnotation{
				Text:   note.Text,
				Labels: cloneStringMap(note.Labels),
			}
		}
	}
	return out
}

// FromRuntimeRunOutput converts runtime RunOutput into the API representation.
func FromRuntimeRunOutput(in runtimeruntime.RunOutput) *RunOutput {
	out := &RunOutput{
		AgentID: in.AgentID,
		RunID:   in.RunID,
	}
	out.Final = FromPlannerAgentMessage(in.Final)
	if len(in.ToolEvents) > 0 {
		out.ToolEvents = make([]*ToolResult, len(in.ToolEvents))
		for i, ev := range in.ToolEvents {
			out.ToolEvents[i] = FromPlannerToolResult(ev)
		}
	}
	if len(in.Notes) > 0 {
		out.Notes = make([]*PlannerAnnotation, len(in.Notes))
		for i, note := range in.Notes {
			out.Notes[i] = &PlannerAnnotation{
				Text:   note.Text,
				Labels: cloneStringMap(note.Labels),
			}
		}
	}
	return out
}

// FromPlannerAgentMessage converts planner AgentMessage into the API representation.
func FromPlannerAgentMessage(msg planner.AgentMessage) *AgentMessage {
	return &AgentMessage{
		Role:    msg.Role,
		Content: msg.Content,
		Meta:    cloneAnyMap(msg.Meta),
	}
}

// ToPlannerAgentMessages converts API messages into planner AgentMessages.
func ToPlannerAgentMessages(msgs []*AgentMessage) []planner.AgentMessage {
	if len(msgs) == 0 {
		return nil
	}
	out := make([]planner.AgentMessage, len(msgs))
	for i, msg := range msgs {
		out[i] = toPlannerAgentMessage(msg)
	}
	return out
}

// FromPlannerToolResult converts planner ToolResult into the API representation.
func FromPlannerToolResult(res planner.ToolResult) *ToolResult {
	out := &ToolResult{
		Name:      res.Name,
		Payload:   res.Payload,
		RetryHint: FromPlannerRetryHint(res.RetryHint),
	}
	if res.Error != nil {
		out.Error = fromToolError(planner.ToolErrorFromError(res.Error))
	}
	if res.Telemetry != nil {
		out.Telemetry = fromToolTelemetry(res.Telemetry)
	}
	return out
}

// ToPlannerToolResults converts API tool results into planner ToolResults.
func ToPlannerToolResults(res []*ToolResult) []planner.ToolResult {
	if len(res) == 0 {
		return nil
	}
	out := make([]planner.ToolResult, len(res))
	for i, r := range res {
		out[i] = toPlannerToolResult(r)
	}
	return out
}

// FromPlannerRetryHint converts planner RetryHint into the API representation.
func FromPlannerRetryHint(hint *planner.RetryHint) *RetryHint {
	if hint == nil {
		return nil
	}
	return &RetryHint{
		Reason:             string(hint.Reason),
		Tool:               hint.Tool,
		RestrictToTool:     hint.RestrictToTool,
		MissingFields:      cloneStringSlice(hint.MissingFields),
		ExampleInput:       cloneAnyMap(hint.ExampleInput),
		PriorInput:         cloneAnyMap(hint.PriorInput),
		ClarifyingQuestion: hint.ClarifyingQuestion,
		Message:            hint.Message,
	}
}

// ToPlannerRetryHint converts API retry hint into the planner representation.
func ToPlannerRetryHint(hint *RetryHint) *planner.RetryHint {
	if hint == nil {
		return nil
	}
	return &planner.RetryHint{
		Reason:             planner.RetryReason(hint.Reason),
		Tool:               hint.Tool,
		RestrictToTool:     hint.RestrictToTool,
		MissingFields:      cloneStringSlice(hint.MissingFields),
		ExampleInput:       cloneAnyMap(hint.ExampleInput),
		PriorInput:         cloneAnyMap(hint.PriorInput),
		ClarifyingQuestion: hint.ClarifyingQuestion,
		Message:            hint.Message,
	}
}

func toPlannerAgentMessage(msg *AgentMessage) planner.AgentMessage {
	return planner.AgentMessage{
		Role:    msg.Role,
		Content: msg.Content,
		Meta:    cloneAnyMap(msg.Meta),
	}
}

func toPlannerToolResult(res *ToolResult) planner.ToolResult {
	out := planner.ToolResult{
		Name:      res.Name,
		Payload:   res.Payload,
		RetryHint: ToPlannerRetryHint(res.RetryHint),
	}
	if res.Error != nil {
		out.Error = toToolError(res.Error)
	}
	if res.Telemetry != nil {
		out.Telemetry = toToolTelemetry(res.Telemetry)
	}
	return out
}

func fromToolTelemetry(t *telemetry.ToolTelemetry) *ToolTelemetry {
	if t == nil {
		return nil
	}
	return &ToolTelemetry{
		DurationMs: t.DurationMs,
		TokensUsed: t.TokensUsed,
		Model:      t.Model,
		Extra:      cloneAnyMap(t.Extra),
	}
}

func toToolTelemetry(t *ToolTelemetry) *telemetry.ToolTelemetry {
	if t == nil {
		return nil
	}
	return &telemetry.ToolTelemetry{
		DurationMs: t.DurationMs,
		TokensUsed: t.TokensUsed,
		Model:      t.Model,
		Extra:      cloneAnyMap(t.Extra),
	}
}

func fromToolError(err *planner.ToolError) *ToolError {
	if err == nil {
		return nil
	}
	return &ToolError{
		Message: err.Message,
		Cause:   fromToolError(err.Cause),
	}
}

func toToolError(err *ToolError) *toolerrors.ToolError {
	if err == nil {
		return nil
	}
	out := &toolerrors.ToolError{
		Message: err.Message,
	}
	if err.Cause != nil {
		out.Cause = toToolError(err.Cause)
	}
	return out
}

func toEngineRetryPolicy(policy *RetryPolicy) (engine.RetryPolicy, error) {
	out := engine.RetryPolicy{
		MaxAttempts:        policy.MaxAttempts,
		BackoffCoefficient: policy.BackoffCoefficient,
	}
	if policy.InitialInterval != "" {
		d, err := time.ParseDuration(policy.InitialInterval)
		if err != nil {
			return engine.RetryPolicy{}, fmt.Errorf("parse initial_interval %q: %w", policy.InitialInterval, err)
		}
		out.InitialInterval = d
	}
	return out, nil
}

func fromEngineRetryPolicy(policy engine.RetryPolicy) *RetryPolicy {
	if isZeroEngineRetryPolicy(policy) {
		return nil
	}
	out := &RetryPolicy{
		MaxAttempts:        policy.MaxAttempts,
		BackoffCoefficient: policy.BackoffCoefficient,
	}
	if policy.InitialInterval > 0 {
		out.InitialInterval = policy.InitialInterval.String()
	}
	return out
}

func isZeroEngineRetryPolicy(policy engine.RetryPolicy) bool {
	return policy.MaxAttempts == 0 && policy.InitialInterval == 0 && policy.BackoffCoefficient == 0
}

func cloneAnyMap(src map[string]any) map[string]any {
	if len(src) == 0 {
		return nil
	}
	dst := make(map[string]any, len(src))
	for k, v := range src {
		dst[k] = v
	}
	return dst
}

func cloneStringMap(src map[string]string) map[string]string {
	if len(src) == 0 {
		return nil
	}
	dst := make(map[string]string, len(src))
	for k, v := range src {
		dst[k] = v
	}
	return dst
}

func cloneStringSlice(src []string) []string {
	if len(src) == 0 {
		return nil
	}
	dst := make([]string, len(src))
	copy(dst, src)
	return dst
}
