## MCP Plugin for Goa

Build MCP servers from your Goa designs with almost no extra work. This plugin reuses Goa’s service and JSON‑RPC generators, adds a thin MCP layer, and places the results under a clean MCP directory layout.

### What you get
- MCP endpoints mapped from your Goa service (tools, resources, prompts)
- JSON‑RPC transport for MCP (SSE included when methods stream)
- MCP client types and helper files (adapter and client wrapper) for straightforward wiring

### How it works
For each service annotated with MCP, the plugin:
1) Derives a temporary MCP‑specific service expression from your DSL (see `expr/mcp.go`).
2) Runs standard Goa generators:
   - Service layer via `codegen/service` (service, endpoints, client)
   - JSON‑RPC transport via `jsonrpc/codegen` (server, client, types; SSE when streaming)
   - JSON‑RPC client CLI via `jsonrpccodegen.ClientCLIFiles`
3) Applies small, deterministic transformations so files land under MCP paths and import MCP packages.

We compose on top of Goa—no forks, minimal templates, and predictable output.

### Layout
- Service layer (kept as generated by Goa)
- JSON‑RPC for MCP: `gen/jsonrpc/mcp_<service>/...`

Note: Goa ultimately decides filenames; we transform whatever it emits into the MCP layout.

### Streaming
No custom streaming templates. When your methods stream, Goa’s JSON‑RPC generator emits the SSE stack. We simply adjust paths/imports so it lives under the MCP tree. Optionally, the adapter can emit structured JSON content items for stream events (type `resource` with `application/json`) when enabled; by default, events are text items containing JSON strings.

### Protocol version
Set the MCP protocol version in your design using the DSL option on `MCPServer`:

```go
var _ = Service("assistant", func() {
    Description("MCP-enabled assistant service")
    mcp.MCPServer("assistant-mcp", "1.0.0", mcp.ProtocolVersion("2025-06-18"))
    JSONRPC(func() { POST("/rpc") })
})
```

The generator emits a constant `DefaultProtocolVersion` in `gen/mcp_<service>/protocol_version.go`. The adapter validates `initialize.protocolVersion` against this default or an explicit adapter option override.

### Adapter options
The generated `MCPAdapterOptions` provides configuration hooks:

- Logger: `func(ctx context.Context, event string, details any)` to observe adapter lifecycle.
- ErrorMapper: `func(error) error` to normalize errors to JSON‑RPC codes.
- AllowedResourceURIs, DeniedResourceURIs: simple allow/deny lists for resource URIs (denylist wins). When allowlist is empty, all URIs are allowed by default.
- StructuredStreamJSON: when true, stream events/results that are JSON are emitted as `resource` items with `application/json`.
- ProtocolVersionOverride: override `DefaultProtocolVersion` at construction time.

### Client wrapper
The generated client wrapper routes mapped methods through the MCP JSON‑RPC service while unmapped methods fall back to the original JSON‑RPC transport. Use it to adopt MCP incrementally without changing existing callers.

### Tool Input Schema
For each tool with a non-empty payload, the plugin derives a compact JSON
Schema from the Goa attribute and exposes it in `tools/list` under
`inputSchema`. This aims to provide client-side hints; it is not a full
validation schema but covers common primitives, arrays, objects (with required
fields), enums and base64-encoded bytes.

### Cross‑platform paths
Path handling relies on `filepath` and Goa’s codegen helpers directly. Templates and generators use `filepath.Join` and Goa’s path data.

### Header updates
The plugin relies on Goa’s generators to emit correct imports; no header rewrite helpers are used. Where additional files are generated (e.g., MCP adapter, protocol version), headers are produced with `codegen.Header`.

### Pure MCP mode (optional)
Projects can choose MCP‑only generation via a future plugin option or environment flag. By default, original transports and clients are still generated; the example phase mounts the MCP service to avoid runtime conflicts.

### Limits and next steps
- The adapter reuses Goa encoders/decoders for JSON‑RPC to avoid drift and hardcoding.
- Mixed (MCP + other transports) ergonomics will evolve; we currently bias toward separation via the example wiring.

### Contributing
- Add MCP concepts in `expr/mcp.go` and update the MCP expression builder
- Customize header imports or titles in `updateHeader` (`codegen/generate.go`)
- Keep new templates small and transport‑agnostic; compose on Goa JSON‑RPC outputs

### Summary
This plugin gives you MCP with familiar Goa patterns, minimal surface area, and a directory layout that feels natural. It’s accurate, easy to maintain, and designed to evolve alongside Goa.
### Resource URI → Payload Mapping
When an MCP resource has an underlying method with a payload, the adapter maps
URI query parameters into that payload using Goa’s JSON‑RPC decoders:

- Query parameters are collected into a JSON object where keys are parameter
  names and values are best-effort typed (bool/int/float); repeated parameters
  produce arrays.
- The JSON object is then passed to the Goa-generated JSON‑RPC request decoder
  for the original method, ensuring consistent field/tag handling.
- Unknown fields are ignored by the decoder; service defaults still apply.

This keeps resource calls simple (`resource://name?field=value`) while reusing
the same decoding pipeline as tools.

### Security considerations
- Resource policy: use deny/allow lists to constrain which URIs can be read; denylist takes precedence. If the allowlist is empty, all URIs are allowed by default.
- Logging: if you configure a Logger, avoid logging sensitive payloads and results in production.
- Protocol version: clients must send `initialize.protocolVersion` matching the service’s configured version. You can override the default via adapter options for compatibility testing.
