## MCP Plugin for Goa

Build MCP servers from your Goa designs with almost no extra work. This plugin reuses Goa’s service and JSON‑RPC generators, adds a thin MCP layer, and places the results under a clean MCP directory layout.

### What you get
- MCP endpoints mapped from your Goa service (tools, resources, prompts)
- JSON‑RPC transport for MCP (SSE included when methods stream)
- MCP client types and helper files (adapter and client wrapper) for straightforward wiring

### How it works
For each service annotated with MCP, the plugin:
1) Derives a temporary MCP‑specific service expression from your DSL (see `expr/mcp.go`).
2) Runs standard Goa generators:
   - Service layer via `codegen/service` (service, endpoints, client)
   - JSON‑RPC transport via `jsonrpc/codegen` (server, client, types; SSE when streaming)
   - JSON‑RPC client CLI via `jsonrpccodegen.ClientCLIFiles`
3) Applies small, deterministic transformations so files land under MCP paths and import MCP packages.

We compose on top of Goa—no forks, minimal templates, and predictable output.

### Layout
- Service layer (kept as generated by Goa)
- JSON‑RPC for MCP: `gen/jsonrpc/mcp_<service>/...`

Note: Goa ultimately decides filenames; we transform whatever it emits into the MCP layout.

### Streaming
No custom streaming templates. When your methods stream, Goa’s JSON‑RPC generator emits the SSE stack. We simply adjust paths/imports so it lives under the MCP tree. Optionally, the adapter can emit structured JSON content items for stream events (type `resource` with `application/json`) when enabled; by default, events are text items containing JSON strings.

### Protocol version
Set the MCP protocol version in your design using the DSL option on `MCPServer`:

```go
var _ = Service("assistant", func() {
    Description("MCP-enabled assistant service")
    mcp.MCPServer("assistant-mcp", "1.0.0", mcp.ProtocolVersion("2025-06-18"))
    JSONRPC(func() { POST("/rpc") })
})
```

The generator emits a constant `DefaultProtocolVersion` in `gen/mcp_<service>/protocol_version.go`. The adapter validates `initialize.protocolVersion` against this default or an explicit adapter option override.

### Adapter options
The generated `MCPAdapterOptions` provides configuration hooks:

- Logger: `func(ctx context.Context, event string, details any)` to observe adapter lifecycle.
- ErrorMapper: `func(error) error` to normalize errors to JSON‑RPC codes.
- AllowedResourceURIs, DeniedResourceURIs: simple allow/deny lists for resource URIs (denylist wins). When allowlist is empty, all URIs are allowed by default.
- StructuredStreamJSON: when true, stream events/results that are JSON are emitted as `resource` items with `application/json`.
- ProtocolVersionOverride: override `DefaultProtocolVersion` at construction time.

### Client wrapper
The generated client wrapper routes mapped methods through the MCP JSON‑RPC service while unmapped methods fall back to the original JSON‑RPC transport. Use it to adopt MCP incrementally without changing existing callers.

### Tool Input Schema
For each tool with a non-empty payload, the plugin derives a compact JSON
Schema from the Goa attribute and exposes it in `tools/list` under
`inputSchema`. This aims to provide client-side hints; it is not a full
validation schema but covers common primitives, arrays, objects (with required
fields), enums and base64-encoded bytes.

### Cross‑platform paths
Path handling relies on `filepath` and Goa’s codegen helpers directly. Templates and generators use `filepath.Join` and Goa’s path data.

### Header updates
The plugin relies on Goa’s generators to emit correct imports; no header rewrite helpers are used. Where additional files are generated (e.g., MCP adapter, protocol version), headers are produced with `codegen.Header`.

### Pure MCP mode (optional)
Projects can choose MCP‑only generation via a future plugin option or environment flag. By default, original transports and clients are still generated; the example phase mounts the MCP service to avoid runtime conflicts.

### Limits and next steps
- The adapter reuses Goa encoders/decoders for JSON‑RPC to avoid drift and hardcoding.
- Mixed (MCP + other transports) ergonomics will evolve; we currently bias toward separation via the example wiring.

### Contributing
- Add MCP concepts in `expr/mcp.go` and update the MCP expression builder
- Customize header imports or titles in `updateHeader` (`codegen/generate.go`)
- Keep new templates small and transport‑agnostic; compose on Goa JSON‑RPC outputs

### Summary
This plugin gives you MCP with familiar Goa patterns, minimal surface area, and a directory layout that feels natural. It’s accurate, easy to maintain, and designed to evolve alongside Goa.
### Resource URI → Payload Mapping
When an MCP resource has an underlying method with a payload, the adapter maps
URI query parameters into that payload using Goa’s JSON‑RPC decoders:

- Query parameters are collected into a JSON object where keys are parameter
  names and values are best-effort typed (bool/int/float); repeated parameters
  produce arrays.
- The JSON object is then passed to the Goa-generated JSON‑RPC request decoder
  for the original method, ensuring consistent field/tag handling.
- Unknown fields are ignored by the decoder; service defaults still apply.

This keeps resource calls simple (`resource://name?field=value`) while reusing
the same decoding pipeline as tools.

---

## Agents Quickstart & Example Scaffold

In addition to MCP features, the agents plugin improves the developer experience after code generation:

- A contextual quickstart file `AGENTS_QUICKSTART.md` is emitted at the module root on `goa gen`, summarizing what was generated and how to wire it. To opt out, invoke `agentsdsl.DisableAgentDocs()` inside your API DSL.
- The `goa example` phase generates application-owned scaffold under `internal/agents/` instead of modifying your `main` package:
  - `internal/agents/bootstrap/bootstrap.go`: constructs a minimal runtime and registers generated agents. Edit and maintain this file; it is not re-generated.
  - `internal/agents/<agent>/planner/planner.go`: planner stub implementing `planner.PlanStart`/`PlanResume` with header comments explaining its role.
  - `internal/agents/<agent>/toolsets/<toolset>/adapter.go`: stubs for mapping method‑backed tools to service types.

From your `cmd` entrypoint, import and use the bootstrap:

```go
rt, cleanup, err := bootstrap.New(ctx)
if err != nil { log.Fatal(err) }
defer cleanup()
// Start runs or serve transports using rt...
```

This pattern keeps generated code under `gen/` while giving you a clean, editable scaffold in `internal/agents/` for planners and adapters.

### Security considerations
- Resource policy: use deny/allow lists to constrain which URIs can be read; denylist takes precedence. If the allowlist is empty, all URIs are allowed by default.
- Logging: if you configure a Logger, avoid logging sensitive payloads and results in production.
- Protocol version: clients must send `initialize.protocolVersion` matching the service’s configured version. You can override the default via adapter options for compatibility testing.

### Initialization policy
Clients must call `initialize` before invoking any method that depends on server state (`tools/list`, `tools/call`, `resources/*`, `prompts/*`, subscriptions). `ping` may be called pre-initialization and is intended for health checks only.

### Error code mapping
The adapter maps Goa `ServiceError` with name `invalid_params` to JSON-RPC `-32602`, `method_not_found` to `-32601`, and otherwise defaults to `-32603` (internal). SSE error events carry the same JSON-RPC codes and messages as non-streaming responses.

### Client typed errors and retry
Generated clients surface JSON-RPC failures from streaming and non-streaming paths as typed errors to simplify handling:

- Streaming (`tools/call`, `events/stream`): client stream `Recv` returns a `JSONRPCError` (with fields `Code`, `Message`) when the server emits a JSON-RPC error event.
- Invalid parameters (`-32602`) are classified as retryable for certain endpoints:
  - `tools/call`: wrapped as `retry.RetryableError` enriched with a repair prompt built from the tool’s input schema and a built-in example. This enables agent-side auto-repair.
  - `prompts/get`: a decode helper mirrors the same behavior and returns `retry.RetryableError` on `-32602`.

This keeps error handling explicit and structured while enabling ergonomic auto-retry flows in clients.

### Accept negotiation
The JSON-RPC server mounts a single `POST /rpc` endpoint. The server negotiates streaming based on the `Accept` header: if it contains `text/event-stream`, compatible methods (e.g., `tools/call`) are served over SSE; otherwise, regular JSON responses are sent. This can be generalized in the future for additional streaming methods without endpoint proliferation.

### Content item semantics
When `StructuredStreamJSON` is true and the payload is valid JSON, the adapter emits items with `type: "text"` and `mimeType: "application/json"` to convey inline JSON efficiently. For binary or external resources, prefer `type: "resource"` with `data` (base64) or a `uri`.

### Client parameter forwarding
For resource-backed endpoints with payloads, the generated client adapter forwards original payload fields via query string so that MCP `resources/read` can reconstruct the original payload. This preserves Goa validations and keeps MCP resources simple.
